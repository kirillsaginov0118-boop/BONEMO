<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>BONEMO - Voice Recording Studio</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI0OC4yODEyOCIgaGVpZ2h0PSIyOS44NzgzOSIgdmlld0JveD0iMCwwLDQ4LjI4MTI4LDI5Ljg3ODM5Ij48ZGVmcz48bGluZWFyR3JhZGllbnQgeDE9IjIyOC45MzM2IiB5MT0iMTcwLjA3NDU1IiB4Mj0iMjI4LjkzMzYiIHkyPSIyMTMuNDg1MTUiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBpZD0iY29sb3ItMSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMDBmZmNlIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMjQzODM0Ii8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgeDE9IjI0MC4zOTQ0OSIgeTE9IjE2Ny4yNjU0MSIgeDI9IjI0MC4zOTQ0OSIgeTI9IjE5MC43NzgiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBpZD0iY29sb3ItMiI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjNzhmZmU1Ii8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgeDE9IjIzNC4xNDgzNiIgeTE9IjE4Mi45NzkwOSIgeDI9IjIzNC4xNDgzNiIgeTI9IjE5MS45MjU5OSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGlkPSJjb2xvci0zIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmZmZmYiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM3OGZmZTUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCB4MT0iMjUzLjg2NDE3IiB5MT0iMTcwLjgyMDgxIiB4Mj0iMjUzLjg2NDE3IiB5Mj0iMjE0LjIzMTQyIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgaWQ9ImNvbG9yLTQiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzAwZmZjZSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2EyZmZlZSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMTcuMjU4MjQsLTE2Ny4yMjg5OSkiPjxnIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjMwLjUyOTkyLDE4MC4wMzMzN2wtMy4yMjIyMSwtNC43NTIwOWwzLjc0NTE5LC02LjMwMjg5bDUuMjA2NzMsMy43NDUxOWwwLjczMDc3LDYuMDI4ODR6IiBmaWxsPSIjMDBmZmNlIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjMzLjA2MDQxLDE4OS4zMzExOWwtNS45NDk3Miw3LjAyOTkzbC05Ljg1MjQ1LC04LjkwMTg0YzAsMCA2LjU2NjE1LC0yLjg2NzY5IDcuNjgyMzksLTcuOTU2MDRjMS4yMTkyLC01LjU1NzY4IDEuNzI3NjUsLTkuNDI4NyAxLjcyNzY1LC05LjQyODdsNC43NSwyLjAwOTYydjQuOTMyNjl6IiBmaWxsPSJ1cmwoI2NvbG9yLTEpIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjI5LjE1MjQ5LDE3MC44Nzk4MWwtMi4xMjcxLDMuODM0OTFsMS44Mzg4NCwzLjQ4NDIxbC0wLjUzMTMyLDAuNTEwNDVsLTIuMDg1OSwtNC4zMDcyMmwyLjQ5NjI4LC00LjUwNDQ1bDEuNjQ2NjMsMC40MzkzbC0wLjUxOTM5LDAuNjYxOXoiIGZpbGw9IiNmZjAwOTQiIHN0cm9rZT0iI2I2NTkxYiIvPjxwYXRoIGQ9Ik0yMjcuOTM2OTEsMTg3Ljc0MTc1bDAuMTMwOCwtNC4xNTQwNmwwLjY5MzQ4LC0zLjA0OThsLTAuNzA1NDIsLTMuNDg5ODlsMC4wMDUxMSwtMi4zMjE2M2w4LjkxMTY1LC03LjQ2MDk2bDEwLjkwODEzLDIuNzc0NDVsNC45NzE0MiwxMC4xNDA1N2wtMS42MTE0Myw4LjgwMDg4bC0xMC4yOTQ3NiwxLjc5NjY5eiIgZmlsbD0idXJsKCNjb2xvci0yKSIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTIyOC41NjEyOSwxNzcuNTc4ODJsLTAuMjcxMDcsLTIuNzU2MjNsOS44NjQ0LC0wLjM5NjI4eiIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTI0MS4wMzA4MSwxOTAuNzk2OTJsNS42ODk5NywtOS42NDQwMWw0LjUwMDU0LC00LjQ2ODM5bDAuMjg5MzIsMTIuMjgwMDV6IiBmaWxsPSIjNWNlNmNiIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjM4LjQwOTM1LDE3NC40NTAxMmw5LjYxNDA4LC00LjQyOTQzbDQuMDEzNjQsNy43NjExOGwtNS4zNDc2OSwzLjI5OTZ6IiBmaWxsPSIjYjVmZmYxIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjI4LjA0ODQzLDE4Ny42NjA1NmwtMC4wMjIwMiwtNC4xOTAyOGwwLjczNDA2LC0yLjk3NDU5bC0wLjUyMDI1LC0yLjc4MDY4bDEwLjA1Nzk3LC0zLjQxNjU1bDguNTY3NjksNi44NTg3NGwtNS45NjkyNCw5LjQ0ODYzeiIgZmlsbD0iIzg1ZmZlNyIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTIyNy44ODU1MiwxOTEuMTEyNjRsNC4zOTIxMSwtNy4zMjAxOWw2LjUwNjg0LC0wLjgxMzM2bDEuNjI2NzEsOC45NDY5eiIgZmlsbD0idXJsKCNjb2xvci0zKSIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTIzNS41MDg1LDE4Ni40NzYzNGwzLjM1MDM1LC0zLjIxOTM5bDEuNDg5MzgsOC42NjQ0MnoiIGZpbGw9IiNiNWZmZjEiIHN0cm9rZT0iI2I2NTkxYiIvPjxwYXRoIGQ9Ik0yNDUuODA3MzcsMTc5LjQ5ODY5bDAuNzMwNzcsLTYuMDI4ODRsNS4yMDY3MywtMy43NDUxOWwzLjc0NTE5LDYuMzAyODlsLTMuMjIyMjEsNC43NTIxeiIgZmlsbD0iIzAwZmZjZSIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTI1MS4zNzk0OSwxNzcuNzYzMTJ2LTQuOTMyNjlsNC43NDk5OSwtMi4wMDk2MWMwLDAgMC41MDg0NSwzLjg3MTAxIDEuNzI3NjUsOS40Mjg3YzEuMTE2MjUsNS4wODgzNSA3LjY4MjM5LDcuOTU2MDQgNy42ODIzOSw3Ljk1NjA0bC05Ljg1MjQ1LDguOTAxODRsLTUuOTQ5NzEsLTcuMDI5OTN6IiBmaWxsPSJ1cmwoI2NvbG9yLTQpIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjQ5LjY5Mjk1LDE3Ni43MTk5N2wyLjQ0MDM3LC02Ljg1NzY2bDEuMDAzMTMsMC4wNDM1OGwxLjU1MzE3LDEuNTUyMWwtMC45NDI0LDAuMzUzNTdsLTEuMDAzNDgsLTAuNzgwNjNsLTEuOTYwNDksNS43MzI2MmwwLjUxNzE5LDEuMTMwOTNsMC4yMjEwMSwyLjAwOTIxeiIgZmlsbD0iI2ZmMDA5NCIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTI0OC4yNzQ1NCwxNjcuNjE0MjF2LTAuMDY3NjJoMC4xMzUyNnYwLjA2NzYyeiIgZmlsbD0iI2ZmMDA5NCIgc3Ryb2tlPSJub25lIi8+PHBhdGggZD0iTTIyOC4xMDEyNSwxNzQuNjk3NDdsOC45NDQzMywtNy40Njg0OGwxMC45MzAyMSwyLjc1NzQ0bDEuMDE3NDMsMS45OTI4OWwtMS41MDcyOSwtMS43Mjg3OWwtMTAuMzMwMjIsLTIuNDA1MjlsLTguMTEyMjYsNi42NjE3N2wtMC4zNTc5Miw2LjExMzhsLTAuODg3MiwtMy40MDY5NnoiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0iI2I2NTkxYiIvPjxwYXRoIGQ9Ik0yMjcuODgyNTUsMTkxLjA4NzM5bDMuNjY0NzMsLTUuMzY4NWwzLjc2MTE3LDAuNzcxNTJsNS4wNDcwMyw1LjM2ODV6IiBmaWxsPSIjODVmZmU3IiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjI4LjQ2OTg2LDE5MC4wNjg2MWwzLjU3ODg5LC02LjU2MTA4bDYuNzg3NzcsLTAuNTU2NTJsMS41NjE0OCw5LjAzOTA0bC0yLjAxMTg5LC04LjU3NzY5bC01LjMxOTg1LDAuNTE0MTR6IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjM1LjI5MTYxLDE4Ni40ODc0OWwtMy40ODI4OSwtMC42OTY1OGwzLjYxNTU4LDAuNDMxMjFsMy4xODQzNiwzLjU4MjQxeiIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTI0Ni41NjM1MiwxODEuMTMxNTJsLTguNDQxOTUsLTYuNDk5MThsLTkuODYxMTUsMy4wNjQ1NWw5LjkzMjEyLC0zLjQ0MjEzbDguNzEwOTksNi45MDUzNmwtMy41MjMyNCw1LjYyNTc0eiIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTIzOS41ODU2MSwxODQuNjU0NjFsLTEuNDg5NDIsLTMuOTczMTNsMS43NTU1LC0zLjE3MzE1bDQuOTQxMDYsLTAuMDA1NDVsMy41NzM2NiwzLjA4NDQzbC0xLjgyNDU5LDMuODc3MjR6IiBmaWxsPSIjMzE3YzZkIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjI4LjAxMjMxLDE4My41MzQ2NWwwLjcwNDI1LC0zLjAyOTkxbC0wLjYzNzQxLC0zLjQ3NDc2bDIuNjY5NTEsLTAuMzQyOTdsMS41MjEwMSwzLjE5ODQ2bC0xLjU5NjUxLDMuNDk3MTJ6IiBmaWxsPSIjMzE3YzZkIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjI4LjAyNjc3LDE4My41MTc5bDIuNTM2MTcsLTAuMjM5NmwxLjczNTE1LC0zLjM4NjM0bC0xLjQzMDAzLDMuNTY3OTZ6IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjM5LjU1MDMyLDE4NC42ODkxOGwtMS40NTcwOSwtMy45MjAwMWwxLjYzMTAxLDMuNjY4NzlsNi43MDU2NiwtMC4yMzE5bDEuOTcxMTEsLTMuNTU1NzNsLTEuODM1ODQsMy45MDM1OHoiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0iI2I2NTkxYiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjIyLjc0MTc1NTg5NDI5NjA5OjEyLjc3MTAwODc2MjMzMDE1NS0tPg==">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@300;400;600;700&family=Noto+Sans+JP:wght@400;700&display=swap');

  :root {
    --bg: #0a0a0f; --bg2: #111118; --bg3: #1a1a24;
    --accent: #00ffcc; --accent2: #ff4466; --accent3: #ffcc00;
    --text: #ddeeff; --muted: #556677; --border: #223344;
    --good: #00ff88; --warn: #ffaa00; --bad: #ff4466;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg); color: var(--text);
    font-family: 'Rajdhani', 'Noto Sans JP', sans-serif;
    font-size: 16px; min-height: 100vh; overflow-x: hidden;
  }

  body::before {
    content: ''; position: fixed; inset: 0;
    background: repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.08) 2px,rgba(0,0,0,0.08) 4px);
    pointer-events: none; z-index: 9999;
  }

  h1 { font-family: 'Share Tech Mono', monospace; font-size: 2.2rem; color: var(--accent); letter-spacing: 0.15em; text-shadow: 0 0 20px var(--accent), 0 0 40px rgba(0,255,204,0.3); }
  .subtitle { font-family: 'Share Tech Mono', monospace; font-size: 0.75rem; color: var(--muted); letter-spacing: 0.2em; margin-top: 2px; }

  header { padding: 18px 30px; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 20px; background: linear-gradient(135deg, var(--bg2), var(--bg)); }
  .skull { font-size: 2.5rem; position: relative; z-index: 10000; cursor: pointer; }
  .skull:hover svg { filter: brightness(1.15); }

  .app { display: grid; grid-template-columns: 280px 1fr 220px; grid-template-rows: auto 1fr auto; height: calc(100vh - 73px); }

  .sidebar { grid-row: 1 / 3; border-right: 1px solid var(--border); background: var(--bg2); display: flex; flex-direction: column; overflow-y: auto; overflow-x: hidden; }
  .sidebar::-webkit-scrollbar { width: 4px; }
  .sidebar::-webkit-scrollbar-track { background: var(--bg); }
  .sidebar::-webkit-scrollbar-thumb { background: var(--border); }
  .sidebar-section { padding: 16px; border-bottom: 1px solid var(--border); flex-shrink: 0; }
  .sidebar-section h3 { font-family: 'Share Tech Mono', monospace; font-size: 0.7rem; color: var(--muted); letter-spacing: 0.2em; margin-bottom: 10px; text-transform: uppercase; }

  .right-sidebar { grid-column: 3; grid-row: 1 / 3; border-left: 1px solid var(--border); background: var(--bg2); display: flex; flex-direction: column; overflow: hidden; }
  .right-sidebar-header { padding: 10px 16px 6px; font-family: 'Share Tech Mono', monospace; font-size: 0.65rem; color: var(--muted); letter-spacing: 0.15em; flex-shrink: 0; border-bottom: 1px solid var(--border); }
  .right-sidebar .word-list { flex: 1; min-height: 0; }

  .btn { display: inline-flex; align-items: center; gap: 8px; padding: 8px 14px; border: 1px solid var(--border); background: var(--bg3); color: var(--text); font-family: 'Rajdhani', 'Noto Sans JP', sans-serif; font-size: 0.9rem; font-weight: 600; cursor: pointer; transition: all 0.15s; letter-spacing: 0.05em; border-radius: 2px; width: 100%; text-align: left; justify-content: flex-start; }
  .btn:hover { border-color: var(--accent); color: var(--accent); background: rgba(0,255,204,0.05); box-shadow: 0 0 10px rgba(0,255,204,0.1); }
  .btn.primary { border-color: var(--accent); color: var(--accent); background: rgba(0,255,204,0.08); }
  .btn.active-toggle { border-color: var(--good); color: var(--good); background: rgba(0,255,136,0.08); }
  .btn.danger { border-color: var(--accent2); color: var(--accent2); background: rgba(255,68,102,0.06); }
  .btn + .btn { margin-top: 6px; }

  .word-list { flex: 1; overflow-y: auto; padding: 4px 8px; min-height: 0; }
  .word-list::-webkit-scrollbar { width: 4px; }
  .word-list::-webkit-scrollbar-track { background: var(--bg); }
  .word-list::-webkit-scrollbar-thumb { background: var(--border); }

  .word-item-wrap {
    display: flex; flex-direction: column;
    border-left: 2px solid transparent;
    border-radius: 2px;
    margin-bottom: 0;
    cursor: pointer;
    transition: border-color 0.1s, background 0.1s;
    border-bottom: 1px solid rgba(0,255,204,0.07);
  }
  .word-item-wrap:last-child { border-bottom: none; }
  .word-item-wrap:hover { background: var(--bg3); border-left-color: var(--muted); }
  .word-item-wrap.active { background: rgba(0,255,204,0.08); border-left-color: var(--accent); }
  .word-item-wrap.done { border-left-color: var(--good); }
  .word-item-wrap.active.done { border-left-color: var(--accent); }

  .word-item {
    padding: 8px 12px; cursor: pointer;
    border-left: none !important; border-radius: 0;
    transition: none; display: flex; align-items: center; gap: 10px;
    font-weight: 600; font-size: 1rem;
    font-family: 'Rajdhani', 'Noto Sans JP', sans-serif;
    background: transparent !important;
  }
  .word-item-wrap.active .word-item { color: var(--accent); }
  .word-item-wrap.done .word-status { color: var(--good); }
  .word-item .word-status { font-size: 0.65rem; margin-left: auto; opacity: 0.7; font-family: 'Share Tech Mono', monospace; }

  .word-mini-wave {
    width: 100%; height: 16px; display: block;
    opacity: 0; transition: opacity 0.3s;
    border-radius: 0 0 2px 2px;
    margin-top: 0;
  }
  .word-item-wrap.done .word-mini-wave { opacity: 1; }

  /* right sidebar — flip accent border to right side */
  .right-sidebar .word-item-wrap { border-left: none; border-right: 2px solid transparent; }
  .right-sidebar .word-item-wrap:hover { border-right-color: var(--muted); }
  .right-sidebar .word-item-wrap.active { border-right-color: var(--accent); }
  .right-sidebar .word-item-wrap.done { border-right-color: var(--good); }
  .right-sidebar .word-item-wrap.active.done { border-right-color: var(--accent); }

  .main-top { padding: 20px 30px; border-bottom: 1px solid var(--border); background: var(--bg2); display: flex; align-items: center; gap: 20px; flex-wrap: wrap; }
  .tone-control { display: flex; flex-direction: column; gap: 6px; }
  .tone-control label { font-family: 'Share Tech Mono', monospace; font-size: 0.65rem; color: var(--muted); letter-spacing: 0.15em; }
  .tone-row { display: flex; align-items: center; gap: 10px; }

  input[type=range] { -webkit-appearance: none; width: 180px; height: 4px; background: var(--bg3); border: 1px solid var(--border); border-radius: 2px; outline: none; }
  input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: var(--accent); border-radius: 50%; cursor: pointer; box-shadow: 0 0 8px var(--accent); }

  /* ---- PITCH LINE ON SLIDER ---- */
  .slider-pitch-wrap { position: relative; display: inline-flex; align-items: center; }
  .slider-pitch-line {
    position: absolute; top: 50%; transform: translateY(-50%);
    width: 2px; height: 22px; background: var(--accent);
    border-radius: 1px; pointer-events: none;
    box-shadow: 0 0 6px var(--accent), 0 0 12px rgba(0,255,204,0.4);
    opacity: 0; transition: opacity 0.15s, left 0.05s;
    left: 0;
  }
  .slider-pitch-line.visible { opacity: 1; }
  .tone-val { font-family: 'Share Tech Mono', monospace; font-size: 0.9rem; color: var(--accent); min-width: 60px; }

  .preview-btn { padding: 6px 12px; border: 1px solid var(--accent3); background: rgba(255,204,0,0.06); color: var(--accent3); font-family: 'Share Tech Mono', monospace; font-size: 0.75rem; cursor: pointer; border-radius: 2px; transition: all 0.15s; white-space: nowrap; }
  .preview-btn:hover { background: rgba(255,204,0,0.15); }
  .preview-btn.playing { border-color: var(--accent2); color: var(--accent2); animation: pulse 0.5s ease infinite alternate; }

  @keyframes pulse { from { opacity: 1; } to { opacity: 0.5; } }

  .main-content { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 30px; gap: 20px; overflow: hidden; min-width: 0; }

  .current-word { font-size: 5rem; font-weight: 700; letter-spacing: 0.05em; color: var(--text); text-align: center; text-shadow: 0 0 30px rgba(221,238,255,0.2); transition: color 0.3s; min-height: 100px; display: flex; align-items: center; font-family: 'Rajdhani', 'Noto Sans JP', sans-serif; flex-wrap: wrap; justify-content: center; max-width: 100%; width: 100%; overflow-wrap: break-word; word-break: break-word; }
  .current-word .seq-parts { display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 0; max-width: 100%; }
  .seq-divider {
    display: inline-block;
    width: 2px;
    height: 0.85em;
    background: var(--accent);
    box-shadow: 0 0 6px var(--accent), 0 0 14px var(--accent), 0 0 28px rgba(0,255,204,0.4);
    border-radius: 1px;
    margin: 0 0.28em;
    vertical-align: middle;
    opacity: 0.7;
    flex-shrink: 0;
  }

  /* ---- CUSTOM COLOR PICKER ---- */
  #cpPanel {
    position: relative;
    background: #0a0a0f;
    border: 1px solid #223344;
    border-top: 2px solid var(--accent);
    width: 280px;
    box-shadow: 0 0 0 1px rgba(0,255,204,0.08), 0 24px 80px rgba(0,0,0,0.95), 0 0 60px rgba(0,255,204,0.06);
    font-family: 'Share Tech Mono', monospace;
    animation: cpSlideIn 0.18s cubic-bezier(0.2,0,0,1);
    overflow: hidden;
  }
  @keyframes cpSlideIn {
    from { opacity: 0; transform: translateY(-8px) scale(0.97); }
    to   { opacity: 1; transform: translateY(0) scale(1); }
  }
  #cpHeader {
    padding: 10px 14px;
    font-size: 0.6rem;
    letter-spacing: 0.25em;
    color: var(--accent);
    border-bottom: 1px solid #1a1a24;
    display: flex;
    align-items: center;
    justify-content: space-between;
    text-shadow: 0 0 12px var(--accent);
  }
  #cpClose {
    background: none; border: none; color: #556677; cursor: pointer;
    font-size: 0.8rem; padding: 0; line-height: 1;
    transition: color 0.15s;
  }
  #cpClose:hover { color: var(--accent2); }

  /* saturation/value canvas */
  #cpSatVal {
    display: block; width: 280px; height: 200px;
    cursor: crosshair;
    border-bottom: 1px solid #1a1a24;
  }
  #cpSatValThumb {
    position: absolute;
    width: 14px; height: 14px;
    border-radius: 50%;
    border: 2px solid #fff;
    box-shadow: 0 0 0 1px rgba(0,0,0,0.6), 0 0 10px rgba(0,0,0,0.8);
    pointer-events: none;
    transform: translate(-50%, -50%);
    top: 220px; left: 280px;
    transition: box-shadow 0.1s;
  }

  /* sliders */
  #cpSliders {
    padding: 14px 14px 10px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    background: #0d0d14;
    border-bottom: 1px solid #1a1a24;
  }
  .cp-slider-row {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .cp-lbl {
    font-size: 0.55rem;
    letter-spacing: 0.15em;
    color: #445566;
    width: 38px;
    flex-shrink: 0;
  }
  .cp-track-wrap {
    position: relative;
    flex: 1;
    height: 14px;
  }
  .cp-track-wrap canvas {
    display: block;
    width: 100%;
    height: 14px;
    border-radius: 3px;
    cursor: pointer;
  }
  .cp-thumb {
    position: absolute;
    top: 50%;
    width: 18px; height: 18px;
    border-radius: 50%;
    background: #fff;
    border: 2px solid rgba(255,255,255,0.9);
    box-shadow: 0 0 0 1px rgba(0,0,0,0.5), 0 2px 8px rgba(0,0,0,0.7);
    transform: translate(-50%, -50%);
    pointer-events: none;
    transition: box-shadow 0.1s;
    left: 0;
  }

  /* bottom: preview + hex + apply */
  #cpBottom {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px 14px;
    background: #0a0a0f;
    border-bottom: 1px solid #1a1a24;
  }
  #cpPreview {
    width: 36px; height: 36px;
    border-radius: 3px;
    flex-shrink: 0;
    border: 1px solid #223344;
    box-shadow: 0 0 12px rgba(0,255,204,0.2);
    transition: background 0.1s, box-shadow 0.1s;
  }
  #cpHexWrap {
    display: flex;
    align-items: center;
    flex: 1;
    border: 1px solid #223344;
    background: #111118;
    padding: 6px 8px;
    border-radius: 2px;
    gap: 2px;
    transition: border-color 0.15s;
  }
  #cpHexWrap:focus-within { border-color: var(--accent); box-shadow: 0 0 8px rgba(0,255,204,0.15); }
  #cpHashLabel { color: #445566; font-size: 0.8rem; }
  #cpHexInput {
    background: none; border: none; outline: none;
    color: var(--accent); font-family: 'Share Tech Mono', monospace;
    font-size: 0.8rem; letter-spacing: 0.1em;
    width: 70px; text-transform: uppercase;
  }
  #cpApply {
    padding: 8px 14px;
    border: 1px solid var(--accent);
    background: rgba(0,255,204,0.08);
    color: var(--accent);
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.15em;
    cursor: pointer;
    border-radius: 2px;
    transition: all 0.15s;
    flex-shrink: 0;
    text-shadow: 0 0 8px var(--accent);
  }
  #cpApply:hover { background: rgba(0,255,204,0.18); box-shadow: 0 0 16px rgba(0,255,204,0.2); }

  /* swatches */
  #cpSwatches {
    padding: 10px 14px 12px;
    background: #0a0a0f;
  }
  .cp-swatch-label {
    font-size: 0.5rem;
    letter-spacing: 0.2em;
    color: #334455;
    margin-bottom: 8px;
  }
  #cpSwatchRow {
    display: flex;
    gap: 7px;
    flex-wrap: wrap;
  }
  .cp-sw {
    width: 22px; height: 22px;
    border-radius: 50%;
    cursor: pointer;
    border: 1px solid rgba(255,255,255,0.08);
    transition: transform 0.15s, box-shadow 0.15s;
    flex-shrink: 0;
  }
  .cp-sw:hover { transform: scale(1.25); box-shadow: 0 0 10px currentColor; }

  #cpRainbowBtn {
    background: none;
    border: 1px solid #334455;
    color: #556677;
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.55rem;
    letter-spacing: 0.1em;
    padding: 4px 8px;
    border-radius: 2px;
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
  }
  #cpRainbowBtn:hover { border-color: #fff; color: #fff; }
  #cpRainbowBtn.active {
    border-color: transparent;
    color: #fff;
    background: linear-gradient(90deg,#ff0055,#ff6600,#ffcc00,#00ff88,#00ccff,#aa00ff,#ff0055);
    background-size: 200% 100%;
    animation: rainbowShift 1.5s linear infinite;
    text-shadow: 0 0 8px rgba(0,0,0,0.8);
  }
  @keyframes rainbowShift {
    from { background-position: 0% 0; }
    to   { background-position: 200% 0; }
  }
  .current-word.recording { color: var(--accent2); text-shadow: 0 0 30px rgba(255,68,102,0.4); }
  .current-word.done-word { color: var(--good); }

  #waveCanvas { width: 100%; max-width: 700px; height: 100px; border: 1px solid var(--border); background: var(--bg3); border-radius: 2px; }

  .pitch-section { display: flex; flex-direction: column; align-items: center; gap: 8px; width: 100%; max-width: 700px; }
  .pitch-label { font-family: 'Share Tech Mono', monospace; font-size: 0.7rem; color: var(--muted); letter-spacing: 0.15em; align-self: flex-start; }
  .pitch-meter { width: 100%; height: 28px; background: var(--bg3); border: 1px solid var(--border); border-radius: 2px; position: relative; overflow: hidden; }
  .pitch-fill { height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), var(--accent3)); transition: width 0.08s; position: absolute; left: 0; }
  .pitch-target-line { position: absolute; top: 0; bottom: 0; width: 2px; background: var(--accent2); box-shadow: 0 0 6px var(--accent2); }
  .pitch-info { display: flex; justify-content: space-between; width: 100%; font-family: 'Share Tech Mono', monospace; font-size: 0.75rem; }
  .pitch-current { color: var(--accent3); }
  .pitch-target-label { color: var(--accent2); }
  .pitch-offset.good { color: var(--good); }
  .pitch-offset.warn { color: var(--warn); }
  .pitch-offset.bad { color: var(--bad); }

  .playback-row { display: flex; align-items: center; gap: 12px; width: 100%; max-width: 700px; }
  #playbackCanvas { flex: 1; height: 60px; border: 1px solid var(--border); background: var(--bg3); border-radius: 2px; cursor: default; user-select: none; }

  .play-btn { padding: 7px 16px; border: 1px solid var(--accent); background: rgba(0,255,204,0.08); color: var(--accent); font-family: 'Share Tech Mono', monospace; font-size: 0.8rem; cursor: pointer; border-radius: 2px; transition: all 0.15s; white-space: nowrap; flex-shrink: 0; }
  .play-btn:hover { background: rgba(0,255,204,0.18); }
  .play-btn.playing { border-color: var(--accent3); color: var(--accent3); animation: pulse 0.6s ease infinite alternate; }

  .record-hint { display: flex; align-items: center; gap: 12px; padding: 12px 20px; border: 1px solid var(--border); background: var(--bg3); border-radius: 2px; font-family: 'Share Tech Mono', monospace; font-size: 0.8rem; color: var(--muted); }
  .record-hint .key { padding: 4px 10px; border: 1px solid var(--accent); color: var(--accent); border-radius: 2px; font-size: 0.9rem; box-shadow: 0 0 8px rgba(0,255,204,0.2); cursor: pointer; transition: all 0.15s; user-select: none; }
  .record-hint .key:hover { background: rgba(0,255,204,0.1); box-shadow: 0 0 16px rgba(0,255,204,0.4); }
  .record-hint .key.binding { border-color: var(--accent3); color: var(--accent3); box-shadow: 0 0 12px rgba(255,204,0,0.5); animation: pulse 0.4s ease infinite alternate; }

  .recording-indicator { display: flex; align-items: center; gap: 8px; color: var(--accent2); font-size: 0.85rem; animation: pulse 0.6s ease infinite alternate; opacity: 0; transition: opacity 0.2s; font-family: 'Share Tech Mono', monospace; }
  .recording-indicator.active { opacity: 1; }
  .rec-dot {
    width: 10px; height: 10px; background: var(--accent2); border-radius: 50%;
    box-shadow: 0 0 8px var(--accent2);
    outline: 2px solid var(--accent2); outline-offset: 3px;
    cursor: pointer; transition: all 0.15s; flex-shrink: 0;
  }
  .rec-dot:hover { outline-color: #fff; }
  .rec-dot.muted { background: transparent; box-shadow: none; outline-color: var(--muted); }
  .recording-indicator.muted { color: var(--muted); animation: none; }

  .progress-bar-wrap { width: 100%; max-width: 700px; display: flex; align-items: center; gap: 12px; }
  .progress-bar { flex: 1; height: 4px; background: var(--bg3); border-radius: 2px; overflow: hidden; }
  .progress-fill { height: 100%; background: var(--accent); border-radius: 2px; transition: width 0.3s; box-shadow: 0 0 8px var(--accent); }
  .progress-text { font-family: 'Share Tech Mono', monospace; font-size: 0.75rem; color: var(--muted); white-space: nowrap; }

  .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; pointer-events: none; transition: opacity 0.2s; }
  .modal-overlay.show { opacity: 1; pointer-events: all; }
  .modal { background: var(--bg2); border: 1px solid var(--border); border-top: 2px solid var(--accent); padding: 28px; min-width: 420px; max-width: 520px; box-shadow: 0 20px 60px rgba(0,0,0,0.8); }
  .modal h2 { font-family: 'Share Tech Mono', monospace; font-size: 1rem; color: var(--accent); letter-spacing: 0.15em; margin-bottom: 20px; }
  .modal p { font-size: 0.9rem; color: var(--muted); margin-bottom: 16px; line-height: 1.5; }
  .modal-row { display: flex; gap: 10px; margin-top: 16px; }
  .modal-input { flex: 1; padding: 8px 12px; background: var(--bg3); border: 1px solid var(--border); color: var(--text); font-family: 'Share Tech Mono', monospace; font-size: 0.85rem; border-radius: 2px; outline: none; }
  .modal-input:focus { border-color: var(--accent); }
  .modal-btn { padding: 8px 18px; border: 1px solid var(--accent); background: rgba(0,255,204,0.08); color: var(--accent); font-family: 'Rajdhani', sans-serif; font-weight: 700; font-size: 0.9rem; cursor: pointer; border-radius: 2px; letter-spacing: 0.05em; transition: all 0.15s; }
  .modal-btn:hover { background: rgba(0,255,204,0.18); }
  .modal-btn.cancel { border-color: var(--muted); color: var(--muted); background: transparent; }
  .modal-btn.cancel:hover { border-color: var(--text); color: var(--text); }

  .status-bar { padding: 8px 30px; background: var(--bg); border-top: 1px solid var(--border); font-family: 'Share Tech Mono', monospace; font-size: 0.7rem; color: var(--muted); display: flex; gap: 20px; grid-column: 1 / 4; }
  .status-item span { color: var(--accent); margin-left: 4px; }

  .no-reclist { text-align: center; color: var(--muted); font-family: 'Share Tech Mono', monospace; font-size: 0.8rem; line-height: 2; }
  .no-reclist .big { font-size: 3rem; opacity: 0.3; }

  select { padding: 7px 12px; background: var(--bg3); border: 1px solid var(--border); color: var(--text); font-family: 'Rajdhani', sans-serif; font-size: 0.9rem; border-radius: 2px; outline: none; cursor: pointer; }
  select:focus { border-color: var(--accent); }

  .keys-hint { font-family: 'Share Tech Mono', monospace; font-size: 0.65rem; color: var(--muted); text-align: center; }
  .keys-hint .key { display: inline-block; padding: 2px 6px; border: 1px solid var(--muted); border-radius: 2px; margin: 0 3px; color: var(--text); }

  /* ---- MIC PANIC ---- */
  @keyframes micPanic {
    0%   { border-color: var(--bad); color: var(--bad); box-shadow: 0 0 0 rgba(255,68,102,0); transform: translateX(0); }
    10%  { transform: translateX(-4px); }
    20%  { transform: translateX(4px); border-color: var(--accent3); color: var(--accent3); box-shadow: 0 0 18px rgba(255,204,0,0.6); }
    30%  { transform: translateX(-4px); }
    40%  { transform: translateX(4px); border-color: var(--bad); color: var(--bad); box-shadow: 0 0 24px rgba(255,68,102,0.8); }
    50%  { transform: translateX(-3px); }
    60%  { transform: translateX(3px); }
    70%  { transform: translateX(-2px); border-color: var(--accent3); color: var(--accent3); }
    80%  { transform: translateX(2px); }
    90%  { transform: translateX(-1px); border-color: var(--bad); color: var(--bad); }
    100% { transform: translateX(0); box-shadow: 0 0 16px rgba(255,68,102,0.5); }
  }
  @keyframes micPanicLabel {
    0%, 100% { color: var(--bad); }
    50% { color: var(--accent3); }
  }
  .header-mic.panic label { animation: micPanicLabel 0.4s ease infinite; }
  .header-mic.panic select {
    border-color: var(--bad) !important;
    color: var(--bad) !important;
    animation: micPanic 0.5s ease infinite;
  }
  .header-mic.panic::after {
    content: '!! NO SIGNAL — TRY SOMETHING ELSE !!';
    display: block;
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.55rem;
    color: var(--bad);
    letter-spacing: 0.1em;
    animation: micPanicLabel 0.3s ease infinite;
    white-space: nowrap;
  }
  /* mobile panic — shake the settings gear */
  @keyframes gearPanic {
    0%,100% { transform: rotate(0deg); color: var(--muted); border-color: var(--border); }
    15% { transform: rotate(-20deg) scale(1.2); color: var(--bad); border-color: var(--bad); box-shadow: 0 0 12px rgba(255,68,102,0.6); }
    30% { transform: rotate(20deg) scale(1.2); color: var(--accent3); border-color: var(--accent3); box-shadow: 0 0 16px rgba(255,204,0,0.6); }
    45% { transform: rotate(-15deg); color: var(--bad); }
    60% { transform: rotate(15deg); }
    75% { transform: rotate(-8deg); }
    90% { transform: rotate(5deg); }
  }
  .mob-settings-btn.panic { animation: gearPanic 0.6s ease infinite; }
  .header-mic { display: flex; flex-direction: column; gap: 4px; margin-left: auto; }
  .header-mic label { font-family: 'Share Tech Mono', monospace; font-size: 0.6rem; color: var(--muted); letter-spacing: 0.15em; }
  .header-mic select { font-size: 0.8rem; padding: 5px 10px; max-width: 220px; }

  /* ---- MOBILE RECORD BUTTON ---- */
  .mobile-rec-btn {
    display: none;
    width: 140px; height: 140px; border-radius: 50%;
    border: 3px solid var(--accent2);
    background: rgba(255,68,102,0.08);
    color: var(--accent2);
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.85rem; letter-spacing: 0.1em;
    flex-direction: column; align-items: center; justify-content: center; gap: 8px;
    cursor: pointer; transition: all 0.15s;
    box-shadow: 0 0 20px rgba(255,68,102,0.2);
    user-select: none; -webkit-user-select: none;
    touch-action: none;
  }
  .mobile-rec-btn .rec-ring { width: 20px; height: 20px; border-radius: 50%; background: var(--accent2); box-shadow: 0 0 10px var(--accent2); }
  .mobile-rec-btn.recording-active { background: rgba(255,68,102,0.25); box-shadow: 0 0 40px rgba(255,68,102,0.5); transform: scale(1.05); }

  /* ---- MOBILE SETTINGS DRAWER ---- */
  .mob-settings-btn {
    display: none; align-items: center; justify-content: center;
    width: 38px; height: 38px; border: 1px solid var(--border);
    background: var(--bg3); color: var(--muted); border-radius: 2px;
    cursor: pointer; font-size: 1.1rem; transition: all 0.15s; flex-shrink: 0;
  }
  .mob-settings-btn:hover { border-color: var(--accent); color: var(--accent); }
  .mob-settings-drawer {
    display: none; position: fixed; inset: 0; z-index: 500;
  }
  .mob-settings-drawer.open { display: block; }
  .mob-settings-scrim { position: absolute; inset: 0; background: rgba(0,0,0,0.7); }
  .mob-settings-panel {
    position: absolute; top: 0; left: 0; bottom: 0; width: 300px;
    background: var(--bg2); border-right: 1px solid var(--border);
    overflow-y: auto; display: flex; flex-direction: column;
  }
  .mob-settings-panel::-webkit-scrollbar { width: 4px; }
  .mob-settings-panel::-webkit-scrollbar-thumb { background: var(--border); }
  .mob-settings-header {
    padding: 14px 16px; border-bottom: 1px solid var(--border);
    display: flex; align-items: center; justify-content: space-between;
    font-family: 'Share Tech Mono', monospace; font-size: 0.7rem;
    color: var(--accent); letter-spacing: 0.2em;
  }
  .mob-settings-close {
    background: none; border: none; color: var(--muted); font-size: 1.2rem;
    cursor: pointer; padding: 0 4px; line-height: 1;
  }

  /* ---- MOBILE WORD PANEL (bottom) ---- */
  .mob-word-panel {
    display: none; position: fixed; bottom: 0; left: 0; right: 0; z-index: 400;
    background: var(--bg2); border-top: 1px solid var(--border);
    flex-direction: column;
  }
  .mob-word-panel.open { display: flex; }
  .mob-word-tab {
    display: none; position: fixed; bottom: 0; left: 0; right: 0; z-index: 399;
    background: var(--bg2); border-top: 1px solid var(--border);
    padding: 8px 16px; font-family: 'Share Tech Mono', monospace;
    font-size: 0.7rem; color: var(--muted); letter-spacing: 0.15em;
    align-items: center; justify-content: space-between; cursor: pointer;
    transition: color 0.15s;
  }
  .mob-word-tab:hover { color: var(--accent); }
  .mob-word-tab-arrow { transition: transform 0.2s; }
  .mob-word-tab.tab-open .mob-word-tab-arrow { transform: rotate(180deg); }
  .mob-word-list-wrap {
    max-height: 45vh; overflow-y: auto; padding: 6px;
  }
  .mob-word-list-wrap::-webkit-scrollbar { width: 4px; }
  .mob-word-list-wrap::-webkit-scrollbar-thumb { background: var(--border); }

  @media (max-width: 700px) {
    /* hide desktop sidebar and status bar entirely */
    .sidebar { display: none !important; }
    .right-sidebar { display: none !important; }
    .status-bar { display: none !important; }
    .main-top { display: none !important; }
    .header-mic { display: none !important; }

    /* layout */
    .app { grid-template-columns: 1fr; grid-template-rows: 1fr; height: calc(100vh - 64px); }
    .main-content { padding: 16px; gap: 14px; padding-bottom: 80px; }

    /* header */
    h1 { font-size: 1.4rem; }
    .skull svg { width: 48px !important; height: 30px !important; }
    header { padding: 12px 16px; gap: 12px; }

    /* show mobile-only elements */
    .mobile-rec-btn { display: flex; }
    .record-hint { display: none; }
    .mob-settings-btn { display: flex; }
    .mob-word-tab { display: flex; }

    .current-word { font-size: 3.5rem; min-height: 70px; overflow-wrap: break-word; }
    input[type=range] { width: 130px; }

    /* modal fix */
    .modal { min-width: unset; width: calc(100vw - 32px); max-width: 100%; }
  }
</style>
</head>
<body>

<header>
  <div class="skull" id="skullBtn" title="click to change theme color" style="position:relative;cursor:pointer" onclick="toggleCP(event)">
    <svg id="skullSvg" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="72" height="44" viewBox="0,0,48.28128,29.87839" style="display:block;transition:filter 0.3s"><defs><linearGradient x1="228.9336" y1="170.07455" x2="228.9336" y2="213.48515" gradientUnits="userSpaceOnUse" id="color-1"><stop offset="0" stop-color="#00ffce"/><stop offset="1" stop-color="#243834"/></linearGradient><linearGradient x1="240.39449" y1="167.26541" x2="240.39449" y2="190.778" gradientUnits="userSpaceOnUse" id="color-2"><stop offset="0" stop-color="#ffffff"/><stop offset="1" stop-color="#78ffe5"/></linearGradient><linearGradient x1="234.14836" y1="182.97909" x2="234.14836" y2="191.92599" gradientUnits="userSpaceOnUse" id="color-3"><stop offset="0" stop-color="#ffffff"/><stop offset="1" stop-color="#78ffe5"/></linearGradient><linearGradient x1="253.86417" y1="170.82081" x2="253.86417" y2="214.23142" gradientUnits="userSpaceOnUse" id="color-4"><stop offset="0" stop-color="#00ffce"/><stop offset="1" stop-color="#a2ffee"/></linearGradient></defs><g transform="translate(-217.25824,-167.22899)"><g stroke-width="0" stroke-miterlimit="10"><path d="M230.52992,180.03337l-3.22221,-4.75209l3.74519,-6.30289l5.20673,3.74519l0.73077,6.02884z" fill="#00ffce" stroke="#b6591b"/><path d="M233.06041,189.33119l-5.94972,7.02993l-9.85245,-8.90184c0,0 6.56615,-2.86769 7.68239,-7.95604c1.2192,-5.55768 1.72765,-9.4287 1.72765,-9.4287l4.75,2.00962v4.93269z" fill="url(#color-1)" stroke="#b6591b"/><path d="M229.15249,170.87981l-2.1271,3.83491l1.83884,3.48421l-0.53132,0.51045l-2.0859,-4.30722l2.49628,-4.50445l1.64663,0.4393l-0.51939,0.6619z" fill="#ff0094" stroke="#b6591b"/><path d="M227.93691,187.74175l0.1308,-4.15406l0.69348,-3.0498l-0.70542,-3.48989l0.00511,-2.32163l8.91165,-7.46096l10.90813,2.77445l4.97142,10.14057l-1.61143,8.80088l-10.29476,1.79669z" fill="url(#color-2)" stroke="#b6591b"/><path d="M228.56129,177.57882l-0.27107,-2.75623l9.8644,-0.39628z" fill="#ffffff" stroke="#b6591b"/><path d="M241.03081,190.79692l5.68997,-9.64401l4.50054,-4.46839l0.28932,12.28005z" fill="#5ce6cb" stroke="#b6591b"/><path d="M238.40935,174.45012l9.61408,-4.42943l4.01364,7.76118l-5.34769,3.2996z" fill="#b5fff1" stroke="#b6591b"/><path d="M228.04843,187.66056l-0.02202,-4.19028l0.73406,-2.97459l-0.52025,-2.78068l10.05797,-3.41655l8.56769,6.85874l-5.96924,9.44863z" fill="#85ffe7" stroke="#b6591b"/><path d="M227.88552,191.11264l4.39211,-7.32019l6.50684,-0.81336l1.62671,8.9469z" fill="url(#color-3)" stroke="#b6591b"/><path d="M235.5085,186.47634l3.35035,-3.21939l1.48938,8.66442z" fill="#b5fff1" stroke="#b6591b"/><path d="M245.80737,179.49869l0.73077,-6.02884l5.20673,-3.74519l3.74519,6.30289l-3.22221,4.7521z" fill="#00ffce" stroke="#b6591b"/><path d="M251.37949,177.76312v-4.93269l4.74999,-2.00961c0,0 0.50845,3.87101 1.72765,9.4287c1.11625,5.08835 7.68239,7.95604 7.68239,7.95604l-9.85245,8.90184l-5.94971,-7.02993z" fill="url(#color-4)" stroke="#b6591b"/><path d="M249.69295,176.71997l2.44037,-6.85766l1.00313,0.04358l1.55317,1.5521l-0.9424,0.35357l-1.00348,-0.78063l-1.96049,5.73262l0.51719,1.13093l0.22101,2.00921z" fill="#ff0094" stroke="#b6591b"/><path d="M248.27454,167.61421v-0.06762h0.13526v0.06762z" fill="#ff0094" stroke="none"/><path d="M228.10125,174.69747l8.94433,-7.46848l10.93021,2.75744l1.01743,1.99289l-1.50729,-1.72879l-10.33022,-2.40529l-8.11226,6.66177l-0.35792,6.1138l-0.8872,-3.40696z" fill="#ffffff" stroke="#b6591b"/><path d="M227.88255,191.08739l3.66473,-5.3685l3.76117,0.77152l5.04703,5.3685z" fill="#85ffe7" stroke="#b6591b"/><path d="M228.46986,190.06861l3.57889,-6.56108l6.78777,-0.55652l1.56148,9.03904l-2.01189,-8.57769l-5.31985,0.51414z" fill="#ffffff" stroke="#b6591b"/><path d="M235.29161,186.48749l-3.48289,-0.69658l3.61558,0.43121l3.18436,3.58241z" fill="#ffffff" stroke="#b6591b"/><path d="M246.56352,181.13152l-8.44195,-6.49918l-9.86115,3.06455l9.93212,-3.44213l8.71099,6.90536l-3.52324,5.62574z" fill="#ffffff" stroke="#b6591b"/><path d="M239.58561,184.65461l-1.48942,-3.97313l1.7555,-3.17315l4.94106,-0.00545l3.57366,3.08443l-1.82459,3.87724z" fill="#317c6d" stroke="#b6591b"/><path d="M228.01231,183.53465l0.70425,-3.02991l-0.63741,-3.47476l2.66951,-0.34297l1.52101,3.19846l-1.59651,3.49712z" fill="#317c6d" stroke="#b6591b"/><path d="M228.02677,183.5179l2.53617,-0.2396l1.73515,-3.38634l-1.43003,3.56796z" fill="#ffffff" stroke="#b6591b"/><path d="M239.55032,184.68918l-1.45709,-3.92001l1.63101,3.66879l6.70566,-0.2319l1.97111,-3.55573l-1.83584,3.90358z" fill="#ffffff" stroke="#b6591b"/></g></g></svg>
  </div>

  <!-- CUSTOM COLOR PICKER -->
  <div id="cpPopup" style="display:none;position:fixed;top:0;left:0;z-index:99999">
    <div id="cpScrim" onclick="closeCP()" style="position:fixed;inset:0"></div>
    <div id="cpPanel">
      <div id="cpHeader">// CHROMATIC OVERRIDE //
        <button id="cpClose" onclick="closeCP()">&#x2715;</button>
      </div>
      <canvas id="cpSatVal" width="240" height="200"></canvas>
      <div id="cpSatValThumb"></div>
      <div id="cpSliders">
        <div class="cp-slider-row">
          <span class="cp-lbl">HUE</span>
          <div class="cp-track-wrap">
            <canvas id="cpHueTrack" width="180" height="14"></canvas>
            <div id="cpHueThumb" class="cp-thumb"></div>
          </div>
        </div>
        <div class="cp-slider-row">
          <span class="cp-lbl">BRIGHT</span>
          <div class="cp-track-wrap">
            <canvas id="cpValTrack" width="180" height="14"></canvas>
            <div id="cpValThumb" class="cp-thumb"></div>
          </div>
        </div>
        <div class="cp-slider-row">
          <span class="cp-lbl">SAT</span>
          <div class="cp-track-wrap">
            <canvas id="cpSatTrack" width="180" height="14"></canvas>
            <div id="cpSatThumb" class="cp-thumb"></div>
          </div>
        </div>
      </div>
      <div id="cpBottom">
        <div id="cpPreview"></div>
        <div id="cpHexWrap">
          <span id="cpHashLabel">#</span>
          <input id="cpHexInput" maxlength="6" spellcheck="false" oninput="cpHexTyped(this.value)" onfocus="this.select()">
        </div>
        <button id="cpApply" onclick="cpConfirm()">APPLY</button>
      </div>
      <div id="cpSwatches">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
          <div class="cp-swatch-label" style="margin-bottom:0">PRESETS</div>
          <button id="cpRainbowBtn" onclick="toggleRainbow()" title="RGB MODE">&#127752; RGB MODE</button>
        </div>
        <div id="cpSwatchRow"></div>
      </div>
    </div>
  </div>
  <div>
    <h1>BONEMO</h1>
    <div class="subtitle">// skeleton voice recording studio // v1.2 //</div>
  </div>
  <!-- desktop mic selector -->
  <div class="header-mic">
    <label>MICROPHONE</label>
    <select id="micSelect" onchange="onMicChange()">
      <option value="">default mic</option>
    </select>
  </div>
  <!-- hover-play toggle -->
  <div class="header-mic" style="margin-left:0">
    <label>HOVER PLAY</label>
    <button id="hoverPlayBtn" onclick="toggleHoverPlay()" style="padding:5px 12px;border:1px solid var(--border);background:var(--bg3);color:var(--muted);font-family:'Share Tech Mono',monospace;font-size:0.75rem;cursor:pointer;border-radius:2px;transition:all 0.15s;white-space:nowrap">OFF</button>
  </div>
  <!-- mobile: settings icon -->
  <button class="mob-settings-btn" onclick="openMobSettings()" title="Settings">&#9881;</button>
</header>

<div class="app">
  <div class="sidebar">
    <div class="sidebar-section">
      <h3>Setup</h3>
      <button class="btn primary" onclick="loadReclist()">&#9654; Load reclist.txt</button>
    </div>
    <div class="sidebar-section">
      <h3>Session</h3>
      <button class="btn" onclick="exportAll()">&#8659; Export WAV + oto.ini</button>
      <button class="btn danger" onclick="clearAll()">&#x2715; Clear recordings</button>
    </div>
    <div class="sidebar-section">
      <h3>Display</h3>
      <button class="btn" id="romajiToggleBtn" onclick="toggleRomaji()">Show Romaji: OFF</button>
      <button class="btn" id="autoAdvanceBtn" onclick="toggleAutoAdvance()" style="margin-top:6px">Auto-advance: ON</button>
    </div>
    <div class="sidebar-section">
      <h3>Recording Offset</h3>
      <div class="tone-control" style="width:100%">
        <div class="tone-row" style="gap:8px">
          <input type="range" id="recOffsetSlider" min="-300" max="300" value="0" step="10" oninput="onOffsetChange()" style="width:100%">
        </div>
        <div style="display:flex;justify-content:space-between;margin-top:4px">
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">-300ms</span>
          <span class="tone-val" id="recOffsetVal" style="font-size:0.8rem;min-width:unset">0 ms</span>
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">+300ms</span>
        </div>
        <div style="font-family:'Share Tech Mono',monospace;font-size:0.6rem;color:var(--muted);margin-top:6px;line-height:1.5">negative: trims clip start<br>positive: delays record start</div>
      </div>
    </div>
    <div class="sidebar-section">
      <h3 style="display:flex;align-items:center;justify-content:space-between">
        Silence Trim
        <span style="display:flex;gap:6px;font-size:0.6rem">
          <span id="trimStartBtn" onclick="toggleTrimStart()" title="trim start" style="padding:2px 6px;border:1px solid var(--accent);color:var(--accent);border-radius:2px;cursor:pointer;opacity:1;transition:opacity 0.15s">S</span>
          <span id="trimEndBtn" onclick="toggleTrimEnd()" title="trim end" style="padding:2px 6px;border:1px solid var(--muted);color:var(--muted);border-radius:2px;cursor:pointer;opacity:0.4;transition:opacity 0.15s">E</span>
        </span>
      </h3>
      <div class="tone-control" style="width:100%">
        <div class="tone-row" style="gap:8px">
          <input type="range" id="silenceSlider" min="0" max="0.05" value="0" step="0.001" oninput="onSilenceChange()" style="width:100%">
        </div>
        <div style="display:flex;justify-content:space-between;margin-top:4px">
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">OFF</span>
          <span class="tone-val" id="silenceVal" style="font-size:0.8rem;min-width:unset">off</span>
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">0.050</span>
        </div>
        <div style="font-family:'Share Tech Mono',monospace;font-size:0.6rem;color:var(--muted);margin-top:6px;line-height:1.5">trims silence from start + end<br>raise until noise gets cut cleanly</div>
      </div>
    </div>
  </div>

  <div class="right-sidebar">
    <div class="right-sidebar-header">WORD LIST</div>
    <div class="word-list" id="wordList">
      <div class="no-reclist"><div class="big">&#9900;</div>load a reclist<br>to begin...</div>
    </div>
  </div>

  <div class="main-top">
    <div class="tone-control" style="flex:1">
      <label>TARGET TONE</label>
      <div class="tone-row">
        <div class="slider-pitch-wrap">
          <input type="range" id="toneSlider" min="80" max="800" value="220" oninput="onToneChange()">
          <div class="slider-pitch-line" id="sliderPitchLine"></div>
        </div>
        <span class="tone-val" id="toneVal">220 Hz</span>
        <select id="noteSelect" onchange="onNoteSelect()">
          <option value="82.41">E2 - 82 Hz</option><option value="87.31">F2 - 87 Hz</option>
          <option value="98.00">G2 - 98 Hz</option><option value="110.00">A2 - 110 Hz</option>
          <option value="130.81">C3 - 131 Hz</option><option value="146.83">D3 - 147 Hz</option>
          <option value="164.81">E3 - 165 Hz</option><option value="174.61">F3 - 175 Hz</option>
          <option value="196.00">G3 - 196 Hz</option><option value="220.00" selected>A3 - 220 Hz</option>
          <option value="261.63">C4 - 262 Hz</option><option value="293.66">D4 - 294 Hz</option>
          <option value="329.63">E4 - 330 Hz</option><option value="349.23">F4 - 349 Hz</option>
          <option value="392.00">G4 - 392 Hz</option><option value="440.00">A4 - 440 Hz</option>
          <option value="523.25">C5 - 523 Hz</option>
        </select>
        <button class="preview-btn" id="previewBtn"
          onmousedown="startPreviewTone()" onmouseup="stopPreviewTone()" onmouseleave="stopPreviewTone()"
          ontouchstart="startPreviewTone()" ontouchend="stopPreviewTone()">&#9834; PREVIEW</button>
      </div>
    </div>
  </div>

  <div class="main-content" id="mainContent">
    <div class="no-reclist" style="text-align:center">
      <div class="big">&#9900;</div>
      load a reclist.txt to start recording...<br>
      <span style="font-size:0.75rem">then hold the record key for each word</span>
    </div>
  </div>

  <div class="status-bar">
    <div class="status-item">WORDS: <span id="statusTotal">0</span></div>
    <div class="status-item">DONE: <span id="statusDone">0</span></div>
    <div class="status-item">TARGET: <span id="statusTone">220 Hz</span></div>
  </div>
</div>

<!-- MOBILE SETTINGS DRAWER -->
<div class="mob-settings-drawer" id="mobSettingsDrawer">
  <div class="mob-settings-scrim" onclick="closeMobSettings()"></div>
  <div class="mob-settings-panel">
    <div class="mob-settings-header">
      // SETTINGS //
      <button class="mob-settings-close" onclick="closeMobSettings()">&#x2715;</button>
    </div>
    <div class="sidebar-section">
      <h3>Setup</h3>
      <button class="btn primary" onclick="loadReclist();closeMobSettings()">&#9654; Load reclist.txt</button>
    </div>
    <div class="sidebar-section">
      <h3>Microphone</h3>
      <select id="micSelectMob" onchange="onMicChangeMob()" style="width:100%">
        <option value="">default mic</option>
      </select>
    </div>
    <div class="sidebar-section">
      <h3>Session</h3>
      <button class="btn" onclick="exportAll();closeMobSettings()">&#8659; Export WAV + oto.ini</button>
      <button class="btn danger" onclick="clearAll()">&#x2715; Clear recordings</button>
    </div>
    <div class="sidebar-section">
      <h3>Display</h3>
      <button class="btn" id="romajiToggleBtnMob" onclick="toggleRomaji()">Show Romaji: OFF</button>
      <button class="btn" id="autoAdvanceBtnMob" onclick="toggleAutoAdvance()" style="margin-top:6px">Auto-advance: ON</button>
      <button class="btn" id="hoverPlayBtnMob" onclick="toggleHoverPlay()" style="margin-top:6px">Hover Play: OFF</button>
    </div>
    <div class="sidebar-section">
      <h3>Target Tone</h3>
      <div class="tone-control" style="width:100%">
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
          <select id="noteSelectMob" onchange="onNoteSelectMob()" style="flex:1">
            <option value="82.41">E2 - 82 Hz</option><option value="87.31">F2 - 87 Hz</option>
            <option value="98.00">G2 - 98 Hz</option><option value="110.00">A2 - 110 Hz</option>
            <option value="130.81">C3 - 131 Hz</option><option value="146.83">D3 - 147 Hz</option>
            <option value="164.81">E3 - 165 Hz</option><option value="174.61">F3 - 175 Hz</option>
            <option value="196.00">G3 - 196 Hz</option><option value="220.00" selected>A3 - 220 Hz</option>
            <option value="261.63">C4 - 262 Hz</option><option value="293.66">D4 - 294 Hz</option>
            <option value="329.63">E4 - 330 Hz</option><option value="349.23">F4 - 349 Hz</option>
            <option value="392.00">G4 - 392 Hz</option><option value="440.00">A4 - 440 Hz</option>
            <option value="523.25">C5 - 523 Hz</option>
          </select>
          <button class="preview-btn"
            onmousedown="startPreviewTone()" onmouseup="stopPreviewTone()" onmouseleave="stopPreviewTone()"
            ontouchstart="startPreviewTone()" ontouchend="stopPreviewTone()">&#9834;</button>
        </div>
        <input type="range" id="toneSliderMob" min="80" max="800" value="220" oninput="onToneChangeMob()" style="width:100%">
        <div style="text-align:center;font-family:'Share Tech Mono',monospace;font-size:0.8rem;color:var(--accent);margin-top:4px" id="toneValMob">220 Hz</div>
      </div>
    </div>
    <div class="sidebar-section">
      <h3>Recording Offset</h3>
      <div class="tone-control" style="width:100%">
        <input type="range" id="recOffsetSliderMob" min="-300" max="300" value="0" step="10" oninput="onOffsetChangeMob()" style="width:100%">
        <div style="display:flex;justify-content:space-between;margin-top:4px">
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">-300ms</span>
          <span class="tone-val" id="recOffsetValMob" style="font-size:0.8rem;min-width:unset">0 ms</span>
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">+300ms</span>
        </div>
      </div>
    </div>
    <div class="sidebar-section">
      <h3 style="display:flex;align-items:center;justify-content:space-between">
        Silence Trim
        <span style="display:flex;gap:6px;font-size:0.6rem">
          <span id="trimStartBtnMob" onclick="toggleTrimStart()" title="trim start" style="padding:2px 6px;border:1px solid var(--accent);color:var(--accent);border-radius:2px;cursor:pointer;opacity:1;transition:opacity 0.15s">S</span>
          <span id="trimEndBtnMob" onclick="toggleTrimEnd()" title="trim end" style="padding:2px 6px;border:1px solid var(--muted);color:var(--muted);border-radius:2px;cursor:pointer;opacity:0.4;transition:opacity 0.15s">E</span>
        </span>
      </h3>
      <div class="tone-control" style="width:100%">
        <input type="range" id="silenceSliderMob" min="0" max="0.05" value="0" step="0.001" oninput="onSilenceChangeMob()" style="width:100%">
        <div style="text-align:center;font-family:'Share Tech Mono',monospace;font-size:0.8rem;color:var(--accent);margin-top:4px" id="silenceValMob">off</div>
      </div>
    </div>
  </div>
</div>

<!-- MOBILE WORD LIST TAB (bottom) -->
<div class="mob-word-tab" id="mobWordTab" onclick="toggleMobWordList()">
  <span>WORD LIST &nbsp;<span id="mobWordProgress">0 / 0</span></span>
  <span class="mob-word-tab-arrow">&#9650;</span>
</div>
<div class="mob-word-panel" id="mobWordPanel">
  <div class="mob-word-tab" style="position:relative;border-bottom:1px solid var(--border);border-top:none" onclick="toggleMobWordList()">
    <span>WORD LIST &nbsp;<span id="mobWordProgress2">0 / 0</span></span>
    <span class="mob-word-tab-arrow tab-open">&#9650;</span>
  </div>
  <div class="mob-word-list-wrap" id="mobWordList"></div>
</div>
<div class="modal-overlay" id="reclistModal">
  <div class="modal">
    <h2>// LOAD RECLIST //</h2>
    <p>load a reclist.txt — one entry per line, or space-separated. japanese (UTF-8) works fine.</p>
    <input type="file" id="reclistFile" accept=".txt,.reclist" style="display:none" onchange="readReclistFile(event)">
    <button class="modal-btn" onclick="document.getElementById('reclistFile').click()">browse file</button>
    <textarea id="reclistText" class="modal-input" style="width:100%;height:140px;margin-top:12px;resize:vertical;font-size:0.9rem" placeholder="あ い う え お&#10;か き く け こ&#10;or&#10;a&#10;i&#10;u&#10;..."></textarea>
    <div class="modal-row">
      <button class="modal-btn cancel" onclick="closeModal('reclistModal')">cancel</button>
      <button class="modal-btn" onclick="confirmReclist()">load</button>
    </div>
  </div>
</div>

<!-- EXPORT MODAL -->
<div class="modal-overlay" id="exportModal">
  <div class="modal">
    <h2>// EXPORT //</h2>
    <p id="exportMsg">name your voicebank and hit export.</p>
    <div style="margin-bottom:12px">
      <label style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted);letter-spacing:0.15em;display:block;margin-bottom:6px">VOICEBANK NAME</label>
      <input type="text" id="vbNameInput" class="modal-input" placeholder="MyVoicebank" style="width:100%">
      <div style="font-family:'Share Tech Mono',monospace;font-size:0.6rem;color:var(--muted);margin-top:6px">used for character.txt, character.yaml, and zip folder name</div>
    </div>
    <div id="exportProgressMsg" style="font-family:'Share Tech Mono',monospace;font-size:0.75rem;color:var(--accent3);margin-bottom:10px;display:none">generating .frq files...</div>
    <div class="modal-row">
      <button class="modal-btn" id="exportConfirmBtn" onclick="runExport()">&#8659; export</button>
      <button class="modal-btn" id="downloadZipBtn" style="display:none">download .zip</button>
      <button class="modal-btn cancel" onclick="closeModal('exportModal')">close</button>
    </div>
  </div>
</div>

<script>
// ---- STATE ----
let words = [], currentIdx = 0;
let recordingBlobs = {}, decodedBuffers = {};
let targetFreq = 220;
let audioCtx = null, mediaStream = null, mediaRecorder = null;
let isRecording = false, recordedChunks = [];
let alwaysOnSource = null, analyserNode = null;
let waveAnimId = null, pitchAnimId = null;
let previewOscillator = null, saveFolderHandle = null;
let recordKeyDown = false, currentPlaybackSource = null, isPlaying = false;
let pendingRecordTimeout = null;

let showRomaji = false;
let autoAdvance = true;
let recOffset = 0;

// ---- TRIM STATE ----
// originalBuffers stores the full uncut buffer before any trim edits
// trimRegions[word] = { startSamples, endSamples } — samples removed from each side
let originalBuffers = {};
let trimRegions = {}; // { startSamples: N, endSamples: N }
let manualTrimWords = new Set(); // words where user dragged a handle — slider won't override these
let silenceThreshold = 0;
let trimStart = true;
let trimEnd = false;
let recordKey = 'r'; // lowercase canonical key
let recordKeyLabel = 'R'; // display label
let bindingMode = false;
let micMuted = false;

function toggleMicMute() {
  micMuted = !micMuted;
  if (mediaStream) {
    mediaStream.getAudioTracks().forEach(t => t.enabled = !micMuted);
  }
  const dot = document.querySelector('.rec-dot');
  const ind = document.getElementById('recIndicator');
  if (dot) { dot.classList.toggle('muted', micMuted); dot.title = micMuted ? 'unmute mic' : 'mute mic'; }
  if (ind) { ind.classList.toggle('muted', micMuted); }
}

// ---- ROMAJI MAP ----
const romajiMap = {
  // vowels
  'あ':'a','い':'i','う':'u','え':'e','お':'o',
  // small vowels standalone
  'ぁ':'a','ぃ':'i','ぅ':'u','ぇ':'e','ぉ':'o',
  // k
  'か':'ka','き':'ki','く':'ku','け':'ke','こ':'ko',
  // s
  'さ':'sa','し':'shi','す':'su','せ':'se','そ':'so',
  // t
  'た':'ta','ち':'chi','つ':'tsu','て':'te','と':'to',
  // n
  'な':'na','に':'ni','ぬ':'nu','ね':'ne','の':'no',
  // h
  'は':'ha','ひ':'hi','ふ':'fu','へ':'he','ほ':'ho',
  // m
  'ま':'ma','み':'mi','む':'mu','め':'me','も':'mo',
  // y
  'や':'ya','ゆ':'yu','よ':'yo',
  // small y standalone
  'ゃ':'ya','ゅ':'yu','ょ':'yo',
  // r
  'ら':'ra','り':'ri','る':'ru','れ':'re','ろ':'ro',
  // w
  'わ':'wa','を':'wo','ん':'n',
  // voiced
  'が':'ga','ぎ':'gi','ぐ':'gu','げ':'ge','ご':'go',
  'ざ':'za','じ':'ji','ず':'zu','ぜ':'ze','ぞ':'zo',
  'だ':'da','ぢ':'ji','づ':'zu','で':'de','ど':'do',
  'ば':'ba','び':'bi','ぶ':'bu','べ':'be','ぼ':'bo',
  // p
  'ぱ':'pa','ぴ':'pi','ぷ':'pu','ぺ':'pe','ぽ':'po',
  // katakana vowels
  'ア':'a','イ':'i','ウ':'u','エ':'e','オ':'o',
  'ァ':'a','ィ':'i','ゥ':'u','ェ':'e','ォ':'o',
  // k
  'カ':'ka','キ':'ki','ク':'ku','ケ':'ke','コ':'ko',
  'ガ':'ga','ギ':'gi','グ':'gu','ゲ':'ge','ゴ':'go',
  // s
  'サ':'sa','シ':'shi','ス':'su','セ':'se','ソ':'so',
  'ザ':'za','ジ':'ji','ズ':'zu','ゼ':'ze','ゾ':'zo',
  // t
  'タ':'ta','チ':'chi','ツ':'tsu','テ':'te','ト':'to',
  'ダ':'da','ヂ':'ji','ヅ':'zu','デ':'de','ド':'do',
  // n
  'ナ':'na','ニ':'ni','ヌ':'nu','ネ':'ne','ノ':'no',
  // h
  'ハ':'ha','ヒ':'hi','フ':'fu','ヘ':'he','ホ':'ho',
  'バ':'ba','ビ':'bi','ブ':'bu','ベ':'be','ボ':'bo',
  'パ':'pa','ピ':'pi','プ':'pu','ペ':'pe','ポ':'po',
  // m
  'マ':'ma','ミ':'mi','ム':'mu','メ':'me','モ':'mo',
  // y
  'ヤ':'ya','ユ':'yu','ヨ':'yo',
  'ャ':'ya','ュ':'yu','ョ':'yo',
  // r
  'ラ':'ra','リ':'ri','ル':'ru','レ':'re','ロ':'ro',
  // w
  'ワ':'wa','ヲ':'wo','ン':'n',
  // v
  'ヴ':'v',
  // misc
  'っ':'っ','ッ':'ッ', // handled separately
};

// digraph combos: base consonant stem + small kana → romaji
const digraphMap = {
  // き/キ
  'きゃ':'kya','きゅ':'kyu','きょ':'kyo','きぇ':'kye','きぃ':'kyi',
  'ぎゃ':'gya','ぎゅ':'gyu','ぎょ':'gyo','ぎぇ':'gye',
  // し/シ
  'しゃ':'sha','しゅ':'shu','しょ':'sho','しぇ':'she','しぃ':'shi',
  'じゃ':'ja','じゅ':'ju','じょ':'jo','じぇ':'je',
  // ち/チ
  'ちゃ':'cha','ちゅ':'chu','ちょ':'cho','ちぇ':'che',
  // に/ニ
  'にゃ':'nya','にゅ':'nyu','にょ':'nyo','にぇ':'nye',
  // ひ/ヒ
  'ひゃ':'hya','ひゅ':'hyu','ひょ':'hyo','ひぇ':'hye',
  'びゃ':'bya','びゅ':'byu','びょ':'byo',
  'ぴゃ':'pya','ぴゅ':'pyu','ぴょ':'pyo','ぴぇ':'pye',
  // み/ミ
  'みゃ':'mya','みゅ':'myu','みょ':'myo','みぇ':'mye',
  // り/リ
  'りゃ':'rya','りゅ':'ryu','りょ':'ryo','りぇ':'rye',
  // て/で + small
  'てぃ':'ti','てゅ':'tyu','てぅ':'tyu',
  'でぃ':'di','でゅ':'dyu','でぅ':'dyu',
  // と/ど + small u
  'とぅ':'tu','どぅ':'du',
  // う + small vowels
  'うぁ':'wa','うぃ':'wi','うぇ':'we','うぉ':'wo',
  'うぅ':'wu',
  // ヴ combos
  'ヴぁ':'va','ヴぃ':'vi','ヴぇ':'ve','ヴぉ':'vo','ヴゅ':'vyu',
  // ふ + small
  'ふぁ':'fa','ふぃ':'fi','ふぇ':'fe','ふぉ':'fo','ふゅ':'fyu',
  // す/ず + small i
  'すぃ':'si','ずぃ':'zi',
  // おぁ
  'おぁ':'oa',
  // katakana digraphs
  'キャ':'kya','キュ':'kyu','キョ':'kyo','キェ':'kye',
  'ギャ':'gya','ギュ':'gyu','ギョ':'gyo',
  'シャ':'sha','シュ':'shu','ショ':'sho','シェ':'she',
  'ジャ':'ja','ジュ':'ju','ジョ':'jo','ジェ':'je',
  'チャ':'cha','チュ':'chu','チョ':'cho','チェ':'che',
  'ニャ':'nya','ニュ':'nyu','ニョ':'nyo',
  'ヒャ':'hya','ヒュ':'hyu','ヒョ':'hyo',
  'ビャ':'bya','ビュ':'byu','ビョ':'byo',
  'ピャ':'pya','ピュ':'pyu','ピョ':'pyo',
  'ミャ':'mya','ミュ':'myu','ミョ':'myo',
  'リャ':'rya','リュ':'ryu','リョ':'ryo',
  'ティ':'ti','テュ':'tyu','ディ':'di','デュ':'dyu',
  'トゥ':'tu','ドゥ':'du',
  'ファ':'fa','フィ':'fi','フェ':'fe','フォ':'fo','フュ':'fyu',
  'ヴァ':'va','ヴィ':'vi','ヴェ':'ve','ヴォ':'vo',
  'ウィ':'wi','ウェ':'we','ウォ':'wo',
};

const smallKana = new Set(['ゃ','ゅ','ょ','ぁ','ぃ','ぅ','ぇ','ぉ','ャ','ュ','ョ','ァ','ィ','ゥ','ェ','ォ']);

function toRomaji(text) {
  const chars = [...text]; // unicode-safe split
  let result = '';
  let i = 0;
  while (i < chars.length) {
    const c = chars[i];
    const next = chars[i + 1];
    // っ/ッ — double the next consonant
    if (c === 'っ' || c === 'ッ') {
      const nextRom = next ? toRomaji(next) : '';
      result += nextRom[0] || '';
      i++; continue;
    }
    // try digraph first
    if (next && smallKana.has(next)) {
      const digraph = digraphMap[c + next];
      if (digraph) { result += digraph; i += 2; continue; }
    }
    // single char
    result += romajiMap[c] || c;
    i++;
  }
  return result;
}

// replaces underscores with spaces for display/export. ga_wi_sa → ga wi sa
function displayName(w) { return w.replace(/_/g, ' '); }
// true if this entry is a multi-part sequence
function isSequence(w) { return w.includes('_'); }

// ---- AUDIO CTX ----
function getAudioCtx() { if (!audioCtx) audioCtx = new AudioContext(); return audioCtx; }

// ---- MIC PANIC ----
let micPanicTimeout = null;
let silenceCheckInterval = null;

function triggerMicPanic() {
  document.getElementById('micSelect')?.closest('.header-mic')?.classList.add('panic');
  document.querySelector('.mob-settings-btn')?.classList.add('panic');
}
function clearMicPanic() {
  document.getElementById('micSelect')?.closest('.header-mic')?.classList.remove('panic');
  document.querySelector('.mob-settings-btn')?.classList.remove('panic');
  if (micPanicTimeout) { clearTimeout(micPanicTimeout); micPanicTimeout = null; }
}

function startSilenceWatch() {
  if (silenceCheckInterval) return;
  let silentStreak = 0;
  silenceCheckInterval = setInterval(() => {
    if (!analyserNode) return;
    const buf = new Float32Array(analyserNode.fftSize);
    analyserNode.getFloatTimeDomainData(buf);
    let rms = 0;
    for (let i = 0; i < buf.length; i++) rms += buf[i] * buf[i];
    rms = Math.sqrt(rms / buf.length);
    if (rms < 0.0005) {
      silentStreak++;
      // 10 seconds of complete dead silence = something's actually wrong
      if (silentStreak >= 20) { triggerMicPanic(); }
    } else {
      silentStreak = 0;
      clearMicPanic();
    }
  }, 500);
}
function stopSilenceWatch() {
  if (silenceCheckInterval) { clearInterval(silenceCheckInterval); silenceCheckInterval = null; }
}

// ---- ALWAYS-ON MIC ----
// Call once after mic permission is granted. Keeps analyser alive permanently.
async function initAlwaysOnMic() {
  if (alwaysOnSource) return; // already init'd
  try {
    const ctx = getAudioCtx();
    const constraints = { audio: selectedDeviceId ? { deviceId: { exact: selectedDeviceId } } : true, video: false };
    if (!mediaStream) mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
    alwaysOnSource = ctx.createMediaStreamSource(mediaStream);
    analyserNode = ctx.createAnalyser(); analyserNode.fftSize = 2048;
    alwaysOnSource.connect(analyserNode);
    clearMicPanic();
    // populate mic list once we have permission
    populateMicList();
    // start live waveform + pitch if main UI is up
    if (words.length) { startWaveAndPitch(); startSilenceWatch(); }
  } catch(e) {
    console.warn('mic init failed:', e.message);
    triggerMicPanic();
  }
}

// ---- TOGGLES ----
function toggleRomaji() {
  showRomaji = !showRomaji;
  const btn = document.getElementById('romajiToggleBtn');
  if (btn) {
    btn.textContent = `Show Romaji: ${showRomaji ? 'ON' : 'OFF'}`;
    btn.className = showRomaji ? 'btn active-toggle' : 'btn';
  }
  renderWordList(); renderMain();
}

function toggleAutoAdvance() {
  autoAdvance = !autoAdvance;
  const btn = document.getElementById('autoAdvanceBtn');
  if (btn) {
    btn.textContent = `Auto-advance: ${autoAdvance ? 'ON' : 'OFF'}`;
    btn.className = autoAdvance ? 'btn active-toggle' : 'btn';
  }
}

// ---- HOVER PLAY ----
let hoverPlay = false;
let hoverPlayTimeout = null;
let hoverPlaySource = null;

function toggleHoverPlay() {
  hoverPlay = !hoverPlay;
  const btn = document.getElementById('hoverPlayBtn');
  const btnMob = document.getElementById('hoverPlayBtnMob');
  const label = `Hover Play: ${hoverPlay ? 'ON' : 'OFF'}`;
  if (btn) { btn.textContent = label; btn.style.borderColor = hoverPlay ? 'var(--accent)' : 'var(--border)'; btn.style.color = hoverPlay ? 'var(--accent)' : 'var(--muted)'; btn.style.background = hoverPlay ? 'rgba(0,255,204,0.08)' : 'var(--bg3)'; }
  if (btnMob) { btnMob.textContent = label; btnMob.className = hoverPlay ? 'btn active-toggle' : 'btn'; }
}

function onWordHover(i) {
  if (!hoverPlay) return;
  const w = words[i];
  if (!decodedBuffers[w]) return;
  // short delay so fast scrolling doesn't spam playback
  hoverPlayTimeout = setTimeout(() => {
    stopHoverPlay();
    const ctx = getAudioCtx();
    hoverPlaySource = ctx.createBufferSource();
    hoverPlaySource.buffer = decodedBuffers[w];
    hoverPlaySource.connect(ctx.destination);
    hoverPlaySource.start();
    hoverPlaySource.onended = () => { hoverPlaySource = null; };
  }, 120);
}

function onWordHoverEnd(i) {
  clearTimeout(hoverPlayTimeout);
  hoverPlayTimeout = null;
  stopHoverPlay();
}

function stopHoverPlay() {
  if (hoverPlaySource) {
    try { hoverPlaySource.stop(); } catch(e) {}
    hoverPlaySource = null;
  }
}

// ---- OFFSET ----
function onOffsetChange() {
  recOffset = parseInt(document.getElementById('recOffsetSlider').value);
  const el = document.getElementById('recOffsetVal');
  if (el) el.textContent = (recOffset > 0 ? '+' : '') + recOffset + ' ms';
}

function toggleTrimStart() {
  trimStart = !trimStart;
  const btn = document.getElementById('trimStartBtn');
  const btnM = document.getElementById('trimStartBtnMob');
  [btn, btnM].forEach(b => { if (!b) return; b.style.borderColor = trimStart ? 'var(--accent)' : 'var(--muted)'; b.style.color = trimStart ? 'var(--accent)' : 'var(--muted)'; b.style.opacity = trimStart ? '1' : '0.4'; });
  _applySilenceTrimToCurrentWord();
}
function toggleTrimEnd() {
  trimEnd = !trimEnd;
  const btn = document.getElementById('trimEndBtn');
  const btnM = document.getElementById('trimEndBtnMob');
  [btn, btnM].forEach(b => { if (!b) return; b.style.borderColor = trimEnd ? 'var(--accent)' : 'var(--muted)'; b.style.color = trimEnd ? 'var(--accent)' : 'var(--muted)'; b.style.opacity = trimEnd ? '1' : '0.4'; });
  _applySilenceTrimToCurrentWord();
}

function onSilenceChange() {
  silenceThreshold = parseFloat(document.getElementById('silenceSlider').value);
  const el = document.getElementById('silenceVal');
  if (el) el.textContent = silenceThreshold === 0 ? 'off' : silenceThreshold.toFixed(3);
  _applyGlobalSilenceTrim();
}

// Apply silence trim globally to all recorded words that aren't manually locked.
// Also refreshes the canvas if the current word is affected.
function _applyGlobalSilenceTrim() {
  let currentWordAffected = false;
  const w = words[currentIdx];
  for (const word of Object.keys(originalBuffers)) {
    if (manualTrimWords.has(word)) continue; // user set this manually — leave it alone
    trimRegions[word] = detectSilenceTrimRegion(originalBuffers[word], silenceThreshold);
    _applyTrim(word);
    if (word === w) currentWordAffected = true;
  }
  if (currentWordAffected) {
    _waveformCache = null;
    const canvas = (_livePlaybackCanvas && _livePlaybackCanvas.isConnected)
      ? _livePlaybackCanvas
      : document.getElementById('playbackCanvas');
    if (canvas) _repaint(canvas);
  }
}

// Single-word re-trim used by S/E toggle buttons (respects manual lock).
function _applySilenceTrimToCurrentWord() {
  const w = words[currentIdx]; if (!w) return;
  const src = originalBuffers[w]; if (!src) return;
  // S/E toggle always recomputes — clear manual lock for this word
  manualTrimWords.delete(w);
  trimRegions[w] = detectSilenceTrimRegion(src, silenceThreshold);
  _applyTrim(w);
  _waveformCache = null;
  const canvas = (_livePlaybackCanvas && _livePlaybackCanvas.isConnected)
    ? _livePlaybackCanvas
    : document.getElementById('playbackCanvas');
  if (!canvas) return;
  _repaint(canvas);
}

// Trim samples below threshold from both ends of an AudioBuffer.
// Uses a small look-ahead window so a single loud spike doesn't prematurely stop trimming.
// Returns { startSamples, endSamples } — samples to remove from each side.
// Does NOT slice the buffer. Zero means no trim on that side.
function detectSilenceTrimRegion(buffer, threshold) {
  const sr = buffer.sampleRate, len = buffer.length, nc = buffer.numberOfChannels;
  const WINDOW = Math.floor(sr * 0.005);

  const mono = new Float32Array(len);
  for (let ch = 0; ch < nc; ch++) {
    const data = buffer.getChannelData(ch);
    for (let i = 0; i < len; i++) mono[i] += Math.abs(data[i]);
  }
  for (let i = 0; i < len; i++) mono[i] /= nc;

  let start = 0;
  if (trimStart && threshold > 0) {
    for (let i = 0; i < len - WINDOW; i++) {
      let loud = false;
      for (let j = i; j < i + WINDOW; j++) { if (mono[j] > threshold) { loud = true; break; } }
      if (loud) { start = i; break; }
    }
  }

  let end = len;
  if (trimEnd && threshold > 0) {
    for (let i = len - 1; i >= WINDOW; i--) {
      let loud = false;
      for (let j = i; j > i - WINDOW; j--) { if (mono[j] > threshold) { loud = true; break; } }
      if (loud) { end = i + 1; break; }
    }
  }

  return { startSamples: start, endSamples: len - end };
}

// ---- DOWNLOAD CURRENT ----
function downloadCurrent() {
  const w = words[currentIdx];
  const blob = recordingBlobs[w]; if (!blob) return;
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = displayName(w) + '.wav'; a.click();
  setTimeout(() => URL.revokeObjectURL(url), 2000);
}

// ---- KEYBIND ----
function startBindingMode() {
  if (bindingMode) return;
  bindingMode = true;
  const keyEl = document.getElementById('recKeyDisplay');
  if (keyEl) { keyEl.textContent = '...'; keyEl.classList.add('binding'); }
}

function finishBinding(e) {
  if (!bindingMode) return;
  // ignore modifiers alone
  if (['Control','Shift','Alt','Meta','CapsLock','Tab','Escape'].includes(e.key)) return;
  bindingMode = false;
  recordKey = e.key.toLowerCase();
  recordKeyLabel = e.key.length === 1 ? e.key.toUpperCase() : e.key;
  const keyEl = document.getElementById('recKeyDisplay');
  if (keyEl) { keyEl.textContent = recordKeyLabel; keyEl.classList.remove('binding'); }
  e.preventDefault(); e.stopPropagation();
}

// ---- WORD LIST ----
function renderWordList() {
  const el = document.getElementById('wordList'); if (!el) return;
  if (!words.length) { el.innerHTML = '<div class="no-reclist"><div class="big">&#9900;</div>load a reclist.txt<br>to begin...</div>'; return; }
  el.innerHTML = words.map((w, i) => {
    const active = i === currentIdx, done = !!recordingBlobs[w];
    const dn = displayName(w);
    const seq = isSequence(w) ? `<span style="font-size:0.55rem;opacity:0.5;font-family:'Share Tech Mono',monospace;margin-left:4px;border:1px solid var(--muted);padding:1px 4px;border-radius:2px">SEQ</span>` : '';
    const displayWord = showRomaji ? `${dn} <span style="font-size:0.75em;opacity:0.6">(${toRomaji(dn)})</span>${seq}` : `${dn}${seq}`;
    const wave = done ? `<canvas class="word-mini-wave" data-word="${encodeURIComponent(w)}" height="16"></canvas>` : '';
    const wrapClass = `word-item-wrap${active?' active':''}${done?' done':''}`;
    return `<div class="${wrapClass}" onclick="selectWord(${i})" onmouseenter="onWordHover(${i})" onmouseleave="onWordHoverEnd(${i})" data-idx="${i}"><div class="word-item"><span>${displayWord}</span><span class="word-status">${done?'REC':''}</span></div>${wave}</div>`;
  }).join('');
  setTimeout(() => { const a = el.querySelector('.active'); if (a) a.scrollIntoView({ block: 'nearest' }); }, 0);
  requestAnimationFrame(() => el.querySelectorAll('.word-mini-wave').forEach(cv => paintMiniWave(cv)));
  if (mobWordOpen) renderMobWordList();
}

function paintMiniWave(cv) {
  const w = decodeURIComponent(cv.dataset.word);
  const buf = decodedBuffers[w];
  const W = Math.round(cv.getBoundingClientRect().width) || cv.offsetWidth || 240;
  const H = 14;
  cv.width = W; cv.height = H;
  const ctx2 = cv.getContext('2d');

  // subtle dark background so the bar is always visible
  ctx2.fillStyle = 'rgba(0,20,16,0.6)';
  ctx2.fillRect(0, 0, W, H);

  if (!buf) { cv.style.opacity = '0'; return; }

  const data = buf.getChannelData(0);
  const step = Math.max(1, Math.floor(data.length / W));

  // build per-column RMS
  const rms = new Float32Array(W);
  for (let x = 0; x < W; x++) {
    let sum = 0, count = 0;
    const start = x * step, end = Math.min(start + step, data.length);
    for (let j = start; j < end; j++) { sum += data[j] * data[j]; count++; }
    rms[x] = count ? Math.sqrt(sum / count) : 0;
  }

  // normalise
  let peak = 0;
  for (let x = 0; x < W; x++) if (rms[x] > peak) peak = rms[x];
  if (peak === 0) { cv.style.opacity = '1'; return; }

  const midY = H / 2;
  for (let x = 0; x < W; x++) {
    const norm = rms[x] / peak;            // 0..1
    const barH = Math.max(1, norm * (H - 2));
    const alpha = 0.12 + norm * 0.88;

    // green glow: dim for silence, bright accent for peaks
    const g = Math.round(100 + norm * 155);
    const b = Math.round(80  + norm * 124);
    ctx2.fillStyle = `rgba(0,${g},${b},${alpha.toFixed(2)})`;
    ctx2.fillRect(x, midY - barH / 2, 1, barH);

    // extra glow layer for loud sections
    if (norm > 0.45) {
      const glowAlpha = ((norm - 0.45) * 0.55).toFixed(2);
      ctx2.fillStyle = `rgba(0,255,204,${glowAlpha})`;
      ctx2.fillRect(x, midY - barH / 2, 1, barH);
    }
  }

  cv.style.opacity = '1';
}

// ---- MAIN UI ----
function renderMain() {
  _livePlaybackCanvas = null; // reset live ref; drawPlaybackWaveform will set it fresh
  if (!words.length) {
    document.getElementById('mainContent').innerHTML = `<div class="no-reclist" style="text-align:center"><div class="big">&#9900;</div>load a reclist.txt to start...<br><span style="font-size:0.75rem">hold the record key for each word</span></div>`;
    return;
  }
  const w = words[currentIdx], done = !!recordingBlobs[w];
  const pct = (Object.keys(recordingBlobs).length / words.length * 100).toFixed(0);
  const dn = displayName(w);
  const seqParts = isSequence(w) ? w.split('_') : null;
  const syllableCount = seqParts ? seqParts.length : 1;
  // Scale font size down for longer sequences to prevent overflow
  let fontSize;
  if (syllableCount <= 2) fontSize = '5rem';
  else if (syllableCount <= 3) fontSize = '4rem';
  else if (syllableCount <= 4) fontSize = '3.2rem';
  else if (syllableCount <= 6) fontSize = '2.5rem';
  else if (syllableCount <= 8) fontSize = '2rem';
  else fontSize = '1.5rem';

  const centerLabel = seqParts
    ? `<span class="seq-parts">${seqParts.map((p, i) => i < seqParts.length - 1 ? `<span style="white-space:nowrap">${p}</span><span class="seq-divider"></span>` : `<span style="white-space:nowrap">${p}</span>`).join('')}</span>`
    : w;
  const displayWord = showRomaji
    ? `${centerLabel}<div style="font-size:1.4rem;opacity:0.5;font-family:'Share Tech Mono',monospace;letter-spacing:0.1em;margin-top:4px">(${toRomaji(dn)})</div>`
    : centerLabel;

  document.getElementById('mainContent').innerHTML = `
    <div class="current-word ${done?'done-word':''}" id="currentWordEl" style="flex-direction:column;gap:4px;font-size:${fontSize}">${displayWord}</div>
    <canvas id="waveCanvas"></canvas>
    <div class="pitch-section">
      <div class="pitch-label">PITCH METER</div>
      <div class="pitch-meter">
        <div class="pitch-fill" id="pitchFill"></div>
        <div class="pitch-target-line" id="pitchTarget"></div>
      </div>
      <div class="pitch-info">
        <span class="pitch-current" id="pitchCurrent">-- Hz</span>
        <span class="pitch-target-label">target: ${targetFreq.toFixed(0)} Hz</span>
        <span class="pitch-offset" id="pitchOffset">--</span>
      </div>
    </div>
    ${done ? `<div class="playback-row">
      <button class="play-btn" id="playBtn" onclick="togglePlayback()">&#9654; LISTEN</button>
      <button class="play-btn" id="dlBtn" onclick="downloadCurrent()" style="border-color:var(--accent3);color:var(--accent3);background:rgba(255,204,0,0.06)">&#8659; DL</button>
      <canvas id="playbackCanvas"></canvas>
    </div>` : ''}
    <div style="display:flex;align-items:center;gap:20px;flex-wrap:wrap;justify-content:center">
      <div class="record-hint">
        <span class="key" id="recKeyDisplay" onclick="startBindingMode()" title="click to remap">${recordKeyLabel}</span>
        <span>${done ? 'hold to re-record' : 'hold to record'}</span>
      </div>
      <button class="mobile-rec-btn" id="mobileRecBtn">
        <div class="rec-ring"></div>
        HOLD
      </button>
      <div class="recording-indicator${micMuted?' muted':''}" id="recIndicator"><div class="rec-dot${micMuted?' muted':''}" onclick="toggleMicMute()" title="${micMuted?'unmute mic':'mute mic'}"></div>REC</div>
    </div>
    <div class="progress-bar-wrap">
      <div class="progress-bar"><div class="progress-fill" style="width:${pct}%"></div></div>
      <div class="progress-text">${Object.keys(recordingBlobs).length} / ${words.length}</div>
    </div>
    <div class="keys-hint">
      <span class="key">&#8593;</span><span class="key">&#8595;</span> prev/next &nbsp;
      <span class="key">&#8592;</span> first &nbsp;
      <span class="key">&#8594;</span> last &nbsp;
      <span class="key">SPACE</span> listen &nbsp;
      <span class="key" style="border-color:var(--accent);color:var(--accent)">${recordKeyLabel}</span> record
      &nbsp;<span style="opacity:0.5">(click key to remap)</span>
    </div>
  `;

  updatePitchTargetLine();
  if (done && decodedBuffers[w]) setTimeout(() => drawPlaybackWaveform(decodedBuffers[w]), 50);

  // always-on: restart wave/pitch display after re-render
  if (analyserNode) { cancelAnimationFrame(waveAnimId); cancelAnimationFrame(pitchAnimId); startWaveAndPitch(); }

  // mobile button touch events
  const mBtn = document.getElementById('mobileRecBtn');
  if (mBtn) {
    mBtn.addEventListener('touchstart', e => { e.preventDefault(); mBtn.classList.add('recording-active'); if (words.length) startRecording(); }, { passive: false });
    mBtn.addEventListener('touchend',   e => { e.preventDefault(); mBtn.classList.remove('recording-active'); if (isRecording) stopRecording(); }, { passive: false });
    mBtn.addEventListener('touchcancel',e => { e.preventDefault(); mBtn.classList.remove('recording-active'); if (isRecording) stopRecording(); }, { passive: false });
    // also support mouse for desktop testing
    mBtn.addEventListener('mousedown', e => { e.preventDefault(); if (words.length) startRecording(); });
    mBtn.addEventListener('mouseup',   e => { e.preventDefault(); if (isRecording) stopRecording(); });
  }
}

function updatePitchTargetLine() {
  const el = document.getElementById('pitchTarget'); if (!el) return;
  const pct = Math.max(0, Math.min(100, ((targetFreq - 50) / (1000 - 50)) * 100));
  el.style.left = pct + '%';
}

function selectWord(i) {
  stopPlayback();
  currentIdx = i;
  // Auto-apply current silence threshold to this word if it has audio and isn't manually locked
  const w = words[i];
  if (originalBuffers[w] && !manualTrimWords.has(w) && silenceThreshold > 0) {
    trimRegions[w] = detectSilenceTrimRegion(originalBuffers[w], silenceThreshold);
    _applyTrim(w);
  }
  renderWordList();
  renderMain();
}

// ---- TONE ----
function snapNoteSelect(freq) {
  const sel = document.getElementById('noteSelect');
  const selMob = document.getElementById('noteSelectMob');
  if (!sel) return;
  let closest = null, minDiff = Infinity;
  for (const opt of sel.options) {
    const diff = Math.abs(parseFloat(opt.value) - freq);
    if (diff < minDiff) { minDiff = diff; closest = opt.value; }
  }
  if (closest) { sel.value = closest; if (selMob) selMob.value = closest; }
}
function onToneChange() {
  targetFreq = parseFloat(document.getElementById('toneSlider').value);
  document.getElementById('toneVal').textContent = targetFreq.toFixed(0) + ' Hz';
  document.getElementById('statusTone').textContent = targetFreq.toFixed(0) + ' Hz';
  snapNoteSelect(targetFreq);
  const mob = document.getElementById('toneSliderMob'); if (mob) mob.value = targetFreq;
  const mobVal = document.getElementById('toneValMob'); if (mobVal) mobVal.textContent = targetFreq.toFixed(0) + ' Hz';
  updatePitchTargetLine();
}
function onNoteSelect() {
  const val = parseFloat(document.getElementById('noteSelect').value);
  document.getElementById('toneSlider').value = val; targetFreq = val;
  document.getElementById('toneVal').textContent = val.toFixed(0) + ' Hz';
  document.getElementById('statusTone').textContent = val.toFixed(0) + ' Hz';
  const mob = document.getElementById('toneSliderMob'); if (mob) mob.value = val;
  const mobVal = document.getElementById('toneValMob'); if (mobVal) mobVal.textContent = val.toFixed(0) + ' Hz';
  const selMob = document.getElementById('noteSelectMob'); if (selMob) selMob.value = val;
  updatePitchTargetLine();
}
function startPreviewTone() {
  if (previewOscillator) return; // already playing
  const ctx = getAudioCtx(), btn = document.getElementById('previewBtn');
  previewOscillator = ctx.createOscillator();
  const g = ctx.createGain();
  previewOscillator.frequency.value = targetFreq;
  previewOscillator.type = 'sine';
  g.gain.value = 0.2;
  previewOscillator.connect(g); g.connect(ctx.destination);
  previewOscillator.start();
  if (btn) { btn.classList.add('playing'); btn.textContent = '■ HOLD'; }
}
function stopPreviewTone() {
  if (!previewOscillator) return;
  try { previewOscillator.stop(); } catch(e) {}
  previewOscillator = null;
  const btn = document.getElementById('previewBtn');
  if (btn) { btn.classList.remove('playing'); btn.textContent = '♪ PREVIEW'; }
}

// ---- RECLIST ----
function loadReclist() { openModal('reclistModal'); }
function readReclistFile(e) {
  const file = e.target.files[0]; if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    const buffer = ev.target.result;
    let decoder = new TextDecoder('utf-8');
    let text = decoder.decode(buffer);
    if (text.includes('\uFFFD')) { decoder = new TextDecoder('shift-jis'); text = decoder.decode(buffer); }
    document.getElementById('reclistText').value = text;
  };
  reader.readAsArrayBuffer(file);
}
function confirmReclist() {
  const text = document.getElementById('reclistText').value.trim(); if (!text) return;
  words = [];
  for (const line of text.split('\n')) {
    const tokens = line.trim().split(/\s+/).filter(t => t.length > 0);
    words.push(...tokens);
  }
  recordingBlobs = {}; decodedBuffers = {}; currentIdx = 0;
  manualTrimWords.clear();
  closeModal('reclistModal');
  renderWordList(); renderMain(); updateStatus();
  // init always-on mic as soon as we have a reclist
  initAlwaysOnMic().then(() => { if (analyserNode) startSilenceWatch(); });
}

// ---- PLAYBACK ----
function togglePlayback() {
  if (isPlaying) { stopPlayback(); return; }
  const w = words[currentIdx], buf = decodedBuffers[w]; if (!buf) return;
  const ctx = getAudioCtx();
  currentPlaybackSource = ctx.createBufferSource();
  currentPlaybackSource.buffer = buf;
  currentPlaybackSource.connect(ctx.destination);
  currentPlaybackSource.start();
  isPlaying = true;
  const btn = document.getElementById('playBtn');
  if (btn) { btn.textContent = '■ STOP'; btn.classList.add('playing'); }
  currentPlaybackSource.onended = () => {
    isPlaying = false; currentPlaybackSource = null;
    const b = document.getElementById('playBtn');
    if (b) { b.textContent = '▶ LISTEN'; b.classList.remove('playing'); }
  };
}
function stopPlayback() {
  if (currentPlaybackSource) { try { currentPlaybackSource.stop(); } catch(e) {} currentPlaybackSource = null; }
  isPlaying = false;
  const btn = document.getElementById('playBtn');
  if (btn) { btn.textContent = '▶ LISTEN'; btn.classList.remove('playing'); }
}

// ---- TRIM EDITOR STATE ----
// trimDrag: null | { side: 'left'|'right' }
let trimDrag = null;
const HANDLE_HIT = 10; // px hit radius around each handle line

function drawPlaybackWaveform(buffer) {
  const canvas = document.getElementById('playbackCanvas'); if (!canvas) return;
  const W = canvas.offsetWidth || 500, H = 60;
  canvas.width = W; canvas.height = H;
  _livePlaybackCanvas = canvas; // will be updated again by _attachTrimListeners
  _repaint(canvas);
  _attachTrimListeners(canvas);
}

// Cached ImageData of just the waveform (no overlay) — reused during drag
let _waveformCache = null; // { imageData, word, W, H }
let _livePlaybackCanvas = null; // always points to the actual canvas in the DOM (post-clone)

// Full repaint: expensive waveform path + overlay. Call on init and mouse-up only.
function _repaint(canvas) {
  if (!canvas) return;
  const W = canvas.width, H = canvas.height;
  const w = words[currentIdx];
  const fullBuf = originalBuffers[w] || decodedBuffers[w]; if (!fullBuf) return;
  const ctx = canvas.getContext('2d');

  // --- draw background + waveform ---
  const data = fullBuf.getChannelData(0);
  const totalSamples = data.length;
  ctx.fillStyle = '#1a1a24';
  ctx.fillRect(0, 0, W, H);
  const step = Math.ceil(totalSamples / W);
  ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 1;
  ctx.shadowBlur = 4; ctx.shadowColor = '#00ffcc';
  ctx.beginPath();
  for (let i = 0; i < W; i++) {
    let mn = 1, mx = -1;
    for (let j = 0; j < step; j++) { const d = data[i * step + j] || 0; if (d < mn) mn = d; if (d > mx) mx = d; }
    ctx.moveTo(i + 0.5, ((1 + mn) / 2) * H);
    ctx.lineTo(i + 0.5, ((1 + mx) / 2) * H);
  }
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Cache the waveform pixels so drag overlay can restore them cheaply
  _waveformCache = { imageData: ctx.getImageData(0, 0, W, H), word: w, W, H };

  // draw overlay on top
  _repaintOverlay(canvas);
}

// Cheap overlay-only repaint: restores cached waveform pixels then draws red zones + handles.
// Called on every mousemove during drag — no waveform loop, just fillRect + lineTo.
function _repaintOverlay(canvas) {
  if (!canvas) return;
  const W = canvas.width, H = canvas.height;
  const ctx = canvas.getContext('2d');
  const w = words[currentIdx];
  const fullBuf = originalBuffers[w] || decodedBuffers[w]; if (!fullBuf) return;
  const totalSamples = fullBuf.getChannelData(0).length;
  const region = trimRegions[w] || { startSamples: 0, endSamples: 0 };
  const leftPx  = Math.round((region.startSamples / totalSamples) * W);
  const rightPx = W - Math.round((region.endSamples  / totalSamples) * W);

  // Restore cached waveform (avoids redrawing the expensive path)
  if (_waveformCache && _waveformCache.word === w && _waveformCache.W === W && _waveformCache.H === H) {
    ctx.putImageData(_waveformCache.imageData, 0, 0);
  } else {
    // Cache is stale — fall back to full repaint
    _repaint(canvas); return;
  }

  // Red overlay for trimmed zones
  if (leftPx > 0) {
    ctx.fillStyle = 'rgba(255,40,70,0.28)';
    ctx.fillRect(0, 0, leftPx, H);
  }
  if (rightPx < W) {
    ctx.fillStyle = 'rgba(255,40,70,0.28)';
    ctx.fillRect(rightPx, 0, W - rightPx, H);
  }

  // Handle lines — no shadowBlur here, too expensive per frame
  const drawHandle = (x, active) => {
    ctx.strokeStyle = active ? '#ff4060' : 'rgba(255,60,80,0.85)';
    ctx.lineWidth = active ? 3 : 2;
    ctx.beginPath();
    ctx.moveTo(x + 0.5, 0);
    ctx.lineTo(x + 0.5, H);
    ctx.stroke();
  };

  drawHandle(leftPx,  trimDrag && trimDrag.side === 'left');
  drawHandle(rightPx, trimDrag && trimDrag.side === 'right');
}

function _attachTrimListeners(canvas) {
  // clone to strip stale listeners, preserve id
  const fresh = canvas.cloneNode(false);
  fresh.id = canvas.id;
  canvas.parentNode.replaceChild(fresh, canvas);
  _livePlaybackCanvas = fresh; // keep a live reference so slider can repaint the right element

  // repaint onto the fresh clone (clone has same width/height attrs)
  _repaint(fresh);

  const getX = e => {
    const r = fresh.getBoundingClientRect();
    return (e.touches ? e.touches[0].clientX : e.clientX) - r.left;
  };

  const getCursorAndSide = ex => {
    const w = words[currentIdx];
    const fullBuf = originalBuffers[w] || decodedBuffers[w]; if (!fullBuf) return null;
    const totalSamples = fullBuf.getChannelData(0).length;
    const region = trimRegions[w] || { startSamples: 0, endSamples: 0 };
    const W = fresh.width;
    const lp = Math.round((region.startSamples / totalSamples) * W);
    const rp = W - Math.round((region.endSamples  / totalSamples) * W);
    if (Math.abs(ex - lp) <= HANDLE_HIT) return 'left';
    if (Math.abs(ex - rp) <= HANDLE_HIT) return 'right';
    return null;
  };

  // Single document-level mousemove — no double dispatch, rAF-throttled
  let _dragRafPending = false;
  let _dragLastX = 0;

  const onDocMove = e => {
    if (!trimDrag) {
      // cursor hint only when over the canvas
      if (e.target === fresh) {
        fresh.style.cursor = getCursorAndSide(getX(e)) ? 'ew-resize' : 'default';
      }
      return;
    }
    e.preventDefault();
    _dragLastX = getX(e);
    if (_dragRafPending) return; // skip if a frame is already queued
    _dragRafPending = true;
    requestAnimationFrame(() => {
      _dragRafPending = false;
      if (!trimDrag) return;
      const ex = _dragLastX;
      const w = words[currentIdx];
      const fullBuf = originalBuffers[w] || decodedBuffers[w]; if (!fullBuf) return;
      const totalSamples = fullBuf.getChannelData(0).length;
      const region = trimRegions[w] || { startSamples: 0, endSamples: 0 };
      const W = fresh.width;
      const lp = Math.round((region.startSamples / totalSamples) * W);
      const rp = W - Math.round((region.endSamples  / totalSamples) * W);
      if (trimDrag.side === 'left') {
        const cx = Math.max(0, Math.min(ex, rp - 2));
        trimRegions[w] = { ...region, startSamples: Math.round((cx / W) * totalSamples) };
      } else {
        const cx = Math.max(lp + 2, Math.min(ex, W));
        trimRegions[w] = { ...region, endSamples: Math.round(((W - cx) / W) * totalSamples) };
      }
      _repaintOverlay(fresh);
    });
  };
  document.addEventListener('mousemove', onDocMove);

  fresh.addEventListener('mousedown', e => {
    const side = getCursorAndSide(getX(e));
    if (!side) return;
    e.preventDefault();
    trimDrag = { side };
    fresh.style.cursor = 'ew-resize';
  });

  // Touch support for trim handles
  fresh.addEventListener('touchstart', e => {
    const side = getCursorAndSide(getX(e));
    if (!side) return;
    e.preventDefault();
    trimDrag = { side };
  }, { passive: false });

  document.addEventListener('touchmove', e => {
    if (!trimDrag) return;
    e.preventDefault();
    _dragLastX = getX(e);
    if (_dragRafPending) return;
    _dragRafPending = true;
    requestAnimationFrame(() => {
      _dragRafPending = false;
      if (!trimDrag) return;
      const ex = _dragLastX;
      const w = words[currentIdx];
      const fullBuf = originalBuffers[w] || decodedBuffers[w]; if (!fullBuf) return;
      const totalSamples = fullBuf.getChannelData(0).length;
      const region = trimRegions[w] || { startSamples: 0, endSamples: 0 };
      const W = fresh.width;
      const lp = Math.round((region.startSamples / totalSamples) * W);
      const rp = W - Math.round((region.endSamples  / totalSamples) * W);
      if (trimDrag.side === 'left') {
        const cx = Math.max(0, Math.min(ex, rp - 2));
        trimRegions[w] = { ...region, startSamples: Math.round((cx / W) * totalSamples) };
      } else {
        const cx = Math.max(lp + 2, Math.min(ex, W));
        trimRegions[w] = { ...region, endSamples: Math.round(((W - cx) / W) * totalSamples) };
      }
      _repaintOverlay(fresh);
    });
  }, { passive: false });

  const onUp = () => {
    if (!trimDrag) return;
    const w = words[currentIdx];
    manualTrimWords.add(w); // user explicitly set this — lock it from global slider
    _applyTrim(w);
    trimDrag = null;
    fresh.style.cursor = 'default';
    _waveformCache = null;
    _repaint(fresh);
  };

  fresh.addEventListener('mouseup', onUp);
  document.addEventListener('mouseup', onUp);
  document.addEventListener('touchend', onUp);
  document.addEventListener('touchcancel', onUp);
}

function _applyTrim(w) {
  const region = trimRegions[w];
  if (!region) return;

  // always work from the original full buffer so handles can restore audio
  if (!originalBuffers[w]) originalBuffers[w] = decodedBuffers[w];
  const src = originalBuffers[w];
  const totalSamples = src.length;
  const keepStart = Math.max(0, region.startSamples);
  const keepEnd   = Math.max(keepStart + 1, totalSamples - region.endSamples);
  const keepLen   = keepEnd - keepStart;

  const ctx = getAudioCtx();
  const trimmed = ctx.createBuffer(src.numberOfChannels, keepLen, src.sampleRate);
  for (let ch = 0; ch < src.numberOfChannels; ch++) {
    trimmed.copyToChannel(src.getChannelData(ch).slice(keepStart, keepEnd), ch);
  }

  decodedBuffers[w] = trimmed;
  recordingBlobs[w] = audioBufferToWavBlob(trimmed);

  // refresh mini waveform in the sidebar
  requestAnimationFrame(() => {
    const cvs = document.querySelectorAll(`.word-mini-wave[data-word="${encodeURIComponent(w)}"]`);
    cvs.forEach(cv => paintMiniWave(cv));
  });
}


async function startRecording() {
  if (!words.length || isRecording) return;
  stopPlayback();

  // ensure mic is up (first press might need permission)
  if (!mediaStream) await initAlwaysOnMic();
  if (!mediaStream) return; // permission denied

  isRecording = true;

  const doStart = () => {
    pendingRecordTimeout = null;
    if (!isRecording) return;
    // Clear countdown colour
    const wordEl2 = document.getElementById('currentWordEl');
    if (wordEl2) { wordEl2.style.color = ''; wordEl2.style.transition = ''; }
    recordedChunks = [];
    // analyserNode is always alive — just hook recorder to the existing stream
    mediaRecorder = new MediaRecorder(mediaStream);
    mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
    mediaRecorder.onstop = processRecording;
    mediaRecorder.start();
    document.getElementById('currentWordEl')?.classList.add('recording');
    const ind = document.getElementById('recIndicator');
    if (ind) { ind.classList.add('active'); ind.style.opacity = ''; }
  };

  if (recOffset > 0) {
    const ind = document.getElementById('recIndicator');
    if (ind) { ind.classList.add('active'); ind.style.opacity = '0.35'; }
    // Show countdown on the word element
    const wordEl = document.getElementById('currentWordEl');
    if (wordEl) { wordEl.style.transition = 'color 0.1s'; wordEl.style.color = 'var(--accent3)'; }
    pendingRecordTimeout = setTimeout(doStart, recOffset);
  } else {
    doStart();
  }
}

function stopRecording() {
  if (!isRecording) return;
  isRecording = false;

  if (pendingRecordTimeout !== null) {
    clearTimeout(pendingRecordTimeout);
    pendingRecordTimeout = null;
    const ind = document.getElementById('recIndicator');
    if (ind) {
      ind.classList.remove('active');
      ind.style.opacity = '';
      // Flash a brief "cancelled" hint
      const wordEl = document.getElementById('currentWordEl');
      if (wordEl) {
        wordEl.style.transition = 'color 0.1s';
        wordEl.style.color = 'var(--warn)';
        setTimeout(() => { wordEl.style.color = ''; wordEl.style.transition = ''; }, 350);
      }
    }
    return;
  }

  if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
  const ind = document.getElementById('recIndicator');
  if (ind) { ind.classList.remove('active'); ind.style.opacity = ''; }
  document.getElementById('currentWordEl')?.classList.remove('recording');
}

function processRecording() {
  const blob = new Blob(recordedChunks, { type: 'audio/webm' }), w = words[currentIdx];
  const reader = new FileReader();
  reader.onload = async ev => {
    const ctx = getAudioCtx();
    try {
      let decoded = await ctx.decodeAudioData(ev.target.result.slice(0));
      if (recOffset < 0) {
        const trimSamples = Math.floor(Math.abs(recOffset) / 1000 * decoded.sampleRate);
        const keepSamples = Math.max(0, decoded.length - trimSamples);
        if (keepSamples > 0) {
          const trimmed = ctx.createBuffer(decoded.numberOfChannels, keepSamples, decoded.sampleRate);
          for (let ch = 0; ch < decoded.numberOfChannels; ch++)
            trimmed.copyToChannel(decoded.getChannelData(ch).slice(trimSamples), ch);
          decoded = trimmed;
        }
      }
      // Store raw audio as the original — silence trim becomes trim region, not a destructive cut
      originalBuffers[w] = decoded;
      manualTrimWords.delete(w); // fresh recording resets any manual lock
      _waveformCache = null;
      // Compute silence trim as a region (visible in UI, user-adjustable)
      trimRegions[w] = detectSilenceTrimRegion(decoded, silenceThreshold);
      // Apply it to produce the working buffer + blob
      _applyTrim(w);
      decodedBuffers[w] = decodedBuffers[w] || decoded; // fallback if _applyTrim didn't set it
    } catch(e) { recordingBlobs[w] = blob; }

    renderWordList(); updateStatus();

    if (autoAdvance && currentIdx < words.length - 1) {
      currentIdx++;
    } else if (Object.keys(recordingBlobs).length === words.length) {
      // All done! Brief celebration glow on the progress bar
      setTimeout(() => {
        const fill = document.querySelector('.progress-fill');
        if (fill) {
          fill.style.transition = 'box-shadow 0.3s';
          fill.style.boxShadow = '0 0 24px var(--accent), 0 0 48px rgba(0,255,204,0.5)';
          setTimeout(() => { fill.style.boxShadow = ''; fill.style.transition = ''; }, 1200);
        }
      }, 100);
    }
    renderMain();
  };
  reader.readAsArrayBuffer(blob);
}

// ---- WAVEFORM ----
function startWaveAndPitch() { drawWave(); detectPitch(); }
function drawWave() {
  const canvas = document.getElementById('waveCanvas'); if (!canvas || !analyserNode) return;
  const ctx2d = canvas.getContext('2d');
  canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight;
  const bufLen = analyserNode.frequencyBinCount, dataArr = new Uint8Array(bufLen);
  function draw() {
    if (!analyserNode || !document.getElementById('waveCanvas')) { cancelAnimationFrame(waveAnimId); return; }
    waveAnimId = requestAnimationFrame(draw);
    analyserNode.getByteTimeDomainData(dataArr);
    ctx2d.fillStyle = '#1a1a24'; ctx2d.fillRect(0, 0, canvas.width, canvas.height);
    ctx2d.lineWidth = 1.5; ctx2d.strokeStyle = '#00ffcc'; ctx2d.shadowBlur = 6; ctx2d.shadowColor = '#00ffcc';
    ctx2d.beginPath();
    const sliceW = canvas.width / bufLen; let x = 0;
    for (let i = 0; i < bufLen; i++) {
      const y = (dataArr[i] / 128.0 * canvas.height) / 2;
      i === 0 ? ctx2d.moveTo(x, y) : ctx2d.lineTo(x, y); x += sliceW;
    }
    ctx2d.stroke();
  }
  draw();
}

// ---- PITCH ----
function detectPitch() {
  if (!analyserNode) return;
  const buf = new Float32Array(analyserNode.fftSize), sr = getAudioCtx().sampleRate;
  function detect() {
    if (!analyserNode || !document.getElementById('pitchFill')) { cancelAnimationFrame(pitchAnimId); return; }
    pitchAnimId = requestAnimationFrame(detect);
    analyserNode.getFloatTimeDomainData(buf);
    updatePitchUI(autoCorrelate(buf, sr));
  }
  detect();
}
function autoCorrelate(buf, sr) {
  let SIZE = buf.length, rms = 0;
  for (let i = 0; i < SIZE; i++) rms += buf[i]*buf[i];
  rms = Math.sqrt(rms/SIZE); if (rms < 0.01) return -1;
  let r1=0, r2=SIZE-1;
  for (let i=0;i<SIZE/2;i++) if(Math.abs(buf[i])<0.2){r1=i;break;}
  for (let i=1;i<SIZE/2;i++) if(Math.abs(buf[SIZE-i])<0.2){r2=SIZE-i;break;}
  buf=buf.slice(r1,r2); SIZE=buf.length;
  const c=new Array(SIZE).fill(0);
  for(let i=0;i<SIZE;i++) for(let j=0;j<SIZE-i;j++) c[i]+=buf[j]*buf[j+i];
  let d=0; while(c[d]>c[d+1])d++;
  let maxval=-1,maxpos=-1;
  for(let i=d;i<SIZE;i++) if(c[i]>maxval){maxval=c[i];maxpos=i;}
  let T0=maxpos;
  const x1=c[T0-1],x2=c[T0],x3=c[T0+1],a=(x1+x3-2*x2)/2,b=(x3-x1)/2;
  if(a) T0-=b/(2*a);
  return sr/T0;
}
function updatePitchUI(freq) {
  const fillEl=document.getElementById('pitchFill'),curEl=document.getElementById('pitchCurrent'),offEl=document.getElementById('pitchOffset');
  const lineEl=document.getElementById('sliderPitchLine');
  if(!fillEl) return;
  if(freq<0){
    fillEl.style.width='0%';curEl.textContent='-- Hz';offEl.textContent='--';offEl.className='pitch-offset';
    if(lineEl) lineEl.classList.remove('visible');
    return;
  }
  fillEl.style.width=Math.max(0,Math.min(100,((freq-50)/950)*100))+'%';
  curEl.textContent=freq.toFixed(1)+' Hz';
  const cents=1200*Math.log2(freq/targetFreq),abs=Math.abs(cents);
  offEl.textContent=(cents>0?'+':'')+cents.toFixed(0)+' cents';
  offEl.className=abs<30?'pitch-offset good':abs<80?'pitch-offset warn':'pitch-offset bad';
  // update slider pitch line
  if(lineEl) {
    const slider = document.getElementById('toneSlider');
    if(slider) {
      const min=80, max=800;
      const clampedFreq = Math.max(min, Math.min(max, freq));
      const pct = (clampedFreq - min) / (max - min);
      const w = slider.offsetWidth;
      // account for thumb width (~14px) so it lines up with the track
      const thumbR = 7;
      const trackPx = w - thumbR * 2;
      lineEl.style.left = (thumbR + pct * trackPx - 1) + 'px';
      lineEl.classList.add('visible');
    }
  }
}

// ---- KEYBOARD ----
document.addEventListener('keydown', e => {
  // keybind capture mode
  if (bindingMode) { finishBinding(e); return; }
  if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;

  if (e.key.toLowerCase() === recordKey && !recordKeyDown) {
    recordKeyDown = true;
    if (words.length) startRecording();
    // init mic early on first ever keypress even before reclist loaded
    if (!mediaStream) initAlwaysOnMic();
  }
  const _navTo = idx => {
    stopPlayback(); currentIdx = idx;
    const w = words[currentIdx];
    if (originalBuffers[w] && !manualTrimWords.has(w) && silenceThreshold > 0) {
      trimRegions[w] = detectSilenceTrimRegion(originalBuffers[w], silenceThreshold);
      _applyTrim(w);
    }
    renderWordList(); renderMain();
  };
  if (e.key === 'ArrowUp'    && currentIdx > 0)               { e.preventDefault(); _navTo(currentIdx - 1); }
  if (e.key === 'ArrowDown'  && currentIdx < words.length - 1) { e.preventDefault(); _navTo(currentIdx + 1); }
  if (e.key === 'ArrowLeft'  && words.length)                  { e.preventDefault(); _navTo(0); }
  if (e.key === 'ArrowRight' && words.length)                  { e.preventDefault(); _navTo(words.length - 1); }
  if (e.key === ' ') { e.preventDefault(); if (recordingBlobs[words[currentIdx]]) togglePlayback(); }
});
document.addEventListener('keyup', e => {
  if (bindingMode) return;
  if (e.key.toLowerCase() === recordKey) { recordKeyDown = false; if (isRecording) stopRecording(); }
});

// ---- MIC SELECTION ----
let selectedDeviceId = '';

async function populateMicList() {
  try {
    // need permission first so labels show up
    await navigator.mediaDevices.getUserMedia({ audio: true });
    const devices = await navigator.mediaDevices.enumerateDevices();
    const mics = devices.filter(d => d.kind === 'audioinput');
    const sel = document.getElementById('micSelect');
    if (!sel) return;
    sel.innerHTML = '<option value="">default mic</option>';
    mics.forEach(d => {
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = d.label || `mic ${d.deviceId.slice(0,6)}`;
      if (d.deviceId === selectedDeviceId) opt.selected = true;
      sel.appendChild(opt);
    });
  } catch(e) { console.warn('mic enum failed:', e.message); }
}

async function onMicChange() {
  const sel = document.getElementById('micSelect');
  selectedDeviceId = sel ? sel.value : '';
  // tear down existing stream so next initAlwaysOnMic picks new device
  stopSilenceWatch();
  clearMicPanic();
  if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }
  if (alwaysOnSource) { try { alwaysOnSource.disconnect(); } catch(e) {} alwaysOnSource = null; }
  cancelAnimationFrame(waveAnimId); cancelAnimationFrame(pitchAnimId);
  await initAlwaysOnMic();
  if (analyserNode && words.length) startSilenceWatch();
}

// ---- FRQ GENERATION ----
// Generates a UTAU-compatible .frq binary from an AudioBuffer using autocorrelation pitch detection.
function generateFrqBinary(audioBuffer) {
  const HOP = 256;
  const sr = audioBuffer.sampleRate;
  const rawData = audioBuffer.getChannelData(0); // mono
  const nFrames = audioBuffer.length;
  const nPoints = Math.floor(nFrames / HOP);

  const freqs = [];
  for (let i = 0; i < nPoints; i++) {
    const start = i * HOP;
    const frame = rawData.slice(start, start + HOP * 4); // use 4 hops for autocorrelation window
    const f = autoCorrelateBuffer(frame, sr);
    freqs.push(f > 0 ? f : 0.0);
  }

  const valid = freqs.filter(f => f > 0);
  const avgPitch = valid.length ? valid.reduce((a, b) => a + b, 0) / valid.length : 0.0;

  // Build binary: FREQ0003 header + hop(int32) + avgPitch(float64) + 16 null bytes + count(int32) + [freq(f64), amp(f64)]...
  const headerStr = 'FREQ0003';
  const totalDoubles = freqs.length * 2;
  const byteLen = 8 + 4 + 8 + 16 + 4 + totalDoubles * 8;
  const buf = new ArrayBuffer(byteLen);
  const view = new DataView(buf);
  let off = 0;

  for (let i = 0; i < 8; i++) { view.setUint8(off++, headerStr.charCodeAt(i)); }
  view.setInt32(off, HOP, true); off += 4;
  view.setFloat64(off, avgPitch, true); off += 8;
  for (let i = 0; i < 16; i++) { view.setUint8(off++, 0); }
  view.setInt32(off, freqs.length, true); off += 4;
  for (const f of freqs) {
    view.setFloat64(off, f, true); off += 8;
    view.setFloat64(off, 0.0, true); off += 8;
  }
  return buf;
}

function autoCorrelateBuffer(buf, sr) {
  let SIZE = buf.length;
  let rms = 0;
  for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
  rms = Math.sqrt(rms / SIZE);
  if (rms < 0.01) return -1;

  let r1 = 0, r2 = SIZE - 1;
  for (let i = 0; i < SIZE / 2; i++) { if (Math.abs(buf[i]) < 0.2) { r1 = i; break; } }
  for (let i = 1; i < SIZE / 2; i++) { if (Math.abs(buf[SIZE - i]) < 0.2) { r2 = SIZE - i; break; } }
  buf = buf.slice(r1, r2); SIZE = buf.length;
  if (SIZE < 2) return -1;

  const c = new Array(SIZE).fill(0);
  for (let i = 0; i < SIZE; i++) for (let j = 0; j < SIZE - i; j++) c[i] += buf[j] * buf[j + i];
  let d = 0;
  while (d < SIZE - 1 && c[d] > c[d + 1]) d++;
  let maxval = -1, maxpos = -1;
  for (let i = d; i < SIZE; i++) { if (c[i] > maxval) { maxval = c[i]; maxpos = i; } }
  if (maxpos <= 0 || maxpos >= SIZE - 1) return -1;
  let T0 = maxpos;
  const x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1], a = (x1 + x3 - 2 * x2) / 2, b = (x3 - x1) / 2;
  if (a) T0 -= b / (2 * a);
  const freq = sr / T0;
  return (freq >= 55 && freq <= 1000) ? freq : 0.0;
}

// ---- EXPORT ----
async function exportAll() {
  if (!Object.keys(recordingBlobs).length) { alert('no recordings yet... hold the record key first.'); return; }
  // reset modal state
  document.getElementById('exportMsg').textContent = 'name your voicebank and hit export.';
  document.getElementById('exportProgressMsg').style.display = 'none';
  document.getElementById('exportConfirmBtn').style.display = '';
  document.getElementById('downloadZipBtn').style.display = 'none';
  document.getElementById('vbNameInput').value = '';
  openModal('exportModal');
}

function analyzeAudioForOto(buffer) {
  const data = buffer.getChannelData(0);
  const sr = buffer.sampleRate;
  const totalMs = (data.length / sr) * 1000;

  // ---- 1. Detect start of sound (first significant amplitude) ----
  const startThreshold = 0.015;
  let startSample = 0;
  for (let i = 0; i < data.length; i++) {
    if (Math.abs(data[i]) >= startThreshold) { startSample = i; break; }
  }

  // ---- 2. Detect end of sound (last significant amplitude) ----
  const endThreshold = 0.01;
  let endSample = data.length - 1;
  for (let i = data.length - 1; i > startSample; i--) {
    if (Math.abs(data[i]) >= endThreshold) { endSample = i; break; }
  }

  const startMs = (startSample / sr) * 1000;
  const endMs   = (endSample   / sr) * 1000;
  const activeMs = endMs - startMs;

  // ---- 3. Detect consonant-vowel boundary using short-term energy ----
  // Window of ~10ms, stride ~5ms. Find where energy stabilises after the
  // initial spike — that's roughly where the vowel begins.
  const winSamples = Math.round(sr * 0.010);
  const stepSamples = Math.round(sr * 0.005);
  const energies = [];
  for (let i = startSample; i < endSample - winSamples; i += stepSamples) {
    let e = 0;
    for (let j = i; j < i + winSamples; j++) e += data[j] * data[j];
    energies.push({ ms: ((i + winSamples / 2) / sr) * 1000, e: e / winSamples });
  }

  // Find peak energy
  let peakE = 0;
  for (const pt of energies) if (pt.e > peakE) peakE = pt.e;

  // Vowel boundary = first frame after start where energy > 40% of peak
  // and we've moved at least a few ms past the initial transient
  let vowelStartMs = startMs + 80; // default fallback
  const vowelThresh = peakE * 0.40;
  let passedTransient = false;
  let transientEndMs = startMs;

  // Find first local energy peak (end of transient/consonant burst)
  for (let i = 1; i < energies.length - 1; i++) {
    if (energies[i].e >= energies[i - 1].e && energies[i].e >= energies[i + 1].e &&
        energies[i].e > peakE * 0.1) {
      transientEndMs = energies[i].ms;
      break;
    }
  }

  // Vowel starts after transient settles and energy is sustained
  for (const pt of energies) {
    if (pt.ms > transientEndMs + 20 && pt.e > vowelThresh && !passedTransient) {
      vowelStartMs = pt.ms;
      passedTransient = true;
      break;
    }
  }

  // ---- 4. Calculate oto values ----
  const consonantMs = Math.max(30, Math.min(200, Math.round(vowelStartMs - startMs)));
  const cutoffMs    = Math.max(50, Math.round(totalMs - endMs));

  return {
    offset:    Math.round(startMs),
    consonant: consonantMs,
    cutoff:    -cutoffMs,
    preutter:  consonantMs,
    overlap:   Math.round(consonantMs * 0.5)
  };
}

async function runExport() {
  const vbName = (document.getElementById('vbNameInput')?.value.trim() || 'MyVoicebank').replace(/[\\/:*?"<>|]/g, '_');

  document.getElementById('exportConfirmBtn').style.display = 'none';
  document.getElementById('exportMsg').textContent = 'building...';
  document.getElementById('exportProgressMsg').style.display = 'block';
  document.getElementById('exportProgressMsg').textContent = 'loading...';

  if (!document.querySelector('script[src*="jszip"]')) {
    const s = document.createElement('script'); s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js'; document.head.appendChild(s);
    await new Promise(res => s.onload = res);
  }

  const zip = new JSZip();
  const folder = zip.folder(vbName);
  const otoLines = [];
  const entries = Object.entries(recordingBlobs);

  document.getElementById('exportProgressMsg').textContent = `generating .frq files (0 / ${entries.length})...`;

  const ctx = getAudioCtx();

  for (let idx = 0; idx < entries.length; idx++) {
    const [word, blob] = entries[idx];
    const dn = displayName(word);
    const fname = '_' + dn;

    // wav
    folder.file(fname + '.wav', await blob.arrayBuffer());

    // oto.ini line — calculate values from actual clip duration
    const alias = dn.replace(/\s+/g, '');
    let audioBuf = decodedBuffers[word];
    if (!audioBuf) {
      const ab = await blob.arrayBuffer();
      audioBuf = await ctx.decodeAudioData(ab.slice(0));
      decodedBuffers[word] = audioBuf;
    }
    const oto = analyzeAudioForOto(audioBuf);
    otoLines.push(`${fname}.wav=${alias},${oto.offset},${oto.consonant},${oto.cutoff},${oto.preutter},${oto.overlap}`);

    // .frq
    try {
      const frqBinary = generateFrqBinary(audioBuf);
      folder.file(fname + '.wav.frq', frqBinary);
    } catch(e) {
      console.warn('frq gen failed for', word, e);
    }

    document.getElementById('exportProgressMsg').textContent = `generating .frq files (${idx + 1} / ${entries.length})...`;
    if (idx % 5 === 0) await new Promise(r => setTimeout(r, 0));
  }

  // oto.ini (UTF-8 with BOM)
  folder.file('oto.ini', '\uFEFF' + otoLines.join('\r\n'));
  folder.file('character.txt', `name=${vbName}\r\n`);
  folder.file('character.yaml',
    `name: ${vbName}\r\ntext_file_encoding: utf-8\r\nportrait_opacity: 0.67\r\nportrait_height: 0\r\n`
  );

  document.getElementById('exportProgressMsg').style.display = 'none';
  document.getElementById('exportMsg').textContent = `${entries.length} wavs + frq files + oto.ini + character files ready.`;

  // encodeFileName: encode as UTF-8 bytes so JSZip sets the UTF-8 language
  // encoding flag (bit 11) in every local file header. Without this flag,
  // apps like OpenUtau fall back to CP437/Latin and Japanese chars get mangled.
  const utf8Enc = new TextEncoder();
  const content = await zip.generateAsync({
    type: 'blob',
    encodeFileName: s => utf8Enc.encode(s)
  });
  const url = URL.createObjectURL(content);
  const dlBtn = document.getElementById('downloadZipBtn');
  dlBtn.style.display = '';
  dlBtn.innerHTML = '&#8659; download .zip';
  dlBtn.onclick = () => {
    const a = document.createElement('a');
    a.href = url; a.download = vbName + '.zip'; a.click();
  };
}

// ---- CLEAR ----
function clearAll() {
  if (!confirm('clear all recordings? ...you sure?')) return;
  recordingBlobs = {}; decodedBuffers = {}; originalBuffers = {}; trimRegions = {}; manualTrimWords.clear(); stopPlayback(); renderWordList(); renderMain(); updateStatus();
}

function updateStatus() {
  document.getElementById('statusTotal').textContent = words.length;
  document.getElementById('statusDone').textContent = Object.keys(recordingBlobs).length;
  // update document title with progress
  const done = Object.keys(recordingBlobs).length;
  const total = words.length;
  if (total > 0) {
    const pct = Math.round(done / total * 100);
    document.title = `BONEMO [${pct}% — ${done}/${total}]`;
  } else {
    document.title = 'BONEMO - Voice Recording Studio';
  }
  // update mobile word tab progress
  const prog = `${Object.keys(recordingBlobs).length} / ${words.length}`;
  const p1 = document.getElementById('mobWordProgress'); if (p1) p1.textContent = prog;
  const p2 = document.getElementById('mobWordProgress2'); if (p2) p2.textContent = prog;
  renderMobWordList();
}
function openModal(id) { document.getElementById(id).classList.add('show'); }
function closeModal(id) { document.getElementById(id).classList.remove('show'); }

// ---- MOBILE SETTINGS DRAWER ----
function openMobSettings() { document.getElementById('mobSettingsDrawer').classList.add('open'); }
function closeMobSettings() { document.getElementById('mobSettingsDrawer').classList.remove('open'); }

// ---- MOBILE WORD LIST ----
let mobWordOpen = false;
function toggleMobWordList() {
  mobWordOpen = !mobWordOpen;
  const panel = document.getElementById('mobWordPanel');
  const tab = document.getElementById('mobWordTab');
  if (panel) panel.classList.toggle('open', mobWordOpen);
  if (tab) tab.classList.toggle('tab-open', mobWordOpen);
  if (mobWordOpen) renderMobWordList();
}

function renderMobWordList() {
  const el = document.getElementById('mobWordList'); if (!el) return;
  if (!words.length) { el.innerHTML = '<div style="padding:12px;font-family:\'Share Tech Mono\',monospace;font-size:0.75rem;color:var(--muted);text-align:center">no reclist loaded</div>'; return; }
  el.innerHTML = words.map((w, i) => {
    const active = i === currentIdx, done = !!recordingBlobs[w];
    const dn = displayName(w);
    return `<div class="word-item ${active?'active':''} ${done?'done':''}" onclick="selectWord(${i});toggleMobWordList()"><span>${dn}</span><span class="word-status">${done?'REC':''}</span></div>`;
  }).join('');
  setTimeout(() => { const a = el.querySelector('.active'); if (a) a.scrollIntoView({ block: 'nearest' }); }, 0);
}

// ---- MOBILE MIRROR CONTROLS ----
// these keep the mob drawer controls in sync with the desktop ones
function onNoteSelectMob() {
  const val = parseFloat(document.getElementById('noteSelectMob').value);
  const ds = document.getElementById('toneSlider'); if (ds) ds.value = val;
  const dm = document.getElementById('toneSliderMob'); if (dm) dm.value = val;
  targetFreq = val;
  document.getElementById('toneVal').textContent = val.toFixed(0) + ' Hz';
  document.getElementById('toneValMob').textContent = val.toFixed(0) + ' Hz';
  document.getElementById('statusTone').textContent = val.toFixed(0) + ' Hz';
  snapNoteSelect(val);
  updatePitchTargetLine();
}
function onToneChangeMob() {
  const val = parseFloat(document.getElementById('toneSliderMob').value);
  const ds = document.getElementById('toneSlider'); if (ds) ds.value = val;
  targetFreq = val;
  document.getElementById('toneVal').textContent = val.toFixed(0) + ' Hz';
  document.getElementById('toneValMob').textContent = val.toFixed(0) + ' Hz';
  document.getElementById('statusTone').textContent = val.toFixed(0) + ' Hz';
  snapNoteSelect(val);
  updatePitchTargetLine();
}
function onOffsetChangeMob() {
  recOffset = parseInt(document.getElementById('recOffsetSliderMob').value);
  const ds = document.getElementById('recOffsetSlider'); if (ds) ds.value = recOffset;
  const lbl = (recOffset > 0 ? '+' : '') + recOffset + ' ms';
  const v1 = document.getElementById('recOffsetVal'); if (v1) v1.textContent = lbl;
  const v2 = document.getElementById('recOffsetValMob'); if (v2) v2.textContent = lbl;
}
function onSilenceChangeMob() {
  silenceThreshold = parseFloat(document.getElementById('silenceSliderMob').value);
  const ds = document.getElementById('silenceSlider'); if (ds) ds.value = silenceThreshold;
  const txt = silenceThreshold === 0 ? 'off' : silenceThreshold.toFixed(3);
  const v1 = document.getElementById('silenceVal'); if (v1) v1.textContent = txt;
  const v2 = document.getElementById('silenceValMob'); if (v2) v2.textContent = txt;
  _applyGlobalSilenceTrim();
}
function onMicChangeMob() {
  const sel = document.getElementById('micSelectMob');
  selectedDeviceId = sel ? sel.value : '';
  const ds = document.getElementById('micSelect'); if (ds) ds.value = selectedDeviceId;
  onMicChange();
}

// patch toggleRomaji and toggleAutoAdvance to also update mob mirror buttons
const _origToggleRomaji = toggleRomaji;
toggleRomaji = function() {
  _origToggleRomaji();
  const b = document.getElementById('romajiToggleBtnMob');
  if (b) { b.textContent = `Show Romaji: ${showRomaji?'ON':'OFF'}`; b.className = showRomaji ? 'btn active-toggle' : 'btn'; }
};
const _origToggleAutoAdvance = toggleAutoAdvance;
toggleAutoAdvance = function() {
  _origToggleAutoAdvance();
  const b = document.getElementById('autoAdvanceBtnMob');
  if (b) { b.textContent = `Auto-advance: ${autoAdvance?'ON':'OFF'}`; b.className = autoAdvance ? 'btn active-toggle' : 'btn'; }
};
const _origToggleHoverPlay = toggleHoverPlay;
toggleHoverPlay = function() {
  _origToggleHoverPlay();
  // desktop button is already updated inside the original; sync mob
  const b = document.getElementById('hoverPlayBtnMob');
  if (b) { b.textContent = `Hover Play: ${hoverPlay?'ON':'OFF'}`; b.className = hoverPlay ? 'btn active-toggle' : 'btn'; }
};

// patch populateMicList to also fill mob select
const _origPopulateMicList = populateMicList;
populateMicList = async function() {
  await _origPopulateMicList();
  // mirror to mob select
  const src = document.getElementById('micSelect');
  const dst = document.getElementById('micSelectMob');
  if (src && dst) { dst.innerHTML = src.innerHTML; dst.value = selectedDeviceId; }
};

// ---- INIT ----
window.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('toneSlider');
  if (slider) {
    targetFreq = parseFloat(slider.value);
    document.getElementById('toneVal').textContent = targetFreq.toFixed(0) + ' Hz';
    document.getElementById('statusTone').textContent = targetFreq.toFixed(0) + ' Hz';
    snapNoteSelect(targetFreq);
    updatePitchTargetLine();
  }
  // restore saved accent color
  const savedColor = localStorage.getItem('bonemo_accent_color');
  if (savedColor) { _applyAccentColor(savedColor, false); }
});

// ---- CUSTOM COLOR PICKER ----
const DEFAULT_ACCENT = '#00ffcc';
const CP_SWATCHES = ['#00ffcc','#ff4466','#ffcc00','#00aaff','#ff00ff','#ff6600','#00ff88','#aa00ff','#ff0055','#ffffff'];

let cpH = 174, cpS = 1.0, cpV = 1.0;
let cpOpen = false;
let _cpDragging = null;

function toggleCP(e) {
  e.stopPropagation();
  cpOpen ? closeCP() : openCP();
}

function openCP() {
  cpOpen = true;
  const pop = document.getElementById('cpPopup');
  pop.style.display = 'block';

  const skull = document.getElementById('skullBtn');
  const rect = skull.getBoundingClientRect();
  const panel = document.getElementById('cpPanel');

  requestAnimationFrame(() => {
    const pw = panel.offsetWidth, ph = panel.offsetHeight;
    let x = rect.left, y = rect.bottom + 8;
    if (x + pw > window.innerWidth - 8) x = window.innerWidth - pw - 8;
    if (y + ph > window.innerHeight - 8) y = rect.top - ph - 8;
    panel.style.position = 'fixed';
    panel.style.left = Math.max(4, x) + 'px';
    panel.style.top = Math.max(4, y) + 'px';

    const cur = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || DEFAULT_ACCENT;
    const hsv = hexToHsv(cur);
    cpH = hsv.h; cpS = hsv.s; cpV = hsv.v;

    _cpDraw();
    _cpBuildSwatches();
    _cpSyncHex();
    _cpSyncPreview();
    requestAnimationFrame(_cpSyncThumbs);
  });

  _cpBindEvents();
}

function closeCP() {
  cpOpen = false;
  document.getElementById('cpPopup').style.display = 'none';
  _cpUnbindEvents();
}

function cpConfirm() {
  if (rainbowActive) toggleRainbow();
  const hex = hsvToHex(cpH, cpS, cpV);
  onAccentColorChange(hex);
  closeCP();
}

function cpHexTyped(val) {
  if (rainbowActive) toggleRainbow();
  val = val.replace(/[^0-9a-fA-F]/g, '');
  document.getElementById('cpHexInput').value = val;
  if (val.length === 6) {
    const hsv = hexToHsv('#' + val);
    cpH = hsv.h; cpS = hsv.s; cpV = hsv.v;
    _cpDraw(); _cpSyncPreview(); requestAnimationFrame(_cpSyncThumbs);
  }
}

function _cpDraw() {
  _cpDrawSatVal();
  _cpDrawHueTrack();
  _cpDrawValTrack();
  _cpDrawSatTrack();
}

function _cpDrawSatVal() {
  const cv = document.getElementById('cpSatVal'); if (!cv) return;
  const W = cv.width, H = cv.height, ctx = cv.getContext('2d');
  ctx.fillStyle = `hsl(${cpH},100%,50%)`;
  ctx.fillRect(0, 0, W, H);
  const wg = ctx.createLinearGradient(0, 0, W, 0);
  wg.addColorStop(0, 'rgba(255,255,255,1)');
  wg.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = wg; ctx.fillRect(0, 0, W, H);
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, 'rgba(0,0,0,0)');
  bg.addColorStop(1, 'rgba(0,0,0,1)');
  ctx.fillStyle = bg; ctx.fillRect(0, 0, W, H);
}

function _cpDrawHueTrack() {
  const cv = document.getElementById('cpHueTrack'); if (!cv) return;
  const W = cv.width, H = cv.height, ctx = cv.getContext('2d');
  const g = ctx.createLinearGradient(0, 0, W, 0);
  for (let i = 0; i <= 12; i++) g.addColorStop(i / 12, `hsl(${i * 30},100%,50%)`);
  ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);
}

function _cpDrawValTrack() {
  const cv = document.getElementById('cpValTrack'); if (!cv) return;
  const W = cv.width, H = cv.height, ctx = cv.getContext('2d');
  const hsl = hsvToHsl(cpH, cpS, 1);
  const g = ctx.createLinearGradient(0, 0, W, 0);
  g.addColorStop(0, '#000');
  g.addColorStop(1, `hsl(${cpH},${Math.round(hsl.s * 100)}%,${Math.round(hsl.l * 100)}%)`);
  ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);
}

function _cpDrawSatTrack() {
  const cv = document.getElementById('cpSatTrack'); if (!cv) return;
  const W = cv.width, H = cv.height, ctx = cv.getContext('2d');
  const hsl1 = hsvToHsl(cpH, 0, cpV), hsl2 = hsvToHsl(cpH, 1, cpV);
  const g = ctx.createLinearGradient(0, 0, W, 0);
  g.addColorStop(0, `hsl(${cpH},${Math.round(hsl1.s * 100)}%,${Math.round(hsl1.l * 100)}%)`);
  g.addColorStop(1, `hsl(${cpH},${Math.round(hsl2.s * 100)}%,${Math.round(hsl2.l * 100)}%)`);
  ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);
}

function _cpSyncThumbs() {
  const cv = document.getElementById('cpSatVal'); if (!cv) return;
  const panel = document.getElementById('cpPanel');
  const pr = panel.getBoundingClientRect();
  const svR = cv.getBoundingClientRect();

  const svT = document.getElementById('cpSatValThumb');
  svT.style.left = (svR.left - pr.left + cpS * svR.width) + 'px';
  svT.style.top = (svR.top - pr.top + (1 - cpV) * svR.height) + 'px';
  svT.style.borderColor = cpV > 0.45 ? '#fff' : '#999';

  const setThumb = (id, trackId, pct) => {
    const tr = document.getElementById(trackId); if (!tr) return;
    const r = tr.getBoundingClientRect();
    document.getElementById(id).style.left = (pct * r.width) + 'px';
  };
  setThumb('cpHueThumb', 'cpHueTrack', cpH / 360);
  setThumb('cpValThumb', 'cpValTrack', cpV);
  setThumb('cpSatThumb', 'cpSatTrack', cpS);
}

function _cpSyncHex() {
  const hex = hsvToHex(cpH, cpS, cpV).slice(1).toUpperCase();
  const inp = document.getElementById('cpHexInput'); if (inp) inp.value = hex;
}

function _cpSyncPreview() {
  const hex = hsvToHex(cpH, cpS, cpV);
  const pv = document.getElementById('cpPreview'); if (!pv) return;
  pv.style.background = hex;
  pv.style.boxShadow = `0 0 18px ${hex}99`;
}

function _cpBuildSwatches() {
  const row = document.getElementById('cpSwatchRow'); if (!row) return;
  row.innerHTML = CP_SWATCHES.map(c =>
    `<div class="cp-sw" style="background:${c}" onclick="cpPickSwatch('${c}')" title="${c}"></div>`
  ).join('');
}

function cpPickSwatch(hex) {
  const hsv = hexToHsv(hex);
  cpH = hsv.h; cpS = hsv.s; cpV = hsv.v;
  _cpDraw(); _cpSyncPreview(); _cpSyncHex(); requestAnimationFrame(_cpSyncThumbs);
}

function _cpClientXY(e) {
  return e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY }
                   : { x: e.clientX, y: e.clientY };
}

function _cpBindEvents() {
  const sv = document.getElementById('cpSatVal');
  const ht = document.getElementById('cpHueTrack');
  const vt = document.getElementById('cpValTrack');
  const st = document.getElementById('cpSatTrack');
  if (!sv) return;

  const down = (type) => (e) => { _cpDragging = type; _cpHandle(type, e); e.preventDefault(); };
  sv._cpD = down('sv');   ht._cpD = down('hue');
  vt._cpD = down('val');  st._cpD = down('sat');
  [sv, ht, vt, st].forEach(el => {
    el.addEventListener('mousedown', el._cpD);
    el.addEventListener('touchstart', el._cpD, { passive: false });
  });

  window._cpMov = (e) => { if (_cpDragging) { _cpHandle(_cpDragging, e); e.preventDefault && e.preventDefault(); } };
  window._cpUp  = () => { _cpDragging = null; };
  window.addEventListener('mousemove', window._cpMov);
  window.addEventListener('mouseup',   window._cpUp);
  window.addEventListener('touchmove', window._cpMov, { passive: false });
  window.addEventListener('touchend',  window._cpUp);
}

function _cpUnbindEvents() {
  if (window._cpMov) window.removeEventListener('mousemove', window._cpMov);
  if (window._cpUp)  window.removeEventListener('mouseup',   window._cpUp);
  if (window._cpMov) window.removeEventListener('touchmove', window._cpMov);
  if (window._cpUp)  window.removeEventListener('touchend',  window._cpUp);
}

function _cpHandle(type, e) {
  if (rainbowActive) toggleRainbow();
  const xy = _cpClientXY(e);
  if (type === 'sv') {
    const r = document.getElementById('cpSatVal').getBoundingClientRect();
    cpS = Math.max(0, Math.min(1, (xy.x - r.left) / r.width));
    cpV = Math.max(0, Math.min(1, 1 - (xy.y - r.top) / r.height));
    _cpDrawValTrack(); _cpDrawSatTrack();
  } else if (type === 'hue') {
    const r = document.getElementById('cpHueTrack').getBoundingClientRect();
    cpH = Math.max(0, Math.min(360, ((xy.x - r.left) / r.width) * 360));
    _cpDraw();
  } else if (type === 'val') {
    const r = document.getElementById('cpValTrack').getBoundingClientRect();
    cpV = Math.max(0, Math.min(1, (xy.x - r.left) / r.width));
    _cpDrawSatTrack();
  } else if (type === 'sat') {
    const r = document.getElementById('cpSatTrack').getBoundingClientRect();
    cpS = Math.max(0, Math.min(1, (xy.x - r.left) / r.width));
    _cpDrawValTrack();
  }
  _cpSyncThumbs(); _cpSyncHex(); _cpSyncPreview();
}

// ---- color math ----
function hexToRgb(hex) {
  hex = hex.replace('#','');
  if (hex.length === 3) hex = hex.split('').map(c => c+c).join('');
  return { r: parseInt(hex.slice(0,2),16), g: parseInt(hex.slice(2,4),16), b: parseInt(hex.slice(4,6),16) };
}
function hexToHsv(hex) {
  let {r,g,b} = hexToRgb(hex);
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
  let h=0, s=max===0?0:d/max, v=max;
  if (d!==0) {
    if (max===r) h=((g-b)/d+6)%6;
    else if (max===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h*=60;
  }
  return {h,s,v};
}
function hsvToRgb(h,s,v) {
  const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
  let r=0,g=0,b=0;
  if(h<60){r=c;g=x;}else if(h<120){r=x;g=c;}else if(h<180){g=c;b=x;}
  else if(h<240){g=x;b=c;}else if(h<300){r=x;b=c;}else{r=c;b=x;}
  return {r:Math.round((r+m)*255),g:Math.round((g+m)*255),b:Math.round((b+m)*255)};
}
function hsvToHex(h,s,v) {
  const {r,g,b}=hsvToRgb(h,s,v);
  return '#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('');
}
function hsvToHsl(h,s,v) {
  const l=v*(1-s/2), sl=(l===0||l===1)?0:(v-l)/Math.min(l,1-l);
  return {h,s:sl,l};
}
function hexToRgba(hex, a) {
  const {r,g,b}=hexToRgb(hex); return `rgba(${r},${g},${b},${a})`;
}
function deriveGood(hex) {
  const {r,g,b}=hexToRgb(hex);
  return '#'+[Math.round(r*0.6),Math.min(255,Math.round(g*1.1+20)),Math.round(b*0.7)].map(x=>x.toString(16).padStart(2,'0')).join('');
}
function hexToHue(hex) {
  return hexToHsv(hex).h;
}

function _applyAccentColor(hex, save = true) {
  const root = document.documentElement;
  root.style.setProperty('--accent', hex);
  root.style.setProperty('--good', deriveGood(hex));

  // hue-rotate skull
  const rotation = hexToHue(hex) - 174;
  const skullSvg = document.getElementById('skullSvg');
  if (skullSvg) skullSvg.style.filter = `hue-rotate(${rotation}deg)`;

  // dynamic style for glow effects
  let dynStyle = document.getElementById('dynAccentStyle');
  if (!dynStyle) { dynStyle = document.createElement('style'); dynStyle.id = 'dynAccentStyle'; document.head.appendChild(dynStyle); }
  dynStyle.textContent = `
    .seq-divider { background:${hex}!important; box-shadow:0 0 6px ${hex},0 0 14px ${hex},0 0 28px ${hexToRgba(hex,0.4)}!important; }
    h1 { text-shadow:0 0 20px ${hex},0 0 40px ${hexToRgba(hex,0.3)}!important; }
    #cpPanel { border-top-color:${hex}!important; }
    #cpApply { border-color:${hex}!important; color:${hex}!important; text-shadow:0 0 8px ${hex}!important; }
    #cpApply:hover { box-shadow:0 0 16px ${hexToRgba(hex,0.4)}!important; }
    #cpHeader { color:${hex}!important; text-shadow:0 0 12px ${hex}!important; }
  `;

  if (save) localStorage.setItem('bonemo_accent_color', hex);
}

function onAccentColorChange(hex) {
  _applyAccentColor(hex, true);
}

// ---- RAINBOW MODE ----
let _rainbowRaf = null;
let _rainbowHue = 0;
let rainbowActive = false;

function toggleRainbow() {
  rainbowActive = !rainbowActive;
  const btn = document.getElementById('cpRainbowBtn');
  if (btn) btn.classList.toggle('active', rainbowActive);
  if (rainbowActive) {
    _rainbowHue = cpH;
    _rainbowTick();
  } else {
    if (_rainbowRaf) { cancelAnimationFrame(_rainbowRaf); _rainbowRaf = null; }
  }
}

function _rainbowTick() {
  if (!rainbowActive) return;
  _rainbowHue = (_rainbowHue + 0.8) % 360;
  const hex = hsvToHex(_rainbowHue, 1, 1);
  _applyAccentColor(hex, true);
  // sync picker state too if it's open
  if (cpOpen) {
    cpH = _rainbowHue; cpS = 1; cpV = 1;
    _cpDraw(); _cpSyncPreview(); _cpSyncHex(); requestAnimationFrame(_cpSyncThumbs);
  }
  _rainbowRaf = requestAnimationFrame(_rainbowTick);
}
function audioBufferToWavBlob(buffer) {
  const nc=buffer.numberOfChannels,sr=buffer.sampleRate,dl=buffer.length*nc*2;
  const ab=new ArrayBuffer(44+dl),v=new DataView(ab);
  const ws=(o,s)=>{for(let i=0;i<s.length;i++)v.setUint8(o+i,s.charCodeAt(i));};
  ws(0,'RIFF');v.setUint32(4,36+dl,true);ws(8,'WAVE');ws(12,'fmt ');
  v.setUint32(16,16,true);v.setUint16(20,1,true);v.setUint16(22,nc,true);
  v.setUint32(24,sr,true);v.setUint32(28,sr*nc*2,true);v.setUint16(32,nc*2,true);
  v.setUint16(34,16,true);ws(36,'data');v.setUint32(40,dl,true);
  let off=44;
  for(let i=0;i<buffer.length;i++) for(let ch=0;ch<nc;ch++){
    const s=Math.max(-1,Math.min(1,buffer.getChannelData(ch)[i]));
    v.setInt16(off,s<0?s*0x8000:s*0x7FFF,true);off+=2;
  }
  return new Blob([ab],{type:'audio/wav'});
}
</script>
</body>
</html>
