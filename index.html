<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>BONEMO - Voice Recording Studio</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI0OC4yODEyOCIgaGVpZ2h0PSIyOS44NzgzOSIgdmlld0JveD0iMCwwLDQ4LjI4MTI4LDI5Ljg3ODM5Ij48ZGVmcz48bGluZWFyR3JhZGllbnQgeDE9IjIyOC45MzM2IiB5MT0iMTcwLjA3NDU1IiB4Mj0iMjI4LjkzMzYiIHkyPSIyMTMuNDg1MTUiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBpZD0iY29sb3ItMSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMDBmZmNlIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMjQzODM0Ii8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgeDE9IjI0MC4zOTQ0OSIgeTE9IjE2Ny4yNjU0MSIgeDI9IjI0MC4zOTQ0OSIgeTI9IjE5MC43NzgiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBpZD0iY29sb3ItMiI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjNzhmZmU1Ii8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgeDE9IjIzNC4xNDgzNiIgeTE9IjE4Mi45NzkwOSIgeDI9IjIzNC4xNDgzNiIgeTI9IjE5MS45MjU5OSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGlkPSJjb2xvci0zIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmZmZmYiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM3OGZmZTUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCB4MT0iMjUzLjg2NDE3IiB5MT0iMTcwLjgyMDgxIiB4Mj0iMjUzLjg2NDE3IiB5Mj0iMjE0LjIzMTQyIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgaWQ9ImNvbG9yLTQiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzAwZmZjZSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2EyZmZlZSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMTcuMjU4MjQsLTE2Ny4yMjg5OSkiPjxnIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjMwLjUyOTkyLDE4MC4wMzMzN2wtMy4yMjIyMSwtNC43NTIwOWwzLjc0NTE5LC02LjMwMjg5bDUuMjA2NzMsMy43NDUxOWwwLjczMDc3LDYuMDI4ODR6IiBmaWxsPSIjMDBmZmNlIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjMzLjA2MDQxLDE4OS4zMzExOWwtNS45NDk3Miw3LjAyOTkzbC05Ljg1MjQ1LC04LjkwMTg0YzAsMCA2LjU2NjE1LC0yLjg2NzY5IDcuNjgyMzksLTcuOTU2MDRjMS4yMTkyLC01LjU1NzY4IDEuNzI3NjUsLTkuNDI4NyAxLjcyNzY1LC05LjQyODdsNC43NSwyLjAwOTYydjQuOTMyNjl6IiBmaWxsPSJ1cmwoI2NvbG9yLTEpIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjI5LjE1MjQ5LDE3MC44Nzk4MWwtMi4xMjcxLDMuODM0OTFsMS44Mzg4NCwzLjQ4NDIxbC0wLjUzMTMyLDAuNTEwNDVsLTIuMDg1OSwtNC4zMDcyMmwyLjQ5NjI4LC00LjUwNDQ1bDEuNjQ2NjMsMC40MzkzbC0wLjUxOTM5LDAuNjYxOXoiIGZpbGw9IiNmZjAwOTQiIHN0cm9rZT0iI2I2NTkxYiIvPjxwYXRoIGQ9Ik0yMjcuOTM2OTEsMTg3Ljc0MTc1bDAuMTMwOCwtNC4xNTQwNmwwLjY5MzQ4LC0zLjA0OThsLTAuNzA1NDIsLTMuNDg5ODlsMC4wMDUxMSwtMi4zMjE2M2w4LjkxMTY1LC03LjQ2MDk2bDEwLjkwODEzLDIuNzc0NDVsNC45NzE0MiwxMC4xNDA1N2wtMS42MTE0Myw4LjgwMDg4bC0xMC4yOTQ3NiwxLjc5NjY5eiIgZmlsbD0idXJsKCNjb2xvci0yKSIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTIyOC41NjEyOSwxNzcuNTc4ODJsLTAuMjcxMDcsLTIuNzU2MjNsOS44NjQ0LC0wLjM5NjI4eiIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTI0MS4wMzA4MSwxOTAuNzk2OTJsNS42ODk5NywtOS42NDQwMWw0LjUwMDU0LC00LjQ2ODM5bDAuMjg5MzIsMTIuMjgwMDV6IiBmaWxsPSIjNWNlNmNiIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjM4LjQwOTM1LDE3NC40NTAxMmw5LjYxNDA4LC00LjQyOTQzbDQuMDEzNjQsNy43NjExOGwtNS4zNDc2OSwzLjI5OTZ6IiBmaWxsPSIjYjVmZmYxIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjI4LjA0ODQzLDE4Ny42NjA1NmwtMC4wMjIwMiwtNC4xOTAyOGwwLjczNDA2LC0yLjk3NDU5bC0wLjUyMDI1LC0yLjc4MDY4bDEwLjA1Nzk3LC0zLjQxNjU1bDguNTY3NjksNi44NTg3NGwtNS45NjkyNCw5LjQ0ODYzeiIgZmlsbD0iIzg1ZmZlNyIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTIyNy44ODU1MiwxOTEuMTEyNjRsNC4zOTIxMSwtNy4zMjAxOWw2LjUwNjg0LC0wLjgxMzM2bDEuNjI2NzEsOC45NDY5eiIgZmlsbD0idXJsKCNjb2xvci0zKSIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTIzNS41MDg1LDE4Ni40NzYzNGwzLjM1MDM1LC0zLjIxOTM5bDEuNDg5MzgsOC42NjQ0MnoiIGZpbGw9IiNiNWZmZjEiIHN0cm9rZT0iI2I2NTkxYiIvPjxwYXRoIGQ9Ik0yNDUuODA3MzcsMTc5LjQ5ODY5bDAuNzMwNzcsLTYuMDI4ODRsNS4yMDY3MywtMy43NDUxOWwzLjc0NTE5LDYuMzAyODlsLTMuMjIyMjEsNC43NTIxeiIgZmlsbD0iIzAwZmZjZSIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTI1MS4zNzk0OSwxNzcuNzYzMTJ2LTQuOTMyNjlsNC43NDk5OSwtMi4wMDk2MWMwLDAgMC41MDg0NSwzLjg3MTAxIDEuNzI3NjUsOS40Mjg3YzEuMTE2MjUsNS4wODgzNSA3LjY4MjM5LDcuOTU2MDQgNy42ODIzOSw3Ljk1NjA0bC05Ljg1MjQ1LDguOTAxODRsLTUuOTQ5NzEsLTcuMDI5OTN6IiBmaWxsPSJ1cmwoI2NvbG9yLTQpIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjQ5LjY5Mjk1LDE3Ni43MTk5N2wyLjQ0MDM3LC02Ljg1NzY2bDEuMDAzMTMsMC4wNDM1OGwxLjU1MzE3LDEuNTUyMWwtMC45NDI0LDAuMzUzNTdsLTEuMDAzNDgsLTAuNzgwNjNsLTEuOTYwNDksNS43MzI2MmwwLjUxNzE5LDEuMTMwOTNsMC4yMjEwMSwyLjAwOTIxeiIgZmlsbD0iI2ZmMDA5NCIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTI0OC4yNzQ1NCwxNjcuNjE0MjF2LTAuMDY3NjJoMC4xMzUyNnYwLjA2NzYyeiIgZmlsbD0iI2ZmMDA5NCIgc3Ryb2tlPSJub25lIi8+PHBhdGggZD0iTTIyOC4xMDEyNSwxNzQuNjk3NDdsOC45NDQzMywtNy40Njg0OGwxMC45MzAyMSwyLjc1NzQ0bDEuMDE3NDMsMS45OTI4OWwtMS41MDcyOSwtMS43Mjg3OWwtMTAuMzMwMjIsLTIuNDA1MjlsLTguMTEyMjYsNi42NjE3N2wtMC4zNTc5Miw2LjExMzhsLTAuODg3MiwtMy40MDY5NnoiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0iI2I2NTkxYiIvPjxwYXRoIGQ9Ik0yMjcuODgyNTUsMTkxLjA4NzM5bDMuNjY0NzMsLTUuMzY4NWwzLjc2MTE3LDAuNzcxNTJsNS4wNDcwMyw1LjM2ODV6IiBmaWxsPSIjODVmZmU3IiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjI4LjQ2OTg2LDE5MC4wNjg2MWwzLjU3ODg5LC02LjU2MTA4bDYuNzg3NzcsLTAuNTU2NTJsMS41NjE0OCw5LjAzOTA0bC0yLjAxMTg5LC04LjU3NzY5bC01LjMxOTg1LDAuNTE0MTR6IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjM1LjI5MTYxLDE4Ni40ODc0OWwtMy40ODI4OSwtMC42OTY1OGwzLjYxNTU4LDAuNDMxMjFsMy4xODQzNiwzLjU4MjQxeiIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTI0Ni41NjM1MiwxODEuMTMxNTJsLTguNDQxOTUsLTYuNDk5MThsLTkuODYxMTUsMy4wNjQ1NWw5LjkzMjEyLC0zLjQ0MjEzbDguNzEwOTksNi45MDUzNmwtMy41MjMyNCw1LjYyNTc0eiIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTIzOS41ODU2MSwxODQuNjU0NjFsLTEuNDg5NDIsLTMuOTczMTNsMS43NTU1LC0zLjE3MzE1bDQuOTQxMDYsLTAuMDA1NDVsMy41NzM2NiwzLjA4NDQzbC0xLjgyNDU5LDMuODc3MjR6IiBmaWxsPSIjMzE3YzZkIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjI4LjAxMjMxLDE4My41MzQ2NWwwLjcwNDI1LC0zLjAyOTkxbC0wLjYzNzQxLC0zLjQ3NDc2bDIuNjY5NTEsLTAuMzQyOTdsMS41MjEwMSwzLjE5ODQ2bC0xLjU5NjUxLDMuNDk3MTJ6IiBmaWxsPSIjMzE3YzZkIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjI4LjAyNjc3LDE4My41MTc5bDIuNTM2MTcsLTAuMjM5NmwxLjczNTE1LC0zLjM4NjM0bC0xLjQzMDAzLDMuNTY3OTZ6IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjM5LjU1MDMyLDE4NC42ODkxOGwtMS40NTcwOSwtMy45MjAwMWwxLjYzMTAxLDMuNjY4NzlsNi43MDU2NiwtMC4yMzE5bDEuOTcxMTEsLTMuNTU1NzNsLTEuODM1ODQsMy45MDM1OHoiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0iI2I2NTkxYiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjIyLjc0MTc1NTg5NDI5NjA5OjEyLjc3MTAwODc2MjMzMDE1NS0tPg==">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@300;400;600;700&family=Noto+Sans+JP:wght@400;700&display=swap');

  :root {
    --bg: #0a0a0f; --bg2: #111118; --bg3: #1a1a24;
    --accent: #00ffcc; --accent2: #ff4466; --accent3: #ffcc00;
    --text: #ddeeff; --muted: #556677; --border: #223344;
    --good: #00ff88; --warn: #ffaa00; --bad: #ff4466;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg); color: var(--text);
    font-family: 'Rajdhani', 'Noto Sans JP', sans-serif;
    font-size: 16px; min-height: 100vh; overflow-x: hidden;
  }

  body::before {
    content: ''; position: fixed; inset: 0;
    background: repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.08) 2px,rgba(0,0,0,0.08) 4px);
    pointer-events: none; z-index: 9999;
  }

  h1 { font-family: 'Share Tech Mono', monospace; font-size: 2.2rem; color: var(--accent); letter-spacing: 0.15em; text-shadow: 0 0 20px var(--accent), 0 0 40px rgba(0,255,204,0.3); }
  .subtitle { font-family: 'Share Tech Mono', monospace; font-size: 0.75rem; color: var(--muted); letter-spacing: 0.2em; margin-top: 2px; }

  header { padding: 18px 30px; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 20px; background: linear-gradient(135deg, var(--bg2), var(--bg)); }
  .skull { font-size: 2.5rem; position: relative; z-index: 10000; }

  .app { display: grid; grid-template-columns: 280px 1fr 220px; grid-template-rows: auto 1fr auto; height: calc(100vh - 73px); }

  .sidebar { grid-row: 1 / 3; border-right: 1px solid var(--border); background: var(--bg2); display: flex; flex-direction: column; overflow-y: auto; overflow-x: hidden; }
  .sidebar::-webkit-scrollbar { width: 4px; }
  .sidebar::-webkit-scrollbar-track { background: var(--bg); }
  .sidebar::-webkit-scrollbar-thumb { background: var(--border); }
  .sidebar-section { padding: 16px; border-bottom: 1px solid var(--border); flex-shrink: 0; }
  .sidebar-section h3 { font-family: 'Share Tech Mono', monospace; font-size: 0.7rem; color: var(--muted); letter-spacing: 0.2em; margin-bottom: 10px; text-transform: uppercase; }

  .right-sidebar { grid-column: 3; grid-row: 1 / 3; border-left: 1px solid var(--border); background: var(--bg2); display: flex; flex-direction: column; overflow: hidden; }
  .right-sidebar-header { padding: 10px 16px 6px; font-family: 'Share Tech Mono', monospace; font-size: 0.65rem; color: var(--muted); letter-spacing: 0.15em; flex-shrink: 0; border-bottom: 1px solid var(--border); }
  .right-sidebar .word-list { flex: 1; min-height: 0; }

  .btn { display: inline-flex; align-items: center; gap: 8px; padding: 8px 14px; border: 1px solid var(--border); background: var(--bg3); color: var(--text); font-family: 'Rajdhani', 'Noto Sans JP', sans-serif; font-size: 0.9rem; font-weight: 600; cursor: pointer; transition: all 0.15s; letter-spacing: 0.05em; border-radius: 2px; width: 100%; text-align: left; justify-content: flex-start; }
  .btn:hover { border-color: var(--accent); color: var(--accent); background: rgba(0,255,204,0.05); box-shadow: 0 0 10px rgba(0,255,204,0.1); }
  .btn.primary { border-color: var(--accent); color: var(--accent); background: rgba(0,255,204,0.08); }
  .btn.active-toggle { border-color: var(--good); color: var(--good); background: rgba(0,255,136,0.08); }
  .btn.danger { border-color: var(--accent2); color: var(--accent2); background: rgba(255,68,102,0.06); }
  .btn + .btn { margin-top: 6px; }

  .word-list { flex: 1; overflow-y: auto; padding: 8px; min-height: 0; }
  .word-list::-webkit-scrollbar { width: 4px; }
  .word-list::-webkit-scrollbar-track { background: var(--bg); }
  .word-list::-webkit-scrollbar-thumb { background: var(--border); }

  .word-item { padding: 8px 12px; cursor: pointer; border-left: 2px solid transparent; border-radius: 2px; transition: all 0.1s; display: flex; align-items: center; gap: 10px; font-weight: 600; font-size: 1rem; margin-bottom: 2px; font-family: 'Rajdhani', 'Noto Sans JP', sans-serif; }
  .word-item:hover { background: var(--bg3); border-left-color: var(--muted); }
  .word-item.active { background: rgba(0,255,204,0.08); border-left-color: var(--accent); color: var(--accent); }
  .word-item.done { border-left-color: var(--good); }
  .word-item.done .word-status { color: var(--good); }
  .word-item .word-status { font-size: 0.65rem; margin-left: auto; opacity: 0.7; font-family: 'Share Tech Mono', monospace; }
  /* right sidebar — flip accent border to right side */
  .right-sidebar .word-item { border-left: none; border-right: 2px solid transparent; }
  .right-sidebar .word-item:hover { border-right-color: var(--muted); }
  .right-sidebar .word-item.active { border-right-color: var(--accent); }
  .right-sidebar .word-item.done { border-right-color: var(--good); }

  .main-top { padding: 20px 30px; border-bottom: 1px solid var(--border); background: var(--bg2); display: flex; align-items: center; gap: 20px; flex-wrap: wrap; }
  .tone-control { display: flex; flex-direction: column; gap: 6px; }
  .tone-control label { font-family: 'Share Tech Mono', monospace; font-size: 0.65rem; color: var(--muted); letter-spacing: 0.15em; }
  .tone-row { display: flex; align-items: center; gap: 10px; }

  input[type=range] { -webkit-appearance: none; width: 180px; height: 4px; background: var(--bg3); border: 1px solid var(--border); border-radius: 2px; outline: none; }
  input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: var(--accent); border-radius: 50%; cursor: pointer; box-shadow: 0 0 8px var(--accent); }

  /* ---- PITCH LINE ON SLIDER ---- */
  .slider-pitch-wrap { position: relative; display: inline-flex; align-items: center; }
  .slider-pitch-line {
    position: absolute; top: 50%; transform: translateY(-50%);
    width: 2px; height: 22px; background: var(--accent);
    border-radius: 1px; pointer-events: none;
    box-shadow: 0 0 6px var(--accent), 0 0 12px rgba(0,255,204,0.4);
    opacity: 0; transition: opacity 0.15s, left 0.05s;
    left: 0;
  }
  .slider-pitch-line.visible { opacity: 1; }
  .tone-val { font-family: 'Share Tech Mono', monospace; font-size: 0.9rem; color: var(--accent); min-width: 60px; }

  .preview-btn { padding: 6px 12px; border: 1px solid var(--accent3); background: rgba(255,204,0,0.06); color: var(--accent3); font-family: 'Share Tech Mono', monospace; font-size: 0.75rem; cursor: pointer; border-radius: 2px; transition: all 0.15s; white-space: nowrap; }
  .preview-btn:hover { background: rgba(255,204,0,0.15); }
  .preview-btn.playing { border-color: var(--accent2); color: var(--accent2); animation: pulse 0.5s ease infinite alternate; }

  @keyframes pulse { from { opacity: 1; } to { opacity: 0.5; } }

  .main-content { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 30px; gap: 20px; overflow: hidden; }

  .current-word { font-size: 5rem; font-weight: 700; letter-spacing: 0.05em; color: var(--text); text-align: center; text-shadow: 0 0 30px rgba(221,238,255,0.2); transition: color 0.3s; min-height: 100px; display: flex; align-items: center; font-family: 'Rajdhani', 'Noto Sans JP', sans-serif; }
  .current-word.recording { color: var(--accent2); text-shadow: 0 0 30px rgba(255,68,102,0.4); }
  .current-word.done-word { color: var(--good); }

  #waveCanvas { width: 100%; max-width: 700px; height: 100px; border: 1px solid var(--border); background: var(--bg3); border-radius: 2px; }

  .pitch-section { display: flex; flex-direction: column; align-items: center; gap: 8px; width: 100%; max-width: 700px; }
  .pitch-label { font-family: 'Share Tech Mono', monospace; font-size: 0.7rem; color: var(--muted); letter-spacing: 0.15em; align-self: flex-start; }
  .pitch-meter { width: 100%; height: 28px; background: var(--bg3); border: 1px solid var(--border); border-radius: 2px; position: relative; overflow: hidden; }
  .pitch-fill { height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), var(--accent3)); transition: width 0.08s; position: absolute; left: 0; }
  .pitch-target-line { position: absolute; top: 0; bottom: 0; width: 2px; background: var(--accent2); box-shadow: 0 0 6px var(--accent2); }
  .pitch-info { display: flex; justify-content: space-between; width: 100%; font-family: 'Share Tech Mono', monospace; font-size: 0.75rem; }
  .pitch-current { color: var(--accent3); }
  .pitch-target-label { color: var(--accent2); }
  .pitch-offset.good { color: var(--good); }
  .pitch-offset.warn { color: var(--warn); }
  .pitch-offset.bad { color: var(--bad); }

  .playback-row { display: flex; align-items: center; gap: 12px; width: 100%; max-width: 700px; }
  #playbackCanvas { flex: 1; height: 60px; border: 1px solid var(--border); background: var(--bg3); border-radius: 2px; cursor: pointer; }

  .play-btn { padding: 7px 16px; border: 1px solid var(--accent); background: rgba(0,255,204,0.08); color: var(--accent); font-family: 'Share Tech Mono', monospace; font-size: 0.8rem; cursor: pointer; border-radius: 2px; transition: all 0.15s; white-space: nowrap; flex-shrink: 0; }
  .play-btn:hover { background: rgba(0,255,204,0.18); }
  .play-btn.playing { border-color: var(--accent3); color: var(--accent3); animation: pulse 0.6s ease infinite alternate; }

  .record-hint { display: flex; align-items: center; gap: 12px; padding: 12px 20px; border: 1px solid var(--border); background: var(--bg3); border-radius: 2px; font-family: 'Share Tech Mono', monospace; font-size: 0.8rem; color: var(--muted); }
  .record-hint .key { padding: 4px 10px; border: 1px solid var(--accent); color: var(--accent); border-radius: 2px; font-size: 0.9rem; box-shadow: 0 0 8px rgba(0,255,204,0.2); cursor: pointer; transition: all 0.15s; user-select: none; }
  .record-hint .key:hover { background: rgba(0,255,204,0.1); box-shadow: 0 0 16px rgba(0,255,204,0.4); }
  .record-hint .key.binding { border-color: var(--accent3); color: var(--accent3); box-shadow: 0 0 12px rgba(255,204,0,0.5); animation: pulse 0.4s ease infinite alternate; }

  .recording-indicator { display: flex; align-items: center; gap: 8px; color: var(--accent2); font-size: 0.85rem; animation: pulse 0.6s ease infinite alternate; opacity: 0; transition: opacity 0.2s; font-family: 'Share Tech Mono', monospace; }
  .recording-indicator.active { opacity: 1; }
  .rec-dot {
    width: 10px; height: 10px; background: var(--accent2); border-radius: 50%;
    box-shadow: 0 0 8px var(--accent2);
    outline: 2px solid var(--accent2); outline-offset: 3px;
    cursor: pointer; transition: all 0.15s; flex-shrink: 0;
  }
  .rec-dot:hover { outline-color: #fff; }
  .rec-dot.muted { background: transparent; box-shadow: none; outline-color: var(--muted); }
  .recording-indicator.muted { color: var(--muted); animation: none; }

  .progress-bar-wrap { width: 100%; max-width: 700px; display: flex; align-items: center; gap: 12px; }
  .progress-bar { flex: 1; height: 4px; background: var(--bg3); border-radius: 2px; overflow: hidden; }
  .progress-fill { height: 100%; background: var(--accent); border-radius: 2px; transition: width 0.3s; box-shadow: 0 0 8px var(--accent); }
  .progress-text { font-family: 'Share Tech Mono', monospace; font-size: 0.75rem; color: var(--muted); white-space: nowrap; }

  .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; pointer-events: none; transition: opacity 0.2s; }
  .modal-overlay.show { opacity: 1; pointer-events: all; }
  .modal { background: var(--bg2); border: 1px solid var(--border); border-top: 2px solid var(--accent); padding: 28px; min-width: 420px; max-width: 520px; box-shadow: 0 20px 60px rgba(0,0,0,0.8); }
  .modal h2 { font-family: 'Share Tech Mono', monospace; font-size: 1rem; color: var(--accent); letter-spacing: 0.15em; margin-bottom: 20px; }
  .modal p { font-size: 0.9rem; color: var(--muted); margin-bottom: 16px; line-height: 1.5; }
  .modal-row { display: flex; gap: 10px; margin-top: 16px; }
  .modal-input { flex: 1; padding: 8px 12px; background: var(--bg3); border: 1px solid var(--border); color: var(--text); font-family: 'Share Tech Mono', monospace; font-size: 0.85rem; border-radius: 2px; outline: none; }
  .modal-input:focus { border-color: var(--accent); }
  .modal-btn { padding: 8px 18px; border: 1px solid var(--accent); background: rgba(0,255,204,0.08); color: var(--accent); font-family: 'Rajdhani', sans-serif; font-weight: 700; font-size: 0.9rem; cursor: pointer; border-radius: 2px; letter-spacing: 0.05em; transition: all 0.15s; }
  .modal-btn:hover { background: rgba(0,255,204,0.18); }
  .modal-btn.cancel { border-color: var(--muted); color: var(--muted); background: transparent; }
  .modal-btn.cancel:hover { border-color: var(--text); color: var(--text); }

  .status-bar { padding: 8px 30px; background: var(--bg); border-top: 1px solid var(--border); font-family: 'Share Tech Mono', monospace; font-size: 0.7rem; color: var(--muted); display: flex; gap: 20px; grid-column: 1 / 4; }
  .status-item span { color: var(--accent); margin-left: 4px; }

  .no-reclist { text-align: center; color: var(--muted); font-family: 'Share Tech Mono', monospace; font-size: 0.8rem; line-height: 2; }
  .no-reclist .big { font-size: 3rem; opacity: 0.3; }

  select { padding: 7px 12px; background: var(--bg3); border: 1px solid var(--border); color: var(--text); font-family: 'Rajdhani', sans-serif; font-size: 0.9rem; border-radius: 2px; outline: none; cursor: pointer; }
  select:focus { border-color: var(--accent); }

  .keys-hint { font-family: 'Share Tech Mono', monospace; font-size: 0.65rem; color: var(--muted); text-align: center; }
  .keys-hint .key { display: inline-block; padding: 2px 6px; border: 1px solid var(--muted); border-radius: 2px; margin: 0 3px; color: var(--text); }

  /* ---- MIC PANIC ---- */
  @keyframes micPanic {
    0%   { border-color: var(--bad); color: var(--bad); box-shadow: 0 0 0 rgba(255,68,102,0); transform: translateX(0); }
    10%  { transform: translateX(-4px); }
    20%  { transform: translateX(4px); border-color: var(--accent3); color: var(--accent3); box-shadow: 0 0 18px rgba(255,204,0,0.6); }
    30%  { transform: translateX(-4px); }
    40%  { transform: translateX(4px); border-color: var(--bad); color: var(--bad); box-shadow: 0 0 24px rgba(255,68,102,0.8); }
    50%  { transform: translateX(-3px); }
    60%  { transform: translateX(3px); }
    70%  { transform: translateX(-2px); border-color: var(--accent3); color: var(--accent3); }
    80%  { transform: translateX(2px); }
    90%  { transform: translateX(-1px); border-color: var(--bad); color: var(--bad); }
    100% { transform: translateX(0); box-shadow: 0 0 16px rgba(255,68,102,0.5); }
  }
  @keyframes micPanicLabel {
    0%, 100% { color: var(--bad); }
    50% { color: var(--accent3); }
  }
  .header-mic.panic label { animation: micPanicLabel 0.4s ease infinite; }
  .header-mic.panic select {
    border-color: var(--bad) !important;
    color: var(--bad) !important;
    animation: micPanic 0.5s ease infinite;
  }
  .header-mic.panic::after {
    content: '!! NO SIGNAL — TRY SOMETHING ELSE !!';
    display: block;
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.55rem;
    color: var(--bad);
    letter-spacing: 0.1em;
    animation: micPanicLabel 0.3s ease infinite;
    white-space: nowrap;
  }
  /* mobile panic — shake the settings gear */
  @keyframes gearPanic {
    0%,100% { transform: rotate(0deg); color: var(--muted); border-color: var(--border); }
    15% { transform: rotate(-20deg) scale(1.2); color: var(--bad); border-color: var(--bad); box-shadow: 0 0 12px rgba(255,68,102,0.6); }
    30% { transform: rotate(20deg) scale(1.2); color: var(--accent3); border-color: var(--accent3); box-shadow: 0 0 16px rgba(255,204,0,0.6); }
    45% { transform: rotate(-15deg); color: var(--bad); }
    60% { transform: rotate(15deg); }
    75% { transform: rotate(-8deg); }
    90% { transform: rotate(5deg); }
  }
  .mob-settings-btn.panic { animation: gearPanic 0.6s ease infinite; }
  .header-mic { display: flex; flex-direction: column; gap: 4px; margin-left: auto; }
  .header-mic label { font-family: 'Share Tech Mono', monospace; font-size: 0.6rem; color: var(--muted); letter-spacing: 0.15em; }
  .header-mic select { font-size: 0.8rem; padding: 5px 10px; max-width: 220px; }

  /* ---- MOBILE RECORD BUTTON ---- */
  .mobile-rec-btn {
    display: none;
    width: 140px; height: 140px; border-radius: 50%;
    border: 3px solid var(--accent2);
    background: rgba(255,68,102,0.08);
    color: var(--accent2);
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.85rem; letter-spacing: 0.1em;
    flex-direction: column; align-items: center; justify-content: center; gap: 8px;
    cursor: pointer; transition: all 0.15s;
    box-shadow: 0 0 20px rgba(255,68,102,0.2);
    user-select: none; -webkit-user-select: none;
    touch-action: none;
  }
  .mobile-rec-btn .rec-ring { width: 20px; height: 20px; border-radius: 50%; background: var(--accent2); box-shadow: 0 0 10px var(--accent2); }
  .mobile-rec-btn.recording-active { background: rgba(255,68,102,0.25); box-shadow: 0 0 40px rgba(255,68,102,0.5); transform: scale(1.05); }

  /* ---- MOBILE SETTINGS DRAWER ---- */
  .mob-settings-btn {
    display: none; align-items: center; justify-content: center;
    width: 38px; height: 38px; border: 1px solid var(--border);
    background: var(--bg3); color: var(--muted); border-radius: 2px;
    cursor: pointer; font-size: 1.1rem; transition: all 0.15s; flex-shrink: 0;
  }
  .mob-settings-btn:hover { border-color: var(--accent); color: var(--accent); }
  .mob-settings-drawer {
    display: none; position: fixed; inset: 0; z-index: 500;
  }
  .mob-settings-drawer.open { display: block; }
  .mob-settings-scrim { position: absolute; inset: 0; background: rgba(0,0,0,0.7); }
  .mob-settings-panel {
    position: absolute; top: 0; left: 0; bottom: 0; width: 300px;
    background: var(--bg2); border-right: 1px solid var(--border);
    overflow-y: auto; display: flex; flex-direction: column;
  }
  .mob-settings-panel::-webkit-scrollbar { width: 4px; }
  .mob-settings-panel::-webkit-scrollbar-thumb { background: var(--border); }
  .mob-settings-header {
    padding: 14px 16px; border-bottom: 1px solid var(--border);
    display: flex; align-items: center; justify-content: space-between;
    font-family: 'Share Tech Mono', monospace; font-size: 0.7rem;
    color: var(--accent); letter-spacing: 0.2em;
  }
  .mob-settings-close {
    background: none; border: none; color: var(--muted); font-size: 1.2rem;
    cursor: pointer; padding: 0 4px; line-height: 1;
  }

  /* ---- MOBILE WORD PANEL (bottom) ---- */
  .mob-word-panel {
    display: none; position: fixed; bottom: 0; left: 0; right: 0; z-index: 400;
    background: var(--bg2); border-top: 1px solid var(--border);
    flex-direction: column;
  }
  .mob-word-panel.open { display: flex; }
  .mob-word-tab {
    display: none; position: fixed; bottom: 0; left: 0; right: 0; z-index: 399;
    background: var(--bg2); border-top: 1px solid var(--border);
    padding: 8px 16px; font-family: 'Share Tech Mono', monospace;
    font-size: 0.7rem; color: var(--muted); letter-spacing: 0.15em;
    align-items: center; justify-content: space-between; cursor: pointer;
    transition: color 0.15s;
  }
  .mob-word-tab:hover { color: var(--accent); }
  .mob-word-tab-arrow { transition: transform 0.2s; }
  .mob-word-tab.tab-open .mob-word-tab-arrow { transform: rotate(180deg); }
  .mob-word-list-wrap {
    max-height: 45vh; overflow-y: auto; padding: 6px;
  }
  .mob-word-list-wrap::-webkit-scrollbar { width: 4px; }
  .mob-word-list-wrap::-webkit-scrollbar-thumb { background: var(--border); }

  @media (max-width: 700px) {
    /* hide desktop sidebar and status bar entirely */
    .sidebar { display: none !important; }
    .right-sidebar { display: none !important; }
    .status-bar { display: none !important; }
    .main-top { display: none !important; }
    .header-mic { display: none !important; }

    /* layout */
    .app { grid-template-columns: 1fr; grid-template-rows: 1fr; height: calc(100vh - 64px); }
    .main-content { padding: 16px; gap: 14px; padding-bottom: 60px; }

    /* header */
    h1 { font-size: 1.4rem; }
    .skull svg { width: 48px !important; height: 30px !important; }
    header { padding: 12px 16px; gap: 12px; }

    /* show mobile-only elements */
    .mobile-rec-btn { display: flex; }
    .record-hint { display: none; }
    .mob-settings-btn { display: flex; }
    .mob-word-tab { display: flex; }

    .current-word { font-size: 3.5rem; min-height: 70px; }
    input[type=range] { width: 130px; }

    /* modal fix */
    .modal { min-width: unset; width: calc(100vw - 32px); max-width: 100%; }
  }
</style>
</head>
<body>

<header>
  <div class="skull"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="72" height="44" viewBox="0,0,48.28128,29.87839" style="display:block"><defs><linearGradient x1="228.9336" y1="170.07455" x2="228.9336" y2="213.48515" gradientUnits="userSpaceOnUse" id="color-1"><stop offset="0" stop-color="#00ffce"/><stop offset="1" stop-color="#243834"/></linearGradient><linearGradient x1="240.39449" y1="167.26541" x2="240.39449" y2="190.778" gradientUnits="userSpaceOnUse" id="color-2"><stop offset="0" stop-color="#ffffff"/><stop offset="1" stop-color="#78ffe5"/></linearGradient><linearGradient x1="234.14836" y1="182.97909" x2="234.14836" y2="191.92599" gradientUnits="userSpaceOnUse" id="color-3"><stop offset="0" stop-color="#ffffff"/><stop offset="1" stop-color="#78ffe5"/></linearGradient><linearGradient x1="253.86417" y1="170.82081" x2="253.86417" y2="214.23142" gradientUnits="userSpaceOnUse" id="color-4"><stop offset="0" stop-color="#00ffce"/><stop offset="1" stop-color="#a2ffee"/></linearGradient></defs><g transform="translate(-217.25824,-167.22899)"><g stroke-width="0" stroke-miterlimit="10"><path d="M230.52992,180.03337l-3.22221,-4.75209l3.74519,-6.30289l5.20673,3.74519l0.73077,6.02884z" fill="#00ffce" stroke="#b6591b"/><path d="M233.06041,189.33119l-5.94972,7.02993l-9.85245,-8.90184c0,0 6.56615,-2.86769 7.68239,-7.95604c1.2192,-5.55768 1.72765,-9.4287 1.72765,-9.4287l4.75,2.00962v4.93269z" fill="url(#color-1)" stroke="#b6591b"/><path d="M229.15249,170.87981l-2.1271,3.83491l1.83884,3.48421l-0.53132,0.51045l-2.0859,-4.30722l2.49628,-4.50445l1.64663,0.4393l-0.51939,0.6619z" fill="#ff0094" stroke="#b6591b"/><path d="M227.93691,187.74175l0.1308,-4.15406l0.69348,-3.0498l-0.70542,-3.48989l0.00511,-2.32163l8.91165,-7.46096l10.90813,2.77445l4.97142,10.14057l-1.61143,8.80088l-10.29476,1.79669z" fill="url(#color-2)" stroke="#b6591b"/><path d="M228.56129,177.57882l-0.27107,-2.75623l9.8644,-0.39628z" fill="#ffffff" stroke="#b6591b"/><path d="M241.03081,190.79692l5.68997,-9.64401l4.50054,-4.46839l0.28932,12.28005z" fill="#5ce6cb" stroke="#b6591b"/><path d="M238.40935,174.45012l9.61408,-4.42943l4.01364,7.76118l-5.34769,3.2996z" fill="#b5fff1" stroke="#b6591b"/><path d="M228.04843,187.66056l-0.02202,-4.19028l0.73406,-2.97459l-0.52025,-2.78068l10.05797,-3.41655l8.56769,6.85874l-5.96924,9.44863z" fill="#85ffe7" stroke="#b6591b"/><path d="M227.88552,191.11264l4.39211,-7.32019l6.50684,-0.81336l1.62671,8.9469z" fill="url(#color-3)" stroke="#b6591b"/><path d="M235.5085,186.47634l3.35035,-3.21939l1.48938,8.66442z" fill="#b5fff1" stroke="#b6591b"/><path d="M245.80737,179.49869l0.73077,-6.02884l5.20673,-3.74519l3.74519,6.30289l-3.22221,4.7521z" fill="#00ffce" stroke="#b6591b"/><path d="M251.37949,177.76312v-4.93269l4.74999,-2.00961c0,0 0.50845,3.87101 1.72765,9.4287c1.11625,5.08835 7.68239,7.95604 7.68239,7.95604l-9.85245,8.90184l-5.94971,-7.02993z" fill="url(#color-4)" stroke="#b6591b"/><path d="M249.69295,176.71997l2.44037,-6.85766l1.00313,0.04358l1.55317,1.5521l-0.9424,0.35357l-1.00348,-0.78063l-1.96049,5.73262l0.51719,1.13093l0.22101,2.00921z" fill="#ff0094" stroke="#b6591b"/><path d="M248.27454,167.61421v-0.06762h0.13526v0.06762z" fill="#ff0094" stroke="none"/><path d="M228.10125,174.69747l8.94433,-7.46848l10.93021,2.75744l1.01743,1.99289l-1.50729,-1.72879l-10.33022,-2.40529l-8.11226,6.66177l-0.35792,6.1138l-0.8872,-3.40696z" fill="#ffffff" stroke="#b6591b"/><path d="M227.88255,191.08739l3.66473,-5.3685l3.76117,0.77152l5.04703,5.3685z" fill="#85ffe7" stroke="#b6591b"/><path d="M228.46986,190.06861l3.57889,-6.56108l6.78777,-0.55652l1.56148,9.03904l-2.01189,-8.57769l-5.31985,0.51414z" fill="#ffffff" stroke="#b6591b"/><path d="M235.29161,186.48749l-3.48289,-0.69658l3.61558,0.43121l3.18436,3.58241z" fill="#ffffff" stroke="#b6591b"/><path d="M246.56352,181.13152l-8.44195,-6.49918l-9.86115,3.06455l9.93212,-3.44213l8.71099,6.90536l-3.52324,5.62574z" fill="#ffffff" stroke="#b6591b"/><path d="M239.58561,184.65461l-1.48942,-3.97313l1.7555,-3.17315l4.94106,-0.00545l3.57366,3.08443l-1.82459,3.87724z" fill="#317c6d" stroke="#b6591b"/><path d="M228.01231,183.53465l0.70425,-3.02991l-0.63741,-3.47476l2.66951,-0.34297l1.52101,3.19846l-1.59651,3.49712z" fill="#317c6d" stroke="#b6591b"/><path d="M228.02677,183.5179l2.53617,-0.2396l1.73515,-3.38634l-1.43003,3.56796z" fill="#ffffff" stroke="#b6591b"/><path d="M239.55032,184.68918l-1.45709,-3.92001l1.63101,3.66879l6.70566,-0.2319l1.97111,-3.55573l-1.83584,3.90358z" fill="#ffffff" stroke="#b6591b"/></g></g></svg></div>
  <div>
    <h1>BONEMO</h1>
    <div class="subtitle">// skeleton voice recording studio // v1.2 //</div>
  </div>
  <!-- desktop mic selector -->
  <div class="header-mic">
    <label>MICROPHONE</label>
    <select id="micSelect" onchange="onMicChange()">
      <option value="">default mic</option>
    </select>
  </div>
  <!-- mobile: settings icon -->
  <button class="mob-settings-btn" onclick="openMobSettings()" title="Settings">&#9881;</button>
</header>

<div class="app">
  <div class="sidebar">
    <div class="sidebar-section">
      <h3>Setup</h3>
      <button class="btn primary" onclick="loadReclist()">&#9654; Load reclist.txt</button>
    </div>
    <div class="sidebar-section">
      <h3>Session</h3>
      <button class="btn" onclick="exportAll()">&#8659; Export WAV + oto.ini</button>
      <button class="btn danger" onclick="clearAll()">&#x2715; Clear recordings</button>
    </div>
    <div class="sidebar-section">
      <h3>Display</h3>
      <button class="btn" id="romajiToggleBtn" onclick="toggleRomaji()">Show Romaji: OFF</button>
      <button class="btn" id="autoAdvanceBtn" onclick="toggleAutoAdvance()" style="margin-top:6px">Auto-advance: ON</button>
    </div>
    <div class="sidebar-section">
      <h3>Recording Offset</h3>
      <div class="tone-control" style="width:100%">
        <div class="tone-row" style="gap:8px">
          <input type="range" id="recOffsetSlider" min="-300" max="300" value="0" step="10" oninput="onOffsetChange()" style="width:100%">
        </div>
        <div style="display:flex;justify-content:space-between;margin-top:4px">
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">-300ms</span>
          <span class="tone-val" id="recOffsetVal" style="font-size:0.8rem;min-width:unset">0 ms</span>
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">+300ms</span>
        </div>
        <div style="font-family:'Share Tech Mono',monospace;font-size:0.6rem;color:var(--muted);margin-top:6px;line-height:1.5">negative: trims clip start<br>positive: delays record start</div>
      </div>
    </div>
    <div class="sidebar-section">
      <h3 style="display:flex;align-items:center;justify-content:space-between">
        Silence Trim
        <span style="display:flex;gap:6px;font-size:0.6rem">
          <span id="trimStartBtn" onclick="toggleTrimStart()" title="trim start" style="padding:2px 6px;border:1px solid var(--accent);color:var(--accent);border-radius:2px;cursor:pointer;opacity:1;transition:opacity 0.15s">S</span>
          <span id="trimEndBtn" onclick="toggleTrimEnd()" title="trim end" style="padding:2px 6px;border:1px solid var(--muted);color:var(--muted);border-radius:2px;cursor:pointer;opacity:0.4;transition:opacity 0.15s">E</span>
        </span>
      </h3>
      <div class="tone-control" style="width:100%">
        <div class="tone-row" style="gap:8px">
          <input type="range" id="silenceSlider" min="0" max="0.05" value="0" step="0.001" oninput="onSilenceChange()" style="width:100%">
        </div>
        <div style="display:flex;justify-content:space-between;margin-top:4px">
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">OFF</span>
          <span class="tone-val" id="silenceVal" style="font-size:0.8rem;min-width:unset">off</span>
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">0.050</span>
        </div>
        <div style="font-family:'Share Tech Mono',monospace;font-size:0.6rem;color:var(--muted);margin-top:6px;line-height:1.5">trims silence from start + end<br>raise until noise gets cut cleanly</div>
      </div>
    </div>
  </div>

  <div class="right-sidebar">
    <div class="right-sidebar-header">WORD LIST</div>
    <div class="word-list" id="wordList">
      <div class="no-reclist"><div class="big">&#9900;</div>load a reclist<br>to begin...</div>
    </div>
  </div>

  <div class="main-top">
    <div class="tone-control" style="flex:1">
      <label>TARGET TONE</label>
      <div class="tone-row">
        <div class="slider-pitch-wrap">
          <input type="range" id="toneSlider" min="80" max="800" value="220" oninput="onToneChange()">
          <div class="slider-pitch-line" id="sliderPitchLine"></div>
        </div>
        <span class="tone-val" id="toneVal">220 Hz</span>
        <select id="noteSelect" onchange="onNoteSelect()">
          <option value="82.41">E2 - 82 Hz</option><option value="87.31">F2 - 87 Hz</option>
          <option value="98.00">G2 - 98 Hz</option><option value="110.00">A2 - 110 Hz</option>
          <option value="130.81">C3 - 131 Hz</option><option value="146.83">D3 - 147 Hz</option>
          <option value="164.81">E3 - 165 Hz</option><option value="174.61">F3 - 175 Hz</option>
          <option value="196.00">G3 - 196 Hz</option><option value="220.00" selected>A3 - 220 Hz</option>
          <option value="261.63">C4 - 262 Hz</option><option value="293.66">D4 - 294 Hz</option>
          <option value="329.63">E4 - 330 Hz</option><option value="349.23">F4 - 349 Hz</option>
          <option value="392.00">G4 - 392 Hz</option><option value="440.00">A4 - 440 Hz</option>
          <option value="523.25">C5 - 523 Hz</option>
        </select>
        <button class="preview-btn" id="previewBtn"
          onmousedown="startPreviewTone()" onmouseup="stopPreviewTone()" onmouseleave="stopPreviewTone()"
          ontouchstart="startPreviewTone()" ontouchend="stopPreviewTone()">&#9834; PREVIEW</button>
      </div>
    </div>
  </div>

  <div class="main-content" id="mainContent">
    <div class="no-reclist" style="text-align:center">
      <div class="big">&#9900;</div>
      load a reclist.txt to start recording...<br>
      <span style="font-size:0.75rem">then hold the record key for each word</span>
    </div>
  </div>

  <div class="status-bar">
    <div class="status-item">WORDS: <span id="statusTotal">0</span></div>
    <div class="status-item">DONE: <span id="statusDone">0</span></div>
    <div class="status-item">TARGET: <span id="statusTone">220 Hz</span></div>
  </div>
</div>

<!-- MOBILE SETTINGS DRAWER -->
<div class="mob-settings-drawer" id="mobSettingsDrawer">
  <div class="mob-settings-scrim" onclick="closeMobSettings()"></div>
  <div class="mob-settings-panel">
    <div class="mob-settings-header">
      // SETTINGS //
      <button class="mob-settings-close" onclick="closeMobSettings()">&#x2715;</button>
    </div>
    <div class="sidebar-section">
      <h3>Setup</h3>
      <button class="btn primary" onclick="loadReclist();closeMobSettings()">&#9654; Load reclist.txt</button>
    </div>
    <div class="sidebar-section">
      <h3>Microphone</h3>
      <select id="micSelectMob" onchange="onMicChangeMob()" style="width:100%">
        <option value="">default mic</option>
      </select>
    </div>
    <div class="sidebar-section">
      <h3>Session</h3>
      <button class="btn" onclick="exportAll();closeMobSettings()">&#8659; Export WAV + oto.ini</button>
      <button class="btn danger" onclick="clearAll()">&#x2715; Clear recordings</button>
    </div>
    <div class="sidebar-section">
      <h3>Display</h3>
      <button class="btn" id="romajiToggleBtnMob" onclick="toggleRomaji()">Show Romaji: OFF</button>
      <button class="btn" id="autoAdvanceBtnMob" onclick="toggleAutoAdvance()" style="margin-top:6px">Auto-advance: ON</button>
    </div>
    <div class="sidebar-section">
      <h3>Target Tone</h3>
      <div class="tone-control" style="width:100%">
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
          <select id="noteSelectMob" onchange="onNoteSelectMob()" style="flex:1">
            <option value="82.41">E2 - 82 Hz</option><option value="87.31">F2 - 87 Hz</option>
            <option value="98.00">G2 - 98 Hz</option><option value="110.00">A2 - 110 Hz</option>
            <option value="130.81">C3 - 131 Hz</option><option value="146.83">D3 - 147 Hz</option>
            <option value="164.81">E3 - 165 Hz</option><option value="174.61">F3 - 175 Hz</option>
            <option value="196.00">G3 - 196 Hz</option><option value="220.00" selected>A3 - 220 Hz</option>
            <option value="261.63">C4 - 262 Hz</option><option value="293.66">D4 - 294 Hz</option>
            <option value="329.63">E4 - 330 Hz</option><option value="349.23">F4 - 349 Hz</option>
            <option value="392.00">G4 - 392 Hz</option><option value="440.00">A4 - 440 Hz</option>
            <option value="523.25">C5 - 523 Hz</option>
          </select>
          <button class="preview-btn"
            onmousedown="startPreviewTone()" onmouseup="stopPreviewTone()" onmouseleave="stopPreviewTone()"
            ontouchstart="startPreviewTone()" ontouchend="stopPreviewTone()">&#9834;</button>
        </div>
        <input type="range" id="toneSliderMob" min="80" max="800" value="220" oninput="onToneChangeMob()" style="width:100%">
        <div style="text-align:center;font-family:'Share Tech Mono',monospace;font-size:0.8rem;color:var(--accent);margin-top:4px" id="toneValMob">220 Hz</div>
      </div>
    </div>
    <div class="sidebar-section">
      <h3>Recording Offset</h3>
      <div class="tone-control" style="width:100%">
        <input type="range" id="recOffsetSliderMob" min="-300" max="300" value="0" step="10" oninput="onOffsetChangeMob()" style="width:100%">
        <div style="display:flex;justify-content:space-between;margin-top:4px">
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">-300ms</span>
          <span class="tone-val" id="recOffsetValMob" style="font-size:0.8rem;min-width:unset">0 ms</span>
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">+300ms</span>
        </div>
      </div>
    </div>
    <div class="sidebar-section">
      <h3 style="display:flex;align-items:center;justify-content:space-between">
        Silence Trim
        <span style="display:flex;gap:6px;font-size:0.6rem">
          <span id="trimStartBtnMob" onclick="toggleTrimStart()" title="trim start" style="padding:2px 6px;border:1px solid var(--accent);color:var(--accent);border-radius:2px;cursor:pointer;opacity:1;transition:opacity 0.15s">S</span>
          <span id="trimEndBtnMob" onclick="toggleTrimEnd()" title="trim end" style="padding:2px 6px;border:1px solid var(--muted);color:var(--muted);border-radius:2px;cursor:pointer;opacity:0.4;transition:opacity 0.15s">E</span>
        </span>
      </h3>
      <div class="tone-control" style="width:100%">
        <input type="range" id="silenceSliderMob" min="0" max="0.05" value="0" step="0.001" oninput="onSilenceChangeMob()" style="width:100%">
        <div style="text-align:center;font-family:'Share Tech Mono',monospace;font-size:0.8rem;color:var(--accent);margin-top:4px" id="silenceValMob">off</div>
      </div>
    </div>
  </div>
</div>

<!-- MOBILE WORD LIST TAB (bottom) -->
<div class="mob-word-tab" id="mobWordTab" onclick="toggleMobWordList()">
  <span>WORD LIST &nbsp;<span id="mobWordProgress">0 / 0</span></span>
  <span class="mob-word-tab-arrow">&#9650;</span>
</div>
<div class="mob-word-panel" id="mobWordPanel">
  <div class="mob-word-tab" style="position:relative;border-bottom:1px solid var(--border);border-top:none" onclick="toggleMobWordList()">
    <span>WORD LIST &nbsp;<span id="mobWordProgress2">0 / 0</span></span>
    <span class="mob-word-tab-arrow tab-open">&#9650;</span>
  </div>
  <div class="mob-word-list-wrap" id="mobWordList"></div>
</div>
<div class="modal-overlay" id="reclistModal">
  <div class="modal">
    <h2>// LOAD RECLIST //</h2>
    <p>load a reclist.txt — one entry per line, or space-separated. japanese (UTF-8) works fine.</p>
    <input type="file" id="reclistFile" accept=".txt,.reclist" style="display:none" onchange="readReclistFile(event)">
    <button class="modal-btn" onclick="document.getElementById('reclistFile').click()">browse file</button>
    <textarea id="reclistText" class="modal-input" style="width:100%;height:140px;margin-top:12px;resize:vertical;font-size:0.9rem" placeholder="あ い う え お&#10;か き く け こ&#10;or&#10;a&#10;i&#10;u&#10;..."></textarea>
    <div class="modal-row">
      <button class="modal-btn cancel" onclick="closeModal('reclistModal')">cancel</button>
      <button class="modal-btn" onclick="confirmReclist()">load</button>
    </div>
  </div>
</div>

<!-- EXPORT MODAL -->
<div class="modal-overlay" id="exportModal">
  <div class="modal">
    <h2>// EXPORT COMPLETE //</h2>
    <p id="exportMsg">your recordings are packaged and ready.</p>
    <div style="margin-bottom:12px">
      <label style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted);letter-spacing:0.15em;display:block;margin-bottom:6px">VOICEBANK NAME</label>
      <input type="text" id="vbNameInput" class="modal-input" placeholder="MyVoicebank" value="MyVoicebank" style="width:100%">
      <div style="font-family:'Share Tech Mono',monospace;font-size:0.6rem;color:var(--muted);margin-top:6px">used for character.txt, character.yaml, and zip folder name</div>
    </div>
    <div id="exportProgressMsg" style="font-family:'Share Tech Mono',monospace;font-size:0.75rem;color:var(--accent3);margin-bottom:10px;display:none">generating .frq files...</div>
    <div class="modal-row">
      <button class="modal-btn" id="downloadZipBtn">download .zip</button>
      <button class="modal-btn cancel" onclick="closeModal('exportModal')">close</button>
    </div>
  </div>
</div>

<script>
// ---- STATE ----
let words = [], currentIdx = 0;
let recordingBlobs = {}, decodedBuffers = {};
let targetFreq = 220;
let audioCtx = null, mediaStream = null, mediaRecorder = null;
let isRecording = false, recordedChunks = [];
let alwaysOnSource = null, analyserNode = null;
let waveAnimId = null, pitchAnimId = null;
let previewOscillator = null, saveFolderHandle = null;
let recordKeyDown = false, currentPlaybackSource = null, isPlaying = false;
let pendingRecordTimeout = null;

let showRomaji = false;
let autoAdvance = true;
let recOffset = 0;
let silenceThreshold = 0;
let trimStart = true;
let trimEnd = false;
let recordKey = 'r'; // lowercase canonical key
let recordKeyLabel = 'R'; // display label
let bindingMode = false;
let micMuted = false;

function toggleMicMute() {
  micMuted = !micMuted;
  if (mediaStream) {
    mediaStream.getAudioTracks().forEach(t => t.enabled = !micMuted);
  }
  const dot = document.querySelector('.rec-dot');
  const ind = document.getElementById('recIndicator');
  if (dot) { dot.classList.toggle('muted', micMuted); dot.title = micMuted ? 'unmute mic' : 'mute mic'; }
  if (ind) { ind.classList.toggle('muted', micMuted); }
}

// ---- ROMAJI MAP ----
const romajiMap = {
  'あ':'a','い':'i','う':'u','え':'e','お':'o',
  'か':'ka','き':'ki','く':'ku','け':'ke','こ':'ko',
  'さ':'sa','し':'shi','す':'su','せ':'se','そ':'so',
  'た':'ta','ち':'chi','つ':'tsu','て':'te','と':'to',
  'な':'na','に':'ni','ぬ':'nu','ね':'ne','の':'no',
  'は':'ha','ひ':'hi','ふ':'fu','へ':'he','ほ':'ho',
  'ま':'ma','み':'mi','む':'mu','め':'me','も':'mo',
  'や':'ya','ゆ':'yu','よ':'yo',
  'ら':'ra','り':'ri','る':'ru','れ':'re','ろ':'ro',
  'わ':'wa','を':'wo','ん':'n',
  'が':'ga','ぎ':'gi','ぐ':'gu','げ':'ge','ご':'go',
  'ざ':'za','じ':'ji','ず':'zu','ぜ':'ze','ぞ':'zo',
  'だ':'da','ぢ':'di','づ':'du','で':'de','ど':'do',
  'ば':'ba','び':'bi','ぶ':'bu','べ':'be','ぼ':'bo',
  'ぱ':'pa','ぴ':'pi','ぷ':'pu','ぺ':'pe','ぽ':'po'
};
function toRomaji(text) { return text.split('').map(c => romajiMap[c] || c).join(''); }

// replaces underscores with spaces for display/export. ga_wi_sa → ga wi sa
function displayName(w) { return w.replace(/_/g, ' '); }
// true if this entry is a multi-part sequence
function isSequence(w) { return w.includes('_'); }

// ---- AUDIO CTX ----
function getAudioCtx() { if (!audioCtx) audioCtx = new AudioContext(); return audioCtx; }

// ---- MIC PANIC ----
let micPanicTimeout = null;
let silenceCheckInterval = null;

function triggerMicPanic() {
  document.getElementById('micSelect')?.closest('.header-mic')?.classList.add('panic');
  document.querySelector('.mob-settings-btn')?.classList.add('panic');
}
function clearMicPanic() {
  document.getElementById('micSelect')?.closest('.header-mic')?.classList.remove('panic');
  document.querySelector('.mob-settings-btn')?.classList.remove('panic');
  if (micPanicTimeout) { clearTimeout(micPanicTimeout); micPanicTimeout = null; }
}

function startSilenceWatch() {
  if (silenceCheckInterval) return;
  let silentStreak = 0;
  silenceCheckInterval = setInterval(() => {
    if (!analyserNode) return;
    const buf = new Float32Array(analyserNode.fftSize);
    analyserNode.getFloatTimeDomainData(buf);
    let rms = 0;
    for (let i = 0; i < buf.length; i++) rms += buf[i] * buf[i];
    rms = Math.sqrt(rms / buf.length);
    if (rms < 0.0005) {
      silentStreak++;
      // 10 seconds of complete dead silence = something's actually wrong
      if (silentStreak >= 20) { triggerMicPanic(); }
    } else {
      silentStreak = 0;
      clearMicPanic();
    }
  }, 500);
}
function stopSilenceWatch() {
  if (silenceCheckInterval) { clearInterval(silenceCheckInterval); silenceCheckInterval = null; }
}

// ---- ALWAYS-ON MIC ----
// Call once after mic permission is granted. Keeps analyser alive permanently.
async function initAlwaysOnMic() {
  if (alwaysOnSource) return; // already init'd
  try {
    const ctx = getAudioCtx();
    const constraints = { audio: selectedDeviceId ? { deviceId: { exact: selectedDeviceId } } : true, video: false };
    if (!mediaStream) mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
    alwaysOnSource = ctx.createMediaStreamSource(mediaStream);
    analyserNode = ctx.createAnalyser(); analyserNode.fftSize = 2048;
    alwaysOnSource.connect(analyserNode);
    clearMicPanic();
    // populate mic list once we have permission
    populateMicList();
    // start live waveform + pitch if main UI is up
    if (words.length) { startWaveAndPitch(); startSilenceWatch(); }
  } catch(e) {
    console.warn('mic init failed:', e.message);
    triggerMicPanic();
  }
}

// ---- TOGGLES ----
function toggleRomaji() {
  showRomaji = !showRomaji;
  const btn = document.getElementById('romajiToggleBtn');
  if (btn) {
    btn.textContent = `Show Romaji: ${showRomaji ? 'ON' : 'OFF'}`;
    btn.className = showRomaji ? 'btn active-toggle' : 'btn';
  }
  renderWordList(); renderMain();
}

function toggleAutoAdvance() {
  autoAdvance = !autoAdvance;
  const btn = document.getElementById('autoAdvanceBtn');
  if (btn) {
    btn.textContent = `Auto-advance: ${autoAdvance ? 'ON' : 'OFF'}`;
    btn.className = autoAdvance ? 'btn active-toggle' : 'btn';
  }
}

// ---- OFFSET ----
function onOffsetChange() {
  recOffset = parseInt(document.getElementById('recOffsetSlider').value);
  const el = document.getElementById('recOffsetVal');
  if (el) el.textContent = (recOffset > 0 ? '+' : '') + recOffset + ' ms';
}

function toggleTrimStart() {
  trimStart = !trimStart;
  const btn = document.getElementById('trimStartBtn');
  const btnM = document.getElementById('trimStartBtnMob');
  [btn, btnM].forEach(b => { if (!b) return; b.style.borderColor = trimStart ? 'var(--accent)' : 'var(--muted)'; b.style.color = trimStart ? 'var(--accent)' : 'var(--muted)'; b.style.opacity = trimStart ? '1' : '0.4'; });
}
function toggleTrimEnd() {
  trimEnd = !trimEnd;
  const btn = document.getElementById('trimEndBtn');
  const btnM = document.getElementById('trimEndBtnMob');
  [btn, btnM].forEach(b => { if (!b) return; b.style.borderColor = trimEnd ? 'var(--accent)' : 'var(--muted)'; b.style.color = trimEnd ? 'var(--accent)' : 'var(--muted)'; b.style.opacity = trimEnd ? '1' : '0.4'; });
}

function onSilenceChange() {
  silenceThreshold = parseFloat(document.getElementById('silenceSlider').value);
  const el = document.getElementById('silenceVal');
  if (el) el.textContent = silenceThreshold === 0 ? 'off' : silenceThreshold.toFixed(3);
}

// Trim samples below threshold from both ends of an AudioBuffer.
// Uses a small look-ahead window so a single loud spike doesn't prematurely stop trimming.
function trimSilence(buffer, threshold) {
  if (threshold === 0 || (!trimStart && !trimEnd)) return buffer;
  const ctx = getAudioCtx();
  const sr = buffer.sampleRate, len = buffer.length, nc = buffer.numberOfChannels;
  const WINDOW = Math.floor(sr * 0.005);

  const mono = new Float32Array(len);
  for (let ch = 0; ch < nc; ch++) {
    const data = buffer.getChannelData(ch);
    for (let i = 0; i < len; i++) mono[i] += Math.abs(data[i]);
  }
  for (let i = 0; i < len; i++) mono[i] /= nc;

  let start = 0;
  if (trimStart) {
    for (let i = 0; i < len - WINDOW; i++) {
      let loud = false;
      for (let j = i; j < i + WINDOW; j++) { if (mono[j] > threshold) { loud = true; break; } }
      if (loud) { start = i; break; }
    }
  }

  let end = len;
  if (trimEnd) {
    for (let i = len - 1; i >= WINDOW; i--) {
      let loud = false;
      for (let j = i; j > i - WINDOW; j--) { if (mono[j] > threshold) { loud = true; break; } }
      if (loud) { end = i + 1; break; }
    }
  }

  if (end <= start) return buffer;
  const trimmed = ctx.createBuffer(nc, end - start, sr);
  for (let ch = 0; ch < nc; ch++)
    trimmed.copyToChannel(buffer.getChannelData(ch).slice(start, end), ch);
  return trimmed;
}

// ---- DOWNLOAD CURRENT ----
function downloadCurrent() {
  const w = words[currentIdx];
  const blob = recordingBlobs[w]; if (!blob) return;
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = displayName(w) + '.wav'; a.click();
  setTimeout(() => URL.revokeObjectURL(url), 2000);
}

// ---- KEYBIND ----
function startBindingMode() {
  if (bindingMode) return;
  bindingMode = true;
  const keyEl = document.getElementById('recKeyDisplay');
  if (keyEl) { keyEl.textContent = '...'; keyEl.classList.add('binding'); }
}

function finishBinding(e) {
  if (!bindingMode) return;
  // ignore modifiers alone
  if (['Control','Shift','Alt','Meta','CapsLock','Tab','Escape'].includes(e.key)) return;
  bindingMode = false;
  recordKey = e.key.toLowerCase();
  recordKeyLabel = e.key.length === 1 ? e.key.toUpperCase() : e.key;
  const keyEl = document.getElementById('recKeyDisplay');
  if (keyEl) { keyEl.textContent = recordKeyLabel; keyEl.classList.remove('binding'); }
  e.preventDefault(); e.stopPropagation();
}

// ---- WORD LIST ----
function renderWordList() {
  const el = document.getElementById('wordList'); if (!el) return;
  if (!words.length) { el.innerHTML = '<div class="no-reclist"><div class="big">&#9900;</div>load a reclist.txt<br>to begin...</div>'; return; }
  el.innerHTML = words.map((w, i) => {
    const active = i === currentIdx, done = !!recordingBlobs[w];
    const dn = displayName(w);
    const seq = isSequence(w) ? `<span style="font-size:0.55rem;opacity:0.5;font-family:'Share Tech Mono',monospace;margin-left:4px;border:1px solid var(--muted);padding:1px 4px;border-radius:2px">SEQ</span>` : '';
    const displayWord = showRomaji ? `${dn} <span style="font-size:0.75em;opacity:0.6">(${toRomaji(dn)})</span>${seq}` : `${dn}${seq}`;
    return `<div class="word-item ${active?'active':''} ${done?'done':''}" onclick="selectWord(${i})"><span>${displayWord}</span><span class="word-status">${done?'REC':''}</span></div>`;
  }).join('');
  setTimeout(() => { const a = el.querySelector('.active'); if (a) a.scrollIntoView({ block: 'nearest' }); }, 0);
  if (mobWordOpen) renderMobWordList();
}

// ---- MAIN UI ----
function renderMain() {
  if (!words.length) {
    document.getElementById('mainContent').innerHTML = `<div class="no-reclist" style="text-align:center"><div class="big">&#9900;</div>load a reclist.txt to start...<br><span style="font-size:0.75rem">hold the record key for each word</span></div>`;
    return;
  }
  const w = words[currentIdx], done = !!recordingBlobs[w];
  const pct = (Object.keys(recordingBlobs).length / words.length * 100).toFixed(0);
  const dn = displayName(w);
  const centerLabel = isSequence(w)
    ? w.split('_').join('<span style="opacity:0.25;font-size:0.6em;margin:0 4px">·</span>')
    : w;
  const displayWord = showRomaji
    ? `${centerLabel}<div style="font-size:1.8rem;opacity:0.5;font-family:'Share Tech Mono',monospace;letter-spacing:0.1em">(${toRomaji(dn)})</div>`
    : centerLabel;

  document.getElementById('mainContent').innerHTML = `
    <div class="current-word ${done?'done-word':''}" id="currentWordEl" style="flex-direction:column;gap:4px">${displayWord}</div>
    <canvas id="waveCanvas"></canvas>
    <div class="pitch-section">
      <div class="pitch-label">PITCH METER</div>
      <div class="pitch-meter">
        <div class="pitch-fill" id="pitchFill"></div>
        <div class="pitch-target-line" id="pitchTarget"></div>
      </div>
      <div class="pitch-info">
        <span class="pitch-current" id="pitchCurrent">-- Hz</span>
        <span class="pitch-target-label">target: ${targetFreq.toFixed(0)} Hz</span>
        <span class="pitch-offset" id="pitchOffset">--</span>
      </div>
    </div>
    ${done ? `<div class="playback-row">
      <button class="play-btn" id="playBtn" onclick="togglePlayback()">&#9654; LISTEN</button>
      <button class="play-btn" id="dlBtn" onclick="downloadCurrent()" style="border-color:var(--accent3);color:var(--accent3);background:rgba(255,204,0,0.06)">&#8659; DL</button>
      <canvas id="playbackCanvas" onclick="togglePlayback()"></canvas>
    </div>` : ''}
    <div style="display:flex;align-items:center;gap:20px;flex-wrap:wrap;justify-content:center">
      <div class="record-hint">
        <span class="key" id="recKeyDisplay" onclick="startBindingMode()" title="click to remap">${recordKeyLabel}</span>
        <span>${done ? 'hold to re-record' : 'hold to record'}</span>
      </div>
      <button class="mobile-rec-btn" id="mobileRecBtn">
        <div class="rec-ring"></div>
        HOLD
      </button>
      <div class="recording-indicator${micMuted?' muted':''}" id="recIndicator"><div class="rec-dot${micMuted?' muted':''}" onclick="toggleMicMute()" title="${micMuted?'unmute mic':'mute mic'}"></div>REC</div>
    </div>
    <div class="progress-bar-wrap">
      <div class="progress-bar"><div class="progress-fill" style="width:${pct}%"></div></div>
      <div class="progress-text">${Object.keys(recordingBlobs).length} / ${words.length}</div>
    </div>
    <div class="keys-hint">
      <span class="key">&#8592;</span><span class="key">&#8594;</span> navigate &nbsp;
      <span class="key">SPACE</span> listen &nbsp;
      <span class="key" style="border-color:var(--accent);color:var(--accent)">${recordKeyLabel}</span> record
      &nbsp;<span style="opacity:0.5">(click key to remap)</span>
    </div>
  `;

  updatePitchTargetLine();
  if (done && decodedBuffers[w]) setTimeout(() => drawPlaybackWaveform(decodedBuffers[w]), 50);

  // always-on: restart wave/pitch display after re-render
  if (analyserNode) { cancelAnimationFrame(waveAnimId); cancelAnimationFrame(pitchAnimId); startWaveAndPitch(); }

  // mobile button touch events
  const mBtn = document.getElementById('mobileRecBtn');
  if (mBtn) {
    mBtn.addEventListener('touchstart', e => { e.preventDefault(); mBtn.classList.add('recording-active'); if (words.length) startRecording(); }, { passive: false });
    mBtn.addEventListener('touchend',   e => { e.preventDefault(); mBtn.classList.remove('recording-active'); if (isRecording) stopRecording(); }, { passive: false });
    mBtn.addEventListener('touchcancel',e => { e.preventDefault(); mBtn.classList.remove('recording-active'); if (isRecording) stopRecording(); }, { passive: false });
    // also support mouse for desktop testing
    mBtn.addEventListener('mousedown', e => { e.preventDefault(); if (words.length) startRecording(); });
    mBtn.addEventListener('mouseup',   e => { e.preventDefault(); if (isRecording) stopRecording(); });
  }
}

function updatePitchTargetLine() {
  const el = document.getElementById('pitchTarget'); if (!el) return;
  const pct = Math.max(0, Math.min(100, ((targetFreq - 50) / (1000 - 50)) * 100));
  el.style.left = pct + '%';
}

function selectWord(i) { stopPlayback(); currentIdx = i; renderWordList(); renderMain(); }

// ---- TONE ----
function snapNoteSelect(freq) {
  const sel = document.getElementById('noteSelect');
  const selMob = document.getElementById('noteSelectMob');
  if (!sel) return;
  let closest = null, minDiff = Infinity;
  for (const opt of sel.options) {
    const diff = Math.abs(parseFloat(opt.value) - freq);
    if (diff < minDiff) { minDiff = diff; closest = opt.value; }
  }
  if (closest) { sel.value = closest; if (selMob) selMob.value = closest; }
}
function onToneChange() {
  targetFreq = parseFloat(document.getElementById('toneSlider').value);
  document.getElementById('toneVal').textContent = targetFreq.toFixed(0) + ' Hz';
  document.getElementById('statusTone').textContent = targetFreq.toFixed(0) + ' Hz';
  snapNoteSelect(targetFreq);
  const mob = document.getElementById('toneSliderMob'); if (mob) mob.value = targetFreq;
  const mobVal = document.getElementById('toneValMob'); if (mobVal) mobVal.textContent = targetFreq.toFixed(0) + ' Hz';
  updatePitchTargetLine();
}
function onNoteSelect() {
  const val = parseFloat(document.getElementById('noteSelect').value);
  document.getElementById('toneSlider').value = val; targetFreq = val;
  document.getElementById('toneVal').textContent = val.toFixed(0) + ' Hz';
  document.getElementById('statusTone').textContent = val.toFixed(0) + ' Hz';
  const mob = document.getElementById('toneSliderMob'); if (mob) mob.value = val;
  const mobVal = document.getElementById('toneValMob'); if (mobVal) mobVal.textContent = val.toFixed(0) + ' Hz';
  const selMob = document.getElementById('noteSelectMob'); if (selMob) selMob.value = val;
  updatePitchTargetLine();
}
function startPreviewTone() {
  if (previewOscillator) return; // already playing
  const ctx = getAudioCtx(), btn = document.getElementById('previewBtn');
  previewOscillator = ctx.createOscillator();
  const g = ctx.createGain();
  previewOscillator.frequency.value = targetFreq;
  previewOscillator.type = 'sine';
  g.gain.value = 0.2;
  previewOscillator.connect(g); g.connect(ctx.destination);
  previewOscillator.start();
  if (btn) { btn.classList.add('playing'); btn.textContent = '■ HOLD'; }
}
function stopPreviewTone() {
  if (!previewOscillator) return;
  try { previewOscillator.stop(); } catch(e) {}
  previewOscillator = null;
  const btn = document.getElementById('previewBtn');
  if (btn) { btn.classList.remove('playing'); btn.textContent = '♪ PREVIEW'; }
}

// ---- RECLIST ----
function loadReclist() { openModal('reclistModal'); }
function readReclistFile(e) {
  const file = e.target.files[0]; if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    const buffer = ev.target.result;
    let decoder = new TextDecoder('utf-8');
    let text = decoder.decode(buffer);
    if (text.includes('\uFFFD')) { decoder = new TextDecoder('shift-jis'); text = decoder.decode(buffer); }
    document.getElementById('reclistText').value = text;
  };
  reader.readAsArrayBuffer(file);
}
function confirmReclist() {
  const text = document.getElementById('reclistText').value.trim(); if (!text) return;
  words = [];
  for (const line of text.split('\n')) {
    const tokens = line.trim().split(/\s+/).filter(t => t.length > 0);
    words.push(...tokens);
  }
  recordingBlobs = {}; decodedBuffers = {}; currentIdx = 0;
  closeModal('reclistModal');
  renderWordList(); renderMain(); updateStatus();
  // init always-on mic as soon as we have a reclist
  initAlwaysOnMic().then(() => { if (analyserNode) startSilenceWatch(); });
}

// ---- PLAYBACK ----
function togglePlayback() {
  if (isPlaying) { stopPlayback(); return; }
  const w = words[currentIdx], buf = decodedBuffers[w]; if (!buf) return;
  const ctx = getAudioCtx();
  currentPlaybackSource = ctx.createBufferSource();
  currentPlaybackSource.buffer = buf;
  currentPlaybackSource.connect(ctx.destination);
  currentPlaybackSource.start();
  isPlaying = true;
  const btn = document.getElementById('playBtn');
  if (btn) { btn.textContent = '■ STOP'; btn.classList.add('playing'); }
  currentPlaybackSource.onended = () => {
    isPlaying = false; currentPlaybackSource = null;
    const b = document.getElementById('playBtn');
    if (b) { b.textContent = '▶ LISTEN'; b.classList.remove('playing'); }
  };
}
function stopPlayback() {
  if (currentPlaybackSource) { try { currentPlaybackSource.stop(); } catch(e) {} currentPlaybackSource = null; }
  isPlaying = false;
  const btn = document.getElementById('playBtn');
  if (btn) { btn.textContent = '▶ LISTEN'; btn.classList.remove('playing'); }
}

function drawPlaybackWaveform(buffer) {
  const canvas = document.getElementById('playbackCanvas'); if (!canvas) return;
  canvas.width = canvas.offsetWidth || 500; canvas.height = 60;
  const ctx2d = canvas.getContext('2d'), data = buffer.getChannelData(0);
  const step = Math.ceil(data.length / canvas.width);
  ctx2d.fillStyle = '#1a1a24'; ctx2d.fillRect(0, 0, canvas.width, canvas.height);
  ctx2d.strokeStyle = '#00ffcc'; ctx2d.lineWidth = 1; ctx2d.shadowBlur = 4; ctx2d.shadowColor = '#00ffcc';
  ctx2d.beginPath();
  for (let i = 0; i < canvas.width; i++) {
    let min = 1, max = -1;
    for (let j = 0; j < step; j++) { const d = data[i*step+j]||0; if(d<min)min=d; if(d>max)max=d; }
    ctx2d.moveTo(i, ((1+min)/2)*canvas.height);
    ctx2d.lineTo(i, ((1+max)/2)*canvas.height);
  }
  ctx2d.stroke();
}

// ---- RECORDING ----
async function startRecording() {
  if (!words.length || isRecording) return;
  stopPlayback();

  // ensure mic is up (first press might need permission)
  if (!mediaStream) await initAlwaysOnMic();
  if (!mediaStream) return; // permission denied

  isRecording = true;

  const doStart = () => {
    pendingRecordTimeout = null;
    if (!isRecording) return;
    recordedChunks = [];
    // analyserNode is always alive — just hook recorder to the existing stream
    mediaRecorder = new MediaRecorder(mediaStream);
    mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
    mediaRecorder.onstop = processRecording;
    mediaRecorder.start();
    document.getElementById('currentWordEl')?.classList.add('recording');
    const ind = document.getElementById('recIndicator');
    if (ind) { ind.classList.add('active'); ind.style.opacity = ''; }
  };

  if (recOffset > 0) {
    const ind = document.getElementById('recIndicator');
    if (ind) { ind.classList.add('active'); ind.style.opacity = '0.35'; }
    pendingRecordTimeout = setTimeout(doStart, recOffset);
  } else {
    doStart();
  }
}

function stopRecording() {
  if (!isRecording) return;
  isRecording = false;

  if (pendingRecordTimeout !== null) {
    clearTimeout(pendingRecordTimeout);
    pendingRecordTimeout = null;
    const ind = document.getElementById('recIndicator');
    if (ind) { ind.classList.remove('active'); ind.style.opacity = ''; }
    return;
  }

  if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
  const ind = document.getElementById('recIndicator');
  if (ind) { ind.classList.remove('active'); ind.style.opacity = ''; }
  document.getElementById('currentWordEl')?.classList.remove('recording');
}

function processRecording() {
  const blob = new Blob(recordedChunks, { type: 'audio/webm' }), w = words[currentIdx];
  const reader = new FileReader();
  reader.onload = async ev => {
    const ctx = getAudioCtx();
    try {
      let decoded = await ctx.decodeAudioData(ev.target.result.slice(0));
      if (recOffset < 0) {
        const trimSamples = Math.floor(Math.abs(recOffset) / 1000 * decoded.sampleRate);
        const keepSamples = Math.max(0, decoded.length - trimSamples);
        if (keepSamples > 0) {
          const trimmed = ctx.createBuffer(decoded.numberOfChannels, keepSamples, decoded.sampleRate);
          for (let ch = 0; ch < decoded.numberOfChannels; ch++)
            trimmed.copyToChannel(decoded.getChannelData(ch).slice(trimSamples), ch);
          decoded = trimmed;
        }
      }
      // silence trim (both ends)
      decoded = trimSilence(decoded, silenceThreshold);
      decodedBuffers[w] = decoded;
      recordingBlobs[w] = audioBufferToWavBlob(decoded);
    } catch(e) { recordingBlobs[w] = blob; }

    renderWordList(); updateStatus();

    if (autoAdvance && currentIdx < words.length - 1) {
      currentIdx++;
    }
    renderMain();
  };
  reader.readAsArrayBuffer(blob);
}

// ---- WAVEFORM ----
function startWaveAndPitch() { drawWave(); detectPitch(); }
function drawWave() {
  const canvas = document.getElementById('waveCanvas'); if (!canvas || !analyserNode) return;
  const ctx2d = canvas.getContext('2d');
  canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight;
  const bufLen = analyserNode.frequencyBinCount, dataArr = new Uint8Array(bufLen);
  function draw() {
    if (!analyserNode || !document.getElementById('waveCanvas')) { cancelAnimationFrame(waveAnimId); return; }
    waveAnimId = requestAnimationFrame(draw);
    analyserNode.getByteTimeDomainData(dataArr);
    ctx2d.fillStyle = '#1a1a24'; ctx2d.fillRect(0, 0, canvas.width, canvas.height);
    ctx2d.lineWidth = 1.5; ctx2d.strokeStyle = '#00ffcc'; ctx2d.shadowBlur = 6; ctx2d.shadowColor = '#00ffcc';
    ctx2d.beginPath();
    const sliceW = canvas.width / bufLen; let x = 0;
    for (let i = 0; i < bufLen; i++) {
      const y = (dataArr[i] / 128.0 * canvas.height) / 2;
      i === 0 ? ctx2d.moveTo(x, y) : ctx2d.lineTo(x, y); x += sliceW;
    }
    ctx2d.stroke();
  }
  draw();
}

// ---- PITCH ----
function detectPitch() {
  if (!analyserNode) return;
  const buf = new Float32Array(analyserNode.fftSize), sr = getAudioCtx().sampleRate;
  function detect() {
    if (!analyserNode || !document.getElementById('pitchFill')) { cancelAnimationFrame(pitchAnimId); return; }
    pitchAnimId = requestAnimationFrame(detect);
    analyserNode.getFloatTimeDomainData(buf);
    updatePitchUI(autoCorrelate(buf, sr));
  }
  detect();
}
function autoCorrelate(buf, sr) {
  let SIZE = buf.length, rms = 0;
  for (let i = 0; i < SIZE; i++) rms += buf[i]*buf[i];
  rms = Math.sqrt(rms/SIZE); if (rms < 0.01) return -1;
  let r1=0, r2=SIZE-1;
  for (let i=0;i<SIZE/2;i++) if(Math.abs(buf[i])<0.2){r1=i;break;}
  for (let i=1;i<SIZE/2;i++) if(Math.abs(buf[SIZE-i])<0.2){r2=SIZE-i;break;}
  buf=buf.slice(r1,r2); SIZE=buf.length;
  const c=new Array(SIZE).fill(0);
  for(let i=0;i<SIZE;i++) for(let j=0;j<SIZE-i;j++) c[i]+=buf[j]*buf[j+i];
  let d=0; while(c[d]>c[d+1])d++;
  let maxval=-1,maxpos=-1;
  for(let i=d;i<SIZE;i++) if(c[i]>maxval){maxval=c[i];maxpos=i;}
  let T0=maxpos;
  const x1=c[T0-1],x2=c[T0],x3=c[T0+1],a=(x1+x3-2*x2)/2,b=(x3-x1)/2;
  if(a) T0-=b/(2*a);
  return sr/T0;
}
function updatePitchUI(freq) {
  const fillEl=document.getElementById('pitchFill'),curEl=document.getElementById('pitchCurrent'),offEl=document.getElementById('pitchOffset');
  const lineEl=document.getElementById('sliderPitchLine');
  if(!fillEl) return;
  if(freq<0){
    fillEl.style.width='0%';curEl.textContent='-- Hz';offEl.textContent='--';offEl.className='pitch-offset';
    if(lineEl) lineEl.classList.remove('visible');
    return;
  }
  fillEl.style.width=Math.max(0,Math.min(100,((freq-50)/950)*100))+'%';
  curEl.textContent=freq.toFixed(1)+' Hz';
  const cents=1200*Math.log2(freq/targetFreq),abs=Math.abs(cents);
  offEl.textContent=(cents>0?'+':'')+cents.toFixed(0)+' cents';
  offEl.className=abs<30?'pitch-offset good':abs<80?'pitch-offset warn':'pitch-offset bad';
  // update slider pitch line
  if(lineEl) {
    const slider = document.getElementById('toneSlider');
    if(slider) {
      const min=80, max=800;
      const clampedFreq = Math.max(min, Math.min(max, freq));
      const pct = (clampedFreq - min) / (max - min);
      const w = slider.offsetWidth;
      // account for thumb width (~14px) so it lines up with the track
      const thumbR = 7;
      const trackPx = w - thumbR * 2;
      lineEl.style.left = (thumbR + pct * trackPx - 1) + 'px';
      lineEl.classList.add('visible');
    }
  }
}

// ---- KEYBOARD ----
document.addEventListener('keydown', e => {
  // keybind capture mode
  if (bindingMode) { finishBinding(e); return; }
  if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;

  if (e.key.toLowerCase() === recordKey && !recordKeyDown) {
    recordKeyDown = true;
    if (words.length) startRecording();
    // init mic early on first ever keypress even before reclist loaded
    if (!mediaStream) initAlwaysOnMic();
  }
  if (e.key === 'ArrowRight' && currentIdx < words.length-1) { stopPlayback(); currentIdx++; renderWordList(); renderMain(); }
  if (e.key === 'ArrowLeft' && currentIdx > 0) { stopPlayback(); currentIdx--; renderWordList(); renderMain(); }
  if (e.key === ' ') { e.preventDefault(); if (recordingBlobs[words[currentIdx]]) togglePlayback(); }
});
document.addEventListener('keyup', e => {
  if (bindingMode) return;
  if (e.key.toLowerCase() === recordKey) { recordKeyDown = false; if (isRecording) stopRecording(); }
});

// ---- MIC SELECTION ----
let selectedDeviceId = '';

async function populateMicList() {
  try {
    // need permission first so labels show up
    await navigator.mediaDevices.getUserMedia({ audio: true });
    const devices = await navigator.mediaDevices.enumerateDevices();
    const mics = devices.filter(d => d.kind === 'audioinput');
    const sel = document.getElementById('micSelect');
    if (!sel) return;
    sel.innerHTML = '<option value="">default mic</option>';
    mics.forEach(d => {
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = d.label || `mic ${d.deviceId.slice(0,6)}`;
      if (d.deviceId === selectedDeviceId) opt.selected = true;
      sel.appendChild(opt);
    });
  } catch(e) { console.warn('mic enum failed:', e.message); }
}

async function onMicChange() {
  const sel = document.getElementById('micSelect');
  selectedDeviceId = sel ? sel.value : '';
  // tear down existing stream so next initAlwaysOnMic picks new device
  stopSilenceWatch();
  clearMicPanic();
  if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }
  if (alwaysOnSource) { try { alwaysOnSource.disconnect(); } catch(e) {} alwaysOnSource = null; }
  cancelAnimationFrame(waveAnimId); cancelAnimationFrame(pitchAnimId);
  await initAlwaysOnMic();
  if (analyserNode && words.length) startSilenceWatch();
}

// ---- FRQ GENERATION ----
// Generates a UTAU-compatible .frq binary from an AudioBuffer using autocorrelation pitch detection.
function generateFrqBinary(audioBuffer) {
  const HOP = 256;
  const sr = audioBuffer.sampleRate;
  const rawData = audioBuffer.getChannelData(0); // mono
  const nFrames = audioBuffer.length;
  const nPoints = Math.floor(nFrames / HOP);

  const freqs = [];
  for (let i = 0; i < nPoints; i++) {
    const start = i * HOP;
    const frame = rawData.slice(start, start + HOP * 4); // use 4 hops for autocorrelation window
    const f = autoCorrelateBuffer(frame, sr);
    freqs.push(f > 0 ? f : 0.0);
  }

  const valid = freqs.filter(f => f > 0);
  const avgPitch = valid.length ? valid.reduce((a, b) => a + b, 0) / valid.length : 0.0;

  // Build binary: FREQ0003 header + hop(int32) + avgPitch(float64) + 16 null bytes + count(int32) + [freq(f64), amp(f64)]...
  const headerStr = 'FREQ0003';
  const totalDoubles = freqs.length * 2;
  const byteLen = 8 + 4 + 8 + 16 + 4 + totalDoubles * 8;
  const buf = new ArrayBuffer(byteLen);
  const view = new DataView(buf);
  let off = 0;

  for (let i = 0; i < 8; i++) { view.setUint8(off++, headerStr.charCodeAt(i)); }
  view.setInt32(off, HOP, true); off += 4;
  view.setFloat64(off, avgPitch, true); off += 8;
  for (let i = 0; i < 16; i++) { view.setUint8(off++, 0); }
  view.setInt32(off, freqs.length, true); off += 4;
  for (const f of freqs) {
    view.setFloat64(off, f, true); off += 8;
    view.setFloat64(off, 0.0, true); off += 8;
  }
  return buf;
}

function autoCorrelateBuffer(buf, sr) {
  let SIZE = buf.length;
  let rms = 0;
  for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
  rms = Math.sqrt(rms / SIZE);
  if (rms < 0.01) return -1;

  let r1 = 0, r2 = SIZE - 1;
  for (let i = 0; i < SIZE / 2; i++) { if (Math.abs(buf[i]) < 0.2) { r1 = i; break; } }
  for (let i = 1; i < SIZE / 2; i++) { if (Math.abs(buf[SIZE - i]) < 0.2) { r2 = SIZE - i; break; } }
  buf = buf.slice(r1, r2); SIZE = buf.length;
  if (SIZE < 2) return -1;

  const c = new Array(SIZE).fill(0);
  for (let i = 0; i < SIZE; i++) for (let j = 0; j < SIZE - i; j++) c[i] += buf[j] * buf[j + i];
  let d = 0;
  while (d < SIZE - 1 && c[d] > c[d + 1]) d++;
  let maxval = -1, maxpos = -1;
  for (let i = d; i < SIZE; i++) { if (c[i] > maxval) { maxval = c[i]; maxpos = i; } }
  if (maxpos <= 0 || maxpos >= SIZE - 1) return -1;
  let T0 = maxpos;
  const x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1], a = (x1 + x3 - 2 * x2) / 2, b = (x3 - x1) / 2;
  if (a) T0 -= b / (2 * a);
  const freq = sr / T0;
  return (freq >= 55 && freq <= 1000) ? freq : 0.0;
}

// ---- EXPORT ----
async function exportAll() {
  if (!Object.keys(recordingBlobs).length) { alert('no recordings yet... hold the record key first.'); return; }
  openModal('exportModal');
  document.getElementById('exportMsg').textContent = 'preparing export...';
  document.getElementById('exportProgressMsg').style.display = 'none';
  document.getElementById('downloadZipBtn').onclick = null;
  document.getElementById('downloadZipBtn').textContent = 'building...';
  document.getElementById('downloadZipBtn').style.opacity = '0.5';

  if (!document.querySelector('script[src*="jszip"]')) {
    const s = document.createElement('script'); s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js'; document.head.appendChild(s);
    await new Promise(res => s.onload = res);
  }

  const vbName = (document.getElementById('vbNameInput')?.value.trim() || 'MyVoicebank').replace(/[\\/:*?"<>|]/g, '_');
  const zip = new JSZip();
  const folder = zip.folder(vbName);
  const otoLines = [];
  const entries = Object.entries(recordingBlobs);

  document.getElementById('exportProgressMsg').style.display = 'block';
  document.getElementById('exportProgressMsg').textContent = `generating .frq files (0 / ${entries.length})...`;

  const ctx = getAudioCtx();

  for (let idx = 0; idx < entries.length; idx++) {
    const [word, blob] = entries[idx];
    const dn = displayName(word);         // e.g. "あ" or "ka ki"
    const fname = '_' + dn;               // e.g. "_あ" or "_ka ki"

    // wav
    folder.file(fname + '.wav', await blob.arrayBuffer());

    // oto.ini line — calculate values from actual clip duration
    const alias = dn.replace(/\s+/g, '');
    let audioBuf = decodedBuffers[word];
    if (!audioBuf) {
      const ab = await blob.arrayBuffer();
      audioBuf = await ctx.decodeAudioData(ab.slice(0));
      decodedBuffers[word] = audioBuf;
    }
    const durMs = (audioBuf.length / audioBuf.sampleRate) * 1000;
    // safe oto values relative to actual duration:
    // offset=0, consonant=30% in, cutoff=-(last 20ms), preutterance=20% in, overlap=10% in
    const consonant = Math.round(durMs * 0.30);
    const cutoff    = -Math.round(durMs * 0.20);  // negative = from end
    const preutter  = Math.round(durMs * 0.20);
    const overlap   = Math.round(durMs * 0.10);
    otoLines.push(`${fname}.wav=${alias},0,${consonant},${cutoff},${preutter},${overlap}`);

    // .frq — use already-decoded buffer
    try {
      const frqBinary = generateFrqBinary(audioBuf);
      folder.file(fname + '.wav.frq', frqBinary);
    } catch(e) {
      console.warn('frq gen failed for', word, e);
    }

    document.getElementById('exportProgressMsg').textContent = `generating .frq files (${idx + 1} / ${entries.length})...`;
    // yield to UI thread every few items
    if (idx % 5 === 0) await new Promise(r => setTimeout(r, 0));
  }

  // oto.ini (UTF-8 with BOM)
  folder.file('oto.ini', '\uFEFF' + otoLines.join('\r\n'));

  // character.txt
  folder.file('character.txt', `name=${vbName}\r\n`);

  // character.yaml
  folder.file('character.yaml',
    `name: ${vbName}\r\ntext_file_encoding: utf-8\r\nportrait_opacity: 0.67\r\nportrait_height: 0\r\n`
  );

  document.getElementById('exportProgressMsg').style.display = 'none';
  document.getElementById('exportMsg').textContent =
    `${entries.length} wavs + frq files + oto.ini + character files ready.`;

  const content = await zip.generateAsync({ type: 'blob' });
  const url = URL.createObjectURL(content);
  const dlBtn = document.getElementById('downloadZipBtn');
  dlBtn.textContent = 'download .zip';
  dlBtn.style.opacity = '';
  dlBtn.onclick = () => {
    const a = document.createElement('a');
    a.href = url; a.download = vbName + '.zip'; a.click();
  };
}

// ---- CLEAR ----
function clearAll() {
  if (!confirm('clear all recordings? ...you sure?')) return;
  recordingBlobs = {}; decodedBuffers = {}; stopPlayback(); renderWordList(); renderMain(); updateStatus();
}

function updateStatus() {
  document.getElementById('statusTotal').textContent = words.length;
  document.getElementById('statusDone').textContent = Object.keys(recordingBlobs).length;
  // update mobile word tab progress
  const prog = `${Object.keys(recordingBlobs).length} / ${words.length}`;
  const p1 = document.getElementById('mobWordProgress'); if (p1) p1.textContent = prog;
  const p2 = document.getElementById('mobWordProgress2'); if (p2) p2.textContent = prog;
  renderMobWordList();
}
function openModal(id) { document.getElementById(id).classList.add('show'); }
function closeModal(id) { document.getElementById(id).classList.remove('show'); }

// ---- MOBILE SETTINGS DRAWER ----
function openMobSettings() { document.getElementById('mobSettingsDrawer').classList.add('open'); }
function closeMobSettings() { document.getElementById('mobSettingsDrawer').classList.remove('open'); }

// ---- MOBILE WORD LIST ----
let mobWordOpen = false;
function toggleMobWordList() {
  mobWordOpen = !mobWordOpen;
  const panel = document.getElementById('mobWordPanel');
  const tab = document.getElementById('mobWordTab');
  if (panel) panel.classList.toggle('open', mobWordOpen);
  if (tab) tab.classList.toggle('tab-open', mobWordOpen);
  if (mobWordOpen) renderMobWordList();
}

function renderMobWordList() {
  const el = document.getElementById('mobWordList'); if (!el) return;
  if (!words.length) { el.innerHTML = '<div style="padding:12px;font-family:\'Share Tech Mono\',monospace;font-size:0.75rem;color:var(--muted);text-align:center">no reclist loaded</div>'; return; }
  el.innerHTML = words.map((w, i) => {
    const active = i === currentIdx, done = !!recordingBlobs[w];
    const dn = displayName(w);
    return `<div class="word-item ${active?'active':''} ${done?'done':''}" onclick="selectWord(${i});toggleMobWordList()"><span>${dn}</span><span class="word-status">${done?'REC':''}</span></div>`;
  }).join('');
  setTimeout(() => { const a = el.querySelector('.active'); if (a) a.scrollIntoView({ block: 'nearest' }); }, 0);
}

// ---- MOBILE MIRROR CONTROLS ----
// these keep the mob drawer controls in sync with the desktop ones
function onNoteSelectMob() {
  const val = parseFloat(document.getElementById('noteSelectMob').value);
  const ds = document.getElementById('toneSlider'); if (ds) ds.value = val;
  const dm = document.getElementById('toneSliderMob'); if (dm) dm.value = val;
  targetFreq = val;
  document.getElementById('toneVal').textContent = val.toFixed(0) + ' Hz';
  document.getElementById('toneValMob').textContent = val.toFixed(0) + ' Hz';
  document.getElementById('statusTone').textContent = val.toFixed(0) + ' Hz';
  snapNoteSelect(val);
  updatePitchTargetLine();
}
function onToneChangeMob() {
  const val = parseFloat(document.getElementById('toneSliderMob').value);
  const ds = document.getElementById('toneSlider'); if (ds) ds.value = val;
  targetFreq = val;
  document.getElementById('toneVal').textContent = val.toFixed(0) + ' Hz';
  document.getElementById('toneValMob').textContent = val.toFixed(0) + ' Hz';
  document.getElementById('statusTone').textContent = val.toFixed(0) + ' Hz';
  snapNoteSelect(val);
  updatePitchTargetLine();
}
function onOffsetChangeMob() {
  recOffset = parseInt(document.getElementById('recOffsetSliderMob').value);
  const ds = document.getElementById('recOffsetSlider'); if (ds) ds.value = recOffset;
  const lbl = (recOffset > 0 ? '+' : '') + recOffset + ' ms';
  const v1 = document.getElementById('recOffsetVal'); if (v1) v1.textContent = lbl;
  const v2 = document.getElementById('recOffsetValMob'); if (v2) v2.textContent = lbl;
}
function onSilenceChangeMob() {
  silenceThreshold = parseFloat(document.getElementById('silenceSliderMob').value);
  const ds = document.getElementById('silenceSlider'); if (ds) ds.value = silenceThreshold;
  const txt = silenceThreshold === 0 ? 'off' : silenceThreshold.toFixed(3);
  const v1 = document.getElementById('silenceVal'); if (v1) v1.textContent = txt;
  const v2 = document.getElementById('silenceValMob'); if (v2) v2.textContent = txt;
}
function onMicChangeMob() {
  const sel = document.getElementById('micSelectMob');
  selectedDeviceId = sel ? sel.value : '';
  const ds = document.getElementById('micSelect'); if (ds) ds.value = selectedDeviceId;
  onMicChange();
}

// patch toggleRomaji and toggleAutoAdvance to also update mob mirror buttons
const _origToggleRomaji = toggleRomaji;
toggleRomaji = function() {
  _origToggleRomaji();
  const b = document.getElementById('romajiToggleBtnMob');
  if (b) { b.textContent = `Show Romaji: ${showRomaji?'ON':'OFF'}`; b.className = showRomaji ? 'btn active-toggle' : 'btn'; }
};
const _origToggleAutoAdvance = toggleAutoAdvance;
toggleAutoAdvance = function() {
  _origToggleAutoAdvance();
  const b = document.getElementById('autoAdvanceBtnMob');
  if (b) { b.textContent = `Auto-advance: ${autoAdvance?'ON':'OFF'}`; b.className = autoAdvance ? 'btn active-toggle' : 'btn'; }
};

// patch populateMicList to also fill mob select
const _origPopulateMicList = populateMicList;
populateMicList = async function() {
  await _origPopulateMicList();
  // mirror to mob select
  const src = document.getElementById('micSelect');
  const dst = document.getElementById('micSelectMob');
  if (src && dst) { dst.innerHTML = src.innerHTML; dst.value = selectedDeviceId; }
};

// ---- INIT ----
window.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('toneSlider');
  if (slider) {
    targetFreq = parseFloat(slider.value);
    document.getElementById('toneVal').textContent = targetFreq.toFixed(0) + ' Hz';
    document.getElementById('statusTone').textContent = targetFreq.toFixed(0) + ' Hz';
    snapNoteSelect(targetFreq);
    updatePitchTargetLine();
  }
});
function audioBufferToWavBlob(buffer) {
  const nc=buffer.numberOfChannels,sr=buffer.sampleRate,dl=buffer.length*nc*2;
  const ab=new ArrayBuffer(44+dl),v=new DataView(ab);
  const ws=(o,s)=>{for(let i=0;i<s.length;i++)v.setUint8(o+i,s.charCodeAt(i));};
  ws(0,'RIFF');v.setUint32(4,36+dl,true);ws(8,'WAVE');ws(12,'fmt ');
  v.setUint32(16,16,true);v.setUint16(20,1,true);v.setUint16(22,nc,true);
  v.setUint32(24,sr,true);v.setUint32(28,sr*nc*2,true);v.setUint16(32,nc*2,true);
  v.setUint16(34,16,true);ws(36,'data');v.setUint32(40,dl,true);
  let off=44;
  for(let i=0;i<buffer.length;i++) for(let ch=0;ch<nc;ch++){
    const s=Math.max(-1,Math.min(1,buffer.getChannelData(ch)[i]));
    v.setInt16(off,s<0?s*0x8000:s*0x7FFF,true);off+=2;
  }
  return new Blob([ab],{type:'audio/wav'});
}
</script>
</body>
</html>
