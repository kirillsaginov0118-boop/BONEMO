<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>BONEMO - Voice Recording Studio</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI0OC4yODEyOCIgaGVpZ2h0PSIyOS44NzgzOSIgdmlld0JveD0iMCwwLDQ4LjI4MTI4LDI5Ljg3ODM5Ij48ZGVmcz48bGluZWFyR3JhZGllbnQgeDE9IjIyOC45MzM2IiB5MT0iMTcwLjA3NDU1IiB4Mj0iMjI4LjkzMzYiIHkyPSIyMTMuNDg1MTUiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBpZD0iY29sb3ItMSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMDBmZmNlIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMjQzODM0Ii8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgeDE9IjI0MC4zOTQ0OSIgeTE9IjE2Ny4yNjU0MSIgeDI9IjI0MC4zOTQ0OSIgeTI9IjE5MC43NzgiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBpZD0iY29sb3ItMiI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjNzhmZmU1Ii8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgeDE9IjIzNC4xNDgzNiIgeTE9IjE4Mi45NzkwOSIgeDI9IjIzNC4xNDgzNiIgeTI9IjE5MS45MjU5OSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGlkPSJjb2xvci0zIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmZmZmYiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM3OGZmZTUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCB4MT0iMjUzLjg2NDE3IiB5MT0iMTcwLjgyMDgxIiB4Mj0iMjUzLjg2NDE3IiB5Mj0iMjE0LjIzMTQyIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgaWQ9ImNvbG9yLTQiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzAwZmZjZSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2EyZmZlZSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMTcuMjU4MjQsLTE2Ny4yMjg5OSkiPjxnIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjMwLjUyOTkyLDE4MC4wMzMzN2wtMy4yMjIyMSwtNC43NTIwOWwzLjc0NTE5LC02LjMwMjg5bDUuMjA2NzMsMy43NDUxOWwwLjczMDc3LDYuMDI4ODR6IiBmaWxsPSIjMDBmZmNlIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjMzLjA2MDQxLDE4OS4zMzExOWwtNS45NDk3Miw3LjAyOTkzbC05Ljg1MjQ1LC04LjkwMTg0YzAsMCA2LjU2NjE1LC0yLjg2NzY5IDcuNjgyMzksLTcuOTU2MDRjMS4yMTkyLC01LjU1NzY4IDEuNzI3NjUsLTkuNDI4NyAxLjcyNzY1LC05LjQyODdsNC43NSwyLjAwOTYydjQuOTMyNjl6IiBmaWxsPSJ1cmwoI2NvbG9yLTEpIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjI5LjE1MjQ5LDE3MC44Nzk4MWwtMi4xMjcxLDMuODM0OTFsMS44Mzg4NCwzLjQ4NDIxbC0wLjUzMTMyLDAuNTEwNDVsLTIuMDg1OSwtNC4zMDcyMmwyLjQ5NjI4LC00LjUwNDQ1bDEuNjQ2NjMsMC40MzkzbC0wLjUxOTM5LDAuNjYxOXoiIGZpbGw9IiNmZjAwOTQiIHN0cm9rZT0iI2I2NTkxYiIvPjxwYXRoIGQ9Ik0yMjcuOTM2OTEsMTg3Ljc0MTc1bDAuMTMwOCwtNC4xNTQwNmwwLjY5MzQ4LC0zLjA0OThsLTAuNzA1NDIsLTMuNDg5ODlsMC4wMDUxMSwtMi4zMjE2M2w4LjkxMTY1LC03LjQ2MDk2bDEwLjkwODEzLDIuNzc0NDVsNC45NzE0MiwxMC4xNDA1N2wtMS42MTE0Myw4LjgwMDg4bC0xMC4yOTQ3NiwxLjc5NjY5eiIgZmlsbD0idXJsKCNjb2xvci0yKSIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTIyOC41NjEyOSwxNzcuNTc4ODJsLTAuMjcxMDcsLTIuNzU2MjNsOS44NjQ0LC0wLjM5NjI4eiIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTI0MS4wMzA4MSwxOTAuNzk2OTJsNS42ODk5NywtOS42NDQwMWw0LjUwMDU0LC00LjQ2ODM5bDAuMjg5MzIsMTIuMjgwMDV6IiBmaWxsPSIjNWNlNmNiIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjM4LjQwOTM1LDE3NC40NTAxMmw5LjYxNDA4LC00LjQyOTQzbDQuMDEzNjQsNy43NjExOGwtNS4zNDc2OSwzLjI5OTZ6IiBmaWxsPSIjYjVmZmYxIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjI4LjA0ODQzLDE4Ny42NjA1NmwtMC4wMjIwMiwtNC4xOTAyOGwwLjczNDA2LC0yLjk3NDU5bC0wLjUyMDI1LC0yLjc4MDY4bDEwLjA1Nzk3LC0zLjQxNjU1bDguNTY3NjksNi44NTg3NGwtNS45NjkyNCw5LjQ0ODYzeiIgZmlsbD0iIzg1ZmZlNyIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTIyNy44ODU1MiwxOTEuMTEyNjRsNC4zOTIxMSwtNy4zMjAxOWw2LjUwNjg0LC0wLjgxMzM2bDEuNjI2NzEsOC45NDY5eiIgZmlsbD0idXJsKCNjb2xvci0zKSIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTIzNS41MDg1LDE4Ni40NzYzNGwzLjM1MDM1LC0zLjIxOTM5bDEuNDg5MzgsOC42NjQ0MnoiIGZpbGw9IiNiNWZmZjEiIHN0cm9rZT0iI2I2NTkxYiIvPjxwYXRoIGQ9Ik0yNDUuODA3MzcsMTc5LjQ5ODY5bDAuNzMwNzcsLTYuMDI4ODRsNS4yMDY3MywtMy43NDUxOWwzLjc0NTE5LDYuMzAyODlsLTMuMjIyMjEsNC43NTIxeiIgZmlsbD0iIzAwZmZjZSIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTI1MS4zNzk0OSwxNzcuNzYzMTJ2LTQuOTMyNjlsNC43NDk5OSwtMi4wMDk2MWMwLDAgMC41MDg0NSwzLjg3MTAxIDEuNzI3NjUsOS40Mjg3YzEuMTE2MjUsNS4wODgzNSA3LjY4MjM5LDcuOTU2MDQgNy42ODIzOSw3Ljk1NjA0bC05Ljg1MjQ1LDguOTAxODRsLTUuOTQ5NzEsLTcuMDI5OTN6IiBmaWxsPSJ1cmwoI2NvbG9yLTQpIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjQ5LjY5Mjk1LDE3Ni43MTk5N2wyLjQ0MDM3LC02Ljg1NzY2bDEuMDAzMTMsMC4wNDM1OGwxLjU1MzE3LDEuNTUyMWwtMC45NDI0LDAuMzUzNTdsLTEuMDAzNDgsLTAuNzgwNjNsLTEuOTYwNDksNS43MzI2MmwwLjUxNzE5LDEuMTMwOTNsMC4yMjEwMSwyLjAwOTIxeiIgZmlsbD0iI2ZmMDA5NCIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTI0OC4yNzQ1NCwxNjcuNjE0MjF2LTAuMDY3NjJoMC4xMzUyNnYwLjA2NzYyeiIgZmlsbD0iI2ZmMDA5NCIgc3Ryb2tlPSJub25lIi8+PHBhdGggZD0iTTIyOC4xMDEyNSwxNzQuNjk3NDdsOC45NDQzMywtNy40Njg0OGwxMC45MzAyMSwyLjc1NzQ0bDEuMDE3NDMsMS45OTI4OWwtMS41MDcyOSwtMS43Mjg3OWwtMTAuMzMwMjIsLTIuNDA1MjlsLTguMTEyMjYsNi42NjE3N2wtMC4zNTc5Miw2LjExMzhsLTAuODg3MiwtMy40MDY5NnoiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0iI2I2NTkxYiIvPjxwYXRoIGQ9Ik0yMjcuODgyNTUsMTkxLjA4NzM5bDMuNjY0NzMsLTUuMzY4NWwzLjc2MTE3LDAuNzcxNTJsNS4wNDcwMyw1LjM2ODV6IiBmaWxsPSIjODVmZmU3IiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjI4LjQ2OTg2LDE5MC4wNjg2MWwzLjU3ODg5LC02LjU2MTA4bDYuNzg3NzcsLTAuNTU2NTJsMS41NjE0OCw5LjAzOTA0bC0yLjAxMTg5LC04LjU3NzY5bC01LjMxOTg1LDAuNTE0MTR6IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjM1LjI5MTYxLDE4Ni40ODc0OWwtMy40ODI4OSwtMC42OTY1OGwzLjYxNTU4LDAuNDMxMjFsMy4xODQzNiwzLjU4MjQxeiIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTI0Ni41NjM1MiwxODEuMTMxNTJsLTguNDQxOTUsLTYuNDk5MThsLTkuODYxMTUsMy4wNjQ1NWw5LjkzMjEyLC0zLjQ0MjEzbDguNzEwOTksNi45MDUzNmwtMy41MjMyNCw1LjYyNTc0eiIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjYjY1OTFiIi8+PHBhdGggZD0iTTIzOS41ODU2MSwxODQuNjU0NjFsLTEuNDg5NDIsLTMuOTczMTNsMS43NTU1LC0zLjE3MzE1bDQuOTQxMDYsLTAuMDA1NDVsMy41NzM2NiwzLjA4NDQzbC0xLjgyNDU5LDMuODc3MjR6IiBmaWxsPSIjMzE3YzZkIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjI4LjAxMjMxLDE4My41MzQ2NWwwLjcwNDI1LC0zLjAyOTkxbC0wLjYzNzQxLC0zLjQ3NDc2bDIuNjY5NTEsLTAuMzQyOTdsMS41MjEwMSwzLjE5ODQ2bC0xLjU5NjUxLDMuNDk3MTJ6IiBmaWxsPSIjMzE3YzZkIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjI4LjAyNjc3LDE4My41MTc5bDIuNTM2MTcsLTAuMjM5NmwxLjczNTE1LC0zLjM4NjM0bC0xLjQzMDAzLDMuNTY3OTZ6IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9IiNiNjU5MWIiLz48cGF0aCBkPSJNMjM5LjU1MDMyLDE4NC42ODkxOGwtMS40NTcwOSwtMy45MjAwMWwxLjYzMTAxLDMuNjY4NzlsNi43MDU2NiwtMC4yMzE5bDEuOTcxMTEsLTMuNTU1NzNsLTEuODM1ODQsMy45MDM1OHoiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0iI2I2NTkxYiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjIyLjc0MTc1NTg5NDI5NjA5OjEyLjc3MTAwODc2MjMzMDE1NS0tPg==">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@300;400;600;700&family=Noto+Sans+JP:wght@400;700&display=swap');

  :root {
    --bg: #0a0a0f; --bg2: #111118; --bg3: #1a1a24;
    --accent: #00ffcc; --accent2: #ff4466; --accent3: #ffcc00;
    --text: #ddeeff; --muted: #556677; --border: #223344;
    --good: #00ff88; --warn: #ffaa00; --bad: #ff4466;
  }

  :root.light-mode {
    --bg: #f0f4f8; --bg2: #e4ecf4; --bg3: #d8e4ef;
    --text: #1a2a3a; --muted: #7a8fa0; --border: #b0c4d4;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg); color: var(--text);
    font-family: 'Rajdhani', 'Noto Sans JP', sans-serif;
    font-size: 16px; min-height: 100vh; overflow-x: hidden;
  }

  body::before {
    content: ''; position: fixed; inset: 0;
    background: repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.08) 2px,rgba(0,0,0,0.08) 4px);
    pointer-events: none; z-index: 9999;
    transition: opacity 0.3s;
  }
  body.no-crt::before { opacity: 0; }

  h1 { font-family: 'Share Tech Mono', monospace; font-size: 2.2rem; color: var(--accent); letter-spacing: 0.15em; text-shadow: 0 0 20px var(--accent), 0 0 40px rgba(0,255,204,0.3); }
  .subtitle { font-family: 'Share Tech Mono', monospace; font-size: 0.75rem; color: var(--muted); letter-spacing: 0.2em; margin-top: 2px; }

  header { padding: 18px 30px; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 20px; background: linear-gradient(135deg, var(--bg2), var(--bg)); }
  .skull { font-size: 2.5rem; position: relative; z-index: 10000; cursor: pointer; }
  .skull:hover svg { filter: brightness(1.15); }

  .app { display: grid; grid-template-columns: 280px 1fr 220px; grid-template-rows: auto 1fr auto; height: calc(100vh - 73px); }

  .sidebar { grid-row: 1 / 3; border-right: 1px solid var(--border); background: var(--bg2); display: flex; flex-direction: column; overflow-y: auto; overflow-x: hidden; }
  .sidebar::-webkit-scrollbar { width: 4px; }
  .sidebar::-webkit-scrollbar-track { background: var(--bg); }
  .sidebar::-webkit-scrollbar-thumb { background: var(--border); }
  .sidebar-section { padding: 16px; border-bottom: 1px solid var(--border); flex-shrink: 0; }
  .sidebar-section h3 { font-family: 'Share Tech Mono', monospace; font-size: 0.7rem; color: var(--muted); letter-spacing: 0.2em; margin-bottom: 10px; text-transform: uppercase; }

  .right-sidebar { grid-column: 3; grid-row: 1 / 3; border-left: 1px solid var(--border); background: var(--bg2); display: flex; flex-direction: column; overflow: hidden; }
  .right-sidebar-header { padding: 10px 16px 6px; font-family: 'Share Tech Mono', monospace; font-size: 0.65rem; color: var(--muted); letter-spacing: 0.15em; flex-shrink: 0; border-bottom: 1px solid var(--border); }
  .right-sidebar .word-list { flex: 1; min-height: 0; }

  .btn { display: inline-flex; align-items: center; gap: 8px; padding: 8px 14px; border: 1px solid var(--border); background: var(--bg3); color: var(--text); font-family: 'Rajdhani', 'Noto Sans JP', sans-serif; font-size: 0.9rem; font-weight: 600; cursor: pointer; transition: all 0.15s; letter-spacing: 0.05em; border-radius: 2px; width: 100%; text-align: left; justify-content: flex-start; }
  .btn:hover { border-color: var(--accent); color: var(--accent); background: rgba(0,255,204,0.05); box-shadow: 0 0 10px rgba(0,255,204,0.1); }
  .btn.primary { border-color: var(--accent); color: var(--accent); background: rgba(0,255,204,0.08); }
  .btn.active-toggle { border-color: var(--good); color: var(--good); background: rgba(0,255,136,0.08); }
  .btn.danger { border-color: var(--accent2); color: var(--accent2); background: rgba(255,68,102,0.06); }
  .btn + .btn { margin-top: 6px; }

  .word-list { flex: 1; overflow-y: auto; padding: 4px 8px; min-height: 0; }
  .word-list::-webkit-scrollbar { width: 4px; }
  .word-list::-webkit-scrollbar-track { background: var(--bg); }
  .word-list::-webkit-scrollbar-thumb { background: var(--border); }

  .word-item-wrap {
    display: flex; flex-direction: column;
    border-left: 2px solid transparent;
    border-radius: 2px;
    margin-bottom: 0;
    cursor: pointer;
    transition: border-color 0.1s, background 0.1s;
    border-bottom: 1px solid rgba(0,255,204,0.07);
  }
  .word-item-wrap:last-child { border-bottom: none; }
  .word-item-wrap:hover { background: var(--bg3); border-left-color: var(--muted); }
  .word-item-wrap.active { background: rgba(0,255,204,0.08); border-left-color: var(--accent); }
  .word-item-wrap.done { border-left-color: var(--good); }
  .word-item-wrap.active.done { border-left-color: var(--accent); }

  .word-item {
    padding: 8px 12px; cursor: pointer;
    border-left: none !important; border-radius: 0;
    transition: none; display: flex; align-items: center; gap: 10px;
    font-weight: 600; font-size: 1rem;
    font-family: 'Rajdhani', 'Noto Sans JP', sans-serif;
    background: transparent !important;
  }
  .word-item-wrap.active .word-item { color: var(--accent); }
  .word-item-wrap.done .word-status { color: var(--good); }
  .word-item .word-status { font-size: 0.65rem; margin-left: auto; opacity: 0.7; font-family: 'Share Tech Mono', monospace; }

  .word-mini-wave {
    width: 100%; height: 16px; display: block;
    opacity: 0; transition: opacity 0.3s;
    border-radius: 0 0 2px 2px;
    margin-top: 0;
  }
  .word-item-wrap.done .word-mini-wave { opacity: 1; }

  /* right sidebar — flip accent border to right side */
  .right-sidebar .word-item-wrap { border-left: none; border-right: 2px solid transparent; }
  .right-sidebar .word-item-wrap:hover { border-right-color: var(--muted); }
  .right-sidebar .word-item-wrap.active { border-right-color: var(--accent); }
  .right-sidebar .word-item-wrap.done { border-right-color: var(--good); }
  .right-sidebar .word-item-wrap.active.done { border-right-color: var(--accent); }

  .main-top { padding: 20px 30px; border-bottom: 1px solid var(--border); background: var(--bg2); display: flex; align-items: center; gap: 20px; flex-wrap: wrap; }
  .tone-control { display: flex; flex-direction: column; gap: 6px; }
  .tone-control label { font-family: 'Share Tech Mono', monospace; font-size: 0.65rem; color: var(--muted); letter-spacing: 0.15em; }
  .tone-row { display: flex; align-items: center; gap: 10px; }

  input[type=range] { -webkit-appearance: none; width: 180px; height: 4px; background: var(--bg3); border: 1px solid var(--border); border-radius: 2px; outline: none; }
  input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: var(--accent); border-radius: 50%; cursor: pointer; box-shadow: 0 0 8px var(--accent); }

  /* ---- PITCH LINE ON SLIDER ---- */
  .slider-pitch-wrap { position: relative; display: inline-flex; align-items: center; }
  .slider-pitch-line {
    position: absolute; top: 50%; transform: translateY(-50%);
    width: 2px; height: 22px; background: var(--accent);
    border-radius: 1px; pointer-events: none;
    box-shadow: 0 0 6px var(--accent), 0 0 12px rgba(0,255,204,0.4);
    opacity: 0; transition: opacity 0.15s, left 0.05s;
    left: 0;
  }
  .slider-pitch-line.visible { opacity: 1; }
  .tone-val { font-family: 'Share Tech Mono', monospace; font-size: 0.9rem; color: var(--accent); min-width: 60px; }

  .preview-btn { padding: 6px 12px; border: 1px solid var(--accent3); background: rgba(255,204,0,0.06); color: var(--accent3); font-family: 'Share Tech Mono', monospace; font-size: 0.75rem; cursor: pointer; border-radius: 2px; transition: all 0.15s; white-space: nowrap; }
  .preview-btn:hover { background: rgba(255,204,0,0.15); }
  .preview-btn.playing { border-color: var(--accent2); color: var(--accent2); animation: pulse 0.5s ease infinite alternate; }

  @keyframes pulse { from { opacity: 1; } to { opacity: 0.5; } }

  .main-content { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 30px; gap: 20px; overflow: hidden; min-width: 0; }

  .current-word { font-size: 5rem; font-weight: 700; letter-spacing: 0.05em; color: var(--text); text-align: center; text-shadow: 0 0 30px rgba(221,238,255,0.2); transition: color 0.3s; min-height: 100px; display: flex; align-items: center; font-family: 'Rajdhani', 'Noto Sans JP', sans-serif; flex-wrap: wrap; justify-content: center; max-width: 100%; width: 100%; overflow-wrap: break-word; word-break: break-word; }
  .current-word .seq-parts { display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 0; max-width: 100%; }
  .seq-divider {
    display: inline-block;
    width: 2px;
    height: 0.85em;
    background: var(--accent);
    box-shadow: 0 0 6px var(--accent), 0 0 14px var(--accent), 0 0 28px rgba(0,255,204,0.4);
    border-radius: 1px;
    margin: 0 0.28em;
    vertical-align: middle;
    opacity: 0.7;
    flex-shrink: 0;
  }

  /* ---- CUSTOM COLOR PICKER ---- */
  #cpPanel {
    position: fixed;
    background: var(--bg2);
    border: 1px solid var(--border);
    border-top: 2px solid var(--accent);
    font-family: 'Share Tech Mono', monospace;
    animation: cpSlideIn 0.18s cubic-bezier(0.2,0,0,1);
    overflow: hidden;
    min-width: 0;
  }
  @keyframes cpSlideIn {
    from { opacity: 0; transform: translateY(-8px) scale(0.97); }
    to   { opacity: 1; transform: translateY(0) scale(1); }
  }
  #cpHeader {
    padding: 10px 14px;
    font-size: 0.6rem;
    letter-spacing: 0.25em;
    color: var(--accent);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    text-shadow: 0 0 12px var(--accent);
    background: var(--bg2);
  }
  #cpClose {
    background: none; border: none; color: var(--muted); cursor: pointer;
    font-size: 0.8rem; padding: 0; line-height: 1; transition: color 0.15s;
  }
  #cpClose:hover { color: var(--accent2); }

  /* three-column layout */
  #cpCols {
    display: flex;
    border-bottom: 1px solid var(--border);
  }
  .cp-col {
    display: flex;
    flex-direction: column;
    width: 220px;
    flex-shrink: 0;
  }
  .cp-col + .cp-col {
    border-left: 1px solid var(--border);
  }
  .cp-col-label {
    padding: 6px 10px 5px;
    font-size: 0.5rem;
    letter-spacing: 0.2em;
    color: var(--muted);
    background: var(--bg3);
    border-bottom: 1px solid var(--border);
    text-align: center;
  }

  /* saturation/value canvas */
  .cp-satval {
    display: block; width: 220px; height: 160px;
    cursor: crosshair;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .cp-satval-thumb {
    position: absolute;
    width: 12px; height: 12px;
    border-radius: 50%;
    border: 2px solid #fff;
    box-shadow: 0 0 0 1px rgba(0,0,0,0.6), 0 0 8px rgba(0,0,0,0.8);
    pointer-events: none;
    transform: translate(-50%, -50%);
    transition: box-shadow 0.1s;
  }

  /* sliders */
  .cp-sliders {
    padding: 10px 10px 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    background: var(--bg3);
    border-bottom: 1px solid var(--border);
  }
  .cp-slider-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .cp-lbl {
    font-size: 0.5rem;
    letter-spacing: 0.12em;
    color: var(--muted);
    width: 34px;
    flex-shrink: 0;
  }
  .cp-track-wrap {
    position: relative;
    flex: 1;
    height: 12px;
  }
  .cp-track-wrap canvas {
    display: block;
    width: 100%;
    height: 12px;
    border-radius: 3px;
    cursor: pointer;
  }
  .cp-thumb {
    position: absolute;
    top: 50%;
    width: 16px; height: 16px;
    border-radius: 50%;
    background: #fff;
    border: 2px solid rgba(255,255,255,0.9);
    box-shadow: 0 0 0 1px rgba(0,0,0,0.5), 0 2px 6px rgba(0,0,0,0.7);
    transform: translate(-50%, -50%);
    pointer-events: none;
    left: 0;
  }

  /* per-column bottom: preview + hex + apply */
  .cp-bottom {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px;
    background: var(--bg2);
    border-bottom: 1px solid var(--border);
  }
  .cp-preview {
    width: 28px; height: 28px;
    border-radius: 3px;
    flex-shrink: 0;
    border: 1px solid var(--border);
    transition: background 0.1s, box-shadow 0.1s;
  }
  .cp-hex-wrap {
    display: flex;
    align-items: center;
    flex: 1;
    border: 1px solid var(--border);
    background: var(--bg);
    padding: 5px 7px;
    border-radius: 2px;
    gap: 2px;
    transition: border-color 0.15s;
    min-width: 0;
  }
  .cp-hex-wrap:focus-within { border-color: var(--accent); }
  .cp-hash { color: var(--muted); font-size: 0.75rem; flex-shrink: 0; }
  .cp-hex-input {
    background: none; border: none; outline: none;
    color: var(--accent); font-family: 'Share Tech Mono', monospace;
    font-size: 0.75rem; letter-spacing: 0.08em;
    width: 56px; text-transform: uppercase; min-width: 0;
  }
  .cp-apply {
    padding: 6px 10px;
    border: 1px solid var(--accent);
    background: rgba(0,255,204,0.08);
    color: var(--accent);
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.55rem;
    letter-spacing: 0.12em;
    cursor: pointer;
    border-radius: 2px;
    transition: all 0.15s;
    flex-shrink: 0;
    white-space: nowrap;
  }
  .cp-apply:hover { background: rgba(0,255,204,0.18); }

  /* swatches row — shared across bottom */
  #cpSwatches {
    padding: 8px 10px 10px;
    background: var(--bg2);
  }
  .cp-swatch-label {
    font-size: 0.5rem;
    letter-spacing: 0.2em;
    color: var(--muted);
    margin-bottom: 7px;
    opacity: 0.6;
  }
  #cpSwatchRow {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
  }
  .cp-sw {
    width: 20px; height: 20px;
    border-radius: 50%;
    cursor: pointer;
    border: 1px solid rgba(255,255,255,0.08);
    transition: transform 0.15s, box-shadow 0.15s;
    flex-shrink: 0;
  }
  .cp-sw:hover { transform: scale(1.28); box-shadow: 0 0 10px currentColor; }

  /* footer buttons */
  #cpFooter {
    display: flex;
    gap: 8px;
    padding: 8px 10px 10px;
    background: var(--bg2);
    border-top: 1px solid var(--border);
    flex-wrap: wrap;
  }
  .cp-foot-btn {
    flex: 1;
    padding: 7px 8px;
    background: none;
    border: 1px solid var(--border);
    color: var(--muted);
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.55rem;
    letter-spacing: 0.12em;
    cursor: pointer;
    border-radius: 2px;
    transition: all 0.15s;
    white-space: nowrap;
    text-align: center;
  }
  .cp-foot-btn:hover { border-color: var(--accent); color: var(--accent); }
  .cp-foot-btn.active {
    border-color: transparent;
    color: #fff;
    background: linear-gradient(90deg,#ff0055,#ff6600,#ffcc00,#00ff88,#00ccff,#aa00ff,#ff0055);
    background-size: 200% 100%;
    animation: rainbowShift 1.5s linear infinite;
    text-shadow: 0 0 8px rgba(0,0,0,0.8);
  }
  .cp-foot-btn.on { border-color: var(--accent); color: var(--accent); background: rgba(0,255,204,0.08); }
  @keyframes rainbowShift {
    from { background-position: 0% 0; }
    to   { background-position: 200% 0; }
  }
  .current-word.recording { color: var(--accent2); text-shadow: 0 0 30px rgba(255,68,102,0.4); }
  .current-word.done-word { color: var(--good); }

  #waveCanvas { width: 100%; max-width: 700px; height: 100px; border: 1px solid var(--border); background: var(--bg3); border-radius: 2px; }

  .pitch-section { display: flex; flex-direction: column; align-items: center; gap: 8px; width: 100%; max-width: 700px; }
  .pitch-label { font-family: 'Share Tech Mono', monospace; font-size: 0.7rem; color: var(--muted); letter-spacing: 0.15em; align-self: flex-start; }
  .pitch-meter { width: 100%; height: 28px; background: var(--bg3); border: 1px solid var(--border); border-radius: 2px; position: relative; overflow: hidden; }
  .pitch-fill { height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), var(--accent3)); transition: width 0.08s; position: absolute; left: 0; }
  .pitch-target-line { position: absolute; top: 0; bottom: 0; width: 2px; background: var(--accent2); box-shadow: 0 0 6px var(--accent2); }
  .pitch-info { display: flex; justify-content: space-between; width: 100%; font-family: 'Share Tech Mono', monospace; font-size: 0.75rem; }
  .pitch-current { color: var(--accent3); }
  .pitch-target-label { color: var(--accent2); }
  .pitch-offset.good { color: var(--good); }
  .pitch-offset.warn { color: var(--warn); }
  .pitch-offset.bad { color: var(--bad); }

  .playback-row { display: flex; align-items: center; gap: 12px; width: 100%; max-width: 700px; }
  #playbackCanvas { flex: 1; height: 60px; border: 1px solid var(--border); background: var(--bg3); border-radius: 2px; cursor: default; user-select: none; }

  .play-btn { padding: 7px 16px; border: 1px solid var(--accent); background: rgba(0,255,204,0.08); color: var(--accent); font-family: 'Share Tech Mono', monospace; font-size: 0.8rem; cursor: pointer; border-radius: 2px; transition: all 0.15s; white-space: nowrap; flex-shrink: 0; }
  .play-btn:hover { background: rgba(0,255,204,0.18); }
  .play-btn.playing { border-color: var(--accent3); color: var(--accent3); animation: pulse 0.6s ease infinite alternate; }

  .record-hint { display: flex; align-items: center; gap: 12px; padding: 12px 20px; border: 1px solid var(--border); background: var(--bg3); border-radius: 2px; font-family: 'Share Tech Mono', monospace; font-size: 0.8rem; color: var(--muted); }
  .record-hint .key { padding: 4px 10px; border: 1px solid var(--accent); color: var(--accent); border-radius: 2px; font-size: 0.9rem; box-shadow: 0 0 8px rgba(0,255,204,0.2); cursor: pointer; transition: all 0.15s; user-select: none; }
  .record-hint .key:hover { background: rgba(0,255,204,0.1); box-shadow: 0 0 16px rgba(0,255,204,0.4); }
  .record-hint .key.binding { border-color: var(--accent3); color: var(--accent3); box-shadow: 0 0 12px rgba(255,204,0,0.5); animation: pulse 0.4s ease infinite alternate; }

  .recording-indicator { display: flex; align-items: center; gap: 8px; color: var(--accent2); font-size: 0.85rem; animation: pulse 0.6s ease infinite alternate; opacity: 0; transition: opacity 0.2s; font-family: 'Share Tech Mono', monospace; }
  .recording-indicator.active { opacity: 1; }
  .rec-dot {
    width: 10px; height: 10px; background: var(--accent2); border-radius: 50%;
    box-shadow: 0 0 8px var(--accent2);
    outline: 2px solid var(--accent2); outline-offset: 3px;
    cursor: pointer; transition: all 0.15s; flex-shrink: 0;
  }
  .rec-dot:hover { outline-color: #fff; }
  .rec-dot.muted { background: transparent; box-shadow: none; outline-color: var(--muted); }
  .recording-indicator.muted { color: var(--muted); animation: none; }

  .progress-bar-wrap { width: 100%; max-width: 700px; display: flex; align-items: center; gap: 12px; }
  .progress-bar { flex: 1; height: 4px; background: var(--bg3); border-radius: 2px; overflow: hidden; }
  .progress-fill { height: 100%; background: var(--accent); border-radius: 2px; transition: width 0.3s; box-shadow: 0 0 8px var(--accent); }
  .progress-text { font-family: 'Share Tech Mono', monospace; font-size: 0.75rem; color: var(--muted); white-space: nowrap; }

  .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; pointer-events: none; transition: opacity 0.2s; }
  .modal-overlay.show { opacity: 1; pointer-events: all; }
  .modal { background: var(--bg2); border: 1px solid var(--border); border-top: 2px solid var(--accent); padding: 28px; min-width: 420px; max-width: 520px; box-shadow: 0 20px 60px rgba(0,0,0,0.8); }
  .modal h2 { font-family: 'Share Tech Mono', monospace; font-size: 1rem; color: var(--accent); letter-spacing: 0.15em; margin-bottom: 20px; }
  .modal p { font-size: 0.9rem; color: var(--muted); margin-bottom: 16px; line-height: 1.5; }
  .modal-row { display: flex; gap: 10px; margin-top: 16px; }
  .modal-input { flex: 1; padding: 8px 12px; background: var(--bg3); border: 1px solid var(--border); color: var(--text); font-family: 'Share Tech Mono', monospace; font-size: 0.85rem; border-radius: 2px; outline: none; }
  .modal-input:focus { border-color: var(--accent); }
  .modal-btn { padding: 8px 18px; border: 1px solid var(--accent); background: rgba(0,255,204,0.08); color: var(--accent); font-family: 'Rajdhani', sans-serif; font-weight: 700; font-size: 0.9rem; cursor: pointer; border-radius: 2px; letter-spacing: 0.05em; transition: all 0.15s; }
  .modal-btn:hover { background: rgba(0,255,204,0.18); }
  .modal-btn.cancel { border-color: var(--muted); color: var(--muted); background: transparent; }
  .modal-btn.cancel:hover { border-color: var(--text); color: var(--text); }

  .status-bar { padding: 8px 30px; background: var(--bg); border-top: 1px solid var(--border); font-family: 'Share Tech Mono', monospace; font-size: 0.7rem; color: var(--muted); display: flex; gap: 20px; grid-column: 1 / 4; }
  .status-item span { color: var(--accent); margin-left: 4px; }

  .no-reclist { text-align: center; color: var(--muted); font-family: 'Share Tech Mono', monospace; font-size: 0.8rem; line-height: 2; }
  .no-reclist .big { font-size: 3rem; opacity: 0.3; }

  select { padding: 7px 12px; background: var(--bg3); border: 1px solid var(--border); color: var(--text); font-family: 'Rajdhani', sans-serif; font-size: 0.9rem; border-radius: 2px; outline: none; cursor: pointer; }
  select:focus { border-color: var(--accent); }

  .keys-hint { font-family: 'Share Tech Mono', monospace; font-size: 0.65rem; color: var(--muted); text-align: center; }
  .keys-hint .key { display: inline-block; padding: 2px 6px; border: 1px solid var(--muted); border-radius: 2px; margin: 0 3px; color: var(--text); }

  /* ---- MIC PANIC ---- */
  @keyframes micPanic {
    0%   { border-color: var(--bad); color: var(--bad); box-shadow: 0 0 0 rgba(255,68,102,0); transform: translateX(0); }
    10%  { transform: translateX(-4px); }
    20%  { transform: translateX(4px); border-color: var(--accent3); color: var(--accent3); box-shadow: 0 0 18px rgba(255,204,0,0.6); }
    30%  { transform: translateX(-4px); }
    40%  { transform: translateX(4px); border-color: var(--bad); color: var(--bad); box-shadow: 0 0 24px rgba(255,68,102,0.8); }
    50%  { transform: translateX(-3px); }
    60%  { transform: translateX(3px); }
    70%  { transform: translateX(-2px); border-color: var(--accent3); color: var(--accent3); }
    80%  { transform: translateX(2px); }
    90%  { transform: translateX(-1px); border-color: var(--bad); color: var(--bad); }
    100% { transform: translateX(0); box-shadow: 0 0 16px rgba(255,68,102,0.5); }
  }
  @keyframes micPanicLabel {
    0%, 100% { color: var(--bad); }
    50% { color: var(--accent3); }
  }
  .header-mic.panic label { animation: micPanicLabel 0.4s ease infinite; }
  .header-mic.panic select {
    border-color: var(--bad) !important;
    color: var(--bad) !important;
    animation: micPanic 0.5s ease infinite;
  }
  .header-mic.panic::after {
    content: '!! NO SIGNAL — TRY SOMETHING ELSE !!';
    display: block;
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.55rem;
    color: var(--bad);
    letter-spacing: 0.1em;
    animation: micPanicLabel 0.3s ease infinite;
    white-space: nowrap;
  }
  /* mobile panic — shake the settings gear */
  @keyframes gearPanic {
    0%,100% { transform: rotate(0deg); color: var(--muted); border-color: var(--border); }
    15% { transform: rotate(-20deg) scale(1.2); color: var(--bad); border-color: var(--bad); box-shadow: 0 0 12px rgba(255,68,102,0.6); }
    30% { transform: rotate(20deg) scale(1.2); color: var(--accent3); border-color: var(--accent3); box-shadow: 0 0 16px rgba(255,204,0,0.6); }
    45% { transform: rotate(-15deg); color: var(--bad); }
    60% { transform: rotate(15deg); }
    75% { transform: rotate(-8deg); }
    90% { transform: rotate(5deg); }
  }
  .mob-settings-btn.panic { animation: gearPanic 0.6s ease infinite; }
  .header-mic { display: flex; flex-direction: column; gap: 4px; margin-left: auto; }
  .header-mic label { font-family: 'Share Tech Mono', monospace; font-size: 0.6rem; color: var(--muted); letter-spacing: 0.15em; }
  .header-mic select { font-size: 0.8rem; padding: 5px 10px; max-width: 220px; }

  /* ---- MOBILE RECORD BUTTON ---- */
  .mobile-rec-btn {
    display: none;
    width: 140px; height: 140px; border-radius: 50%;
    border: 3px solid var(--accent2);
    background: rgba(255,68,102,0.08);
    color: var(--accent2);
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.85rem; letter-spacing: 0.1em;
    flex-direction: column; align-items: center; justify-content: center; gap: 8px;
    cursor: pointer; transition: all 0.15s;
    box-shadow: 0 0 20px rgba(255,68,102,0.2);
    user-select: none; -webkit-user-select: none;
    touch-action: none;
  }
  .mobile-rec-btn .rec-ring { width: 20px; height: 20px; border-radius: 50%; background: var(--accent2); box-shadow: 0 0 10px var(--accent2); }
  .mobile-rec-btn.recording-active { background: rgba(255,68,102,0.25); box-shadow: 0 0 40px rgba(255,68,102,0.5); transform: scale(1.05); }

  /* ---- MOBILE SETTINGS DRAWER ---- */
  .mob-settings-btn {
    display: none; align-items: center; justify-content: center;
    width: 38px; height: 38px; border: 1px solid var(--border);
    background: var(--bg3); color: var(--muted); border-radius: 2px;
    cursor: pointer; font-size: 1.1rem; transition: all 0.15s; flex-shrink: 0;
  }
  .mob-settings-btn:hover { border-color: var(--accent); color: var(--accent); }
  .mob-settings-drawer {
    display: none; position: fixed; inset: 0; z-index: 500;
  }
  .mob-settings-drawer.open { display: block; }
  .mob-settings-scrim { position: absolute; inset: 0; background: rgba(0,0,0,0.7); }
  .mob-settings-panel {
    position: absolute; top: 0; left: 0; bottom: 0; width: 300px;
    background: var(--bg2); border-right: 1px solid var(--border);
    overflow-y: auto; display: flex; flex-direction: column;
  }
  .mob-settings-panel::-webkit-scrollbar { width: 4px; }
  .mob-settings-panel::-webkit-scrollbar-thumb { background: var(--border); }
  .mob-settings-header {
    padding: 14px 16px; border-bottom: 1px solid var(--border);
    display: flex; align-items: center; justify-content: space-between;
    font-family: 'Share Tech Mono', monospace; font-size: 0.7rem;
    color: var(--accent); letter-spacing: 0.2em;
  }
  .mob-settings-close {
    background: none; border: none; color: var(--muted); font-size: 1.2rem;
    cursor: pointer; padding: 0 4px; line-height: 1;
  }

  /* ---- MOBILE WORD PANEL (bottom) ---- */
  .mob-word-panel {
    display: none; position: fixed; bottom: 0; left: 0; right: 0; z-index: 400;
    background: var(--bg2); border-top: 1px solid var(--border);
    flex-direction: column;
  }
  .mob-word-panel.open { display: flex; }
  .mob-word-tab {
    display: none; position: fixed; bottom: 0; left: 0; right: 0; z-index: 399;
    background: var(--bg2); border-top: 1px solid var(--border);
    padding: 8px 16px; font-family: 'Share Tech Mono', monospace;
    font-size: 0.7rem; color: var(--muted); letter-spacing: 0.15em;
    align-items: center; justify-content: space-between; cursor: pointer;
    transition: color 0.15s;
  }
  .mob-word-tab:hover { color: var(--accent); }
  .mob-word-tab-arrow { transition: transform 0.2s; }
  .mob-word-tab.tab-open .mob-word-tab-arrow { transform: rotate(180deg); }
  .mob-word-list-wrap {
    max-height: 45vh; overflow-y: auto; padding: 6px;
  }
  .mob-word-list-wrap::-webkit-scrollbar { width: 4px; }
  .mob-word-list-wrap::-webkit-scrollbar-thumb { background: var(--border); }

  @media (max-width: 700px) {
    /* hide desktop sidebar and status bar entirely */
    .sidebar { display: none !important; }
    .right-sidebar { display: none !important; }
    .status-bar { display: none !important; }
    .main-top { display: none !important; }
    .header-mic { display: none !important; }

    /* layout */
    .app { grid-template-columns: 1fr; grid-template-rows: 1fr; height: calc(100vh - 64px); }
    .main-content { padding: 16px; gap: 14px; padding-bottom: 80px; }

    /* header */
    h1 { font-size: 1.4rem; }
    .skull svg { width: 48px !important; height: 30px !important; }
    header { padding: 12px 16px; gap: 12px; }

    /* show mobile-only elements */
    .mobile-rec-btn { display: flex; }
    .record-hint { display: none; }
    .mob-settings-btn { display: flex; }
    .mob-word-tab { display: flex; }

    .current-word { font-size: 3.5rem; min-height: 70px; overflow-wrap: break-word; }
    input[type=range] { width: 130px; }

    /* modal fix */
    .modal { min-width: unset; width: calc(100vw - 32px); max-width: 100%; }
  }
</style>
</head>
<body>

<header>
  <div class="skull" id="skullBtn" title="click to change theme color" style="position:relative;cursor:pointer" onclick="toggleCP(event)">
    <svg id="skullSvg" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="72" height="44" viewBox="0,0,48.28128,29.87839" style="display:block;transition:filter 0.3s"><defs><linearGradient x1="228.9336" y1="170.07455" x2="228.9336" y2="213.48515" gradientUnits="userSpaceOnUse" id="color-1"><stop offset="0" stop-color="#00ffce"/><stop offset="1" stop-color="#243834"/></linearGradient><linearGradient x1="240.39449" y1="167.26541" x2="240.39449" y2="190.778" gradientUnits="userSpaceOnUse" id="color-2"><stop offset="0" stop-color="#ffffff"/><stop offset="1" stop-color="#78ffe5"/></linearGradient><linearGradient x1="234.14836" y1="182.97909" x2="234.14836" y2="191.92599" gradientUnits="userSpaceOnUse" id="color-3"><stop offset="0" stop-color="#ffffff"/><stop offset="1" stop-color="#78ffe5"/></linearGradient><linearGradient x1="253.86417" y1="170.82081" x2="253.86417" y2="214.23142" gradientUnits="userSpaceOnUse" id="color-4"><stop offset="0" stop-color="#00ffce"/><stop offset="1" stop-color="#a2ffee"/></linearGradient></defs><g transform="translate(-217.25824,-167.22899)"><g stroke-width="0" stroke-miterlimit="10"><path d="M230.52992,180.03337l-3.22221,-4.75209l3.74519,-6.30289l5.20673,3.74519l0.73077,6.02884z" fill="#00ffce" stroke="#b6591b"/><path d="M233.06041,189.33119l-5.94972,7.02993l-9.85245,-8.90184c0,0 6.56615,-2.86769 7.68239,-7.95604c1.2192,-5.55768 1.72765,-9.4287 1.72765,-9.4287l4.75,2.00962v4.93269z" fill="url(#color-1)" stroke="#b6591b"/><path d="M229.15249,170.87981l-2.1271,3.83491l1.83884,3.48421l-0.53132,0.51045l-2.0859,-4.30722l2.49628,-4.50445l1.64663,0.4393l-0.51939,0.6619z" fill="#ff0094" stroke="#b6591b"/><path d="M227.93691,187.74175l0.1308,-4.15406l0.69348,-3.0498l-0.70542,-3.48989l0.00511,-2.32163l8.91165,-7.46096l10.90813,2.77445l4.97142,10.14057l-1.61143,8.80088l-10.29476,1.79669z" fill="url(#color-2)" stroke="#b6591b"/><path d="M228.56129,177.57882l-0.27107,-2.75623l9.8644,-0.39628z" fill="#ffffff" stroke="#b6591b"/><path d="M241.03081,190.79692l5.68997,-9.64401l4.50054,-4.46839l0.28932,12.28005z" fill="#5ce6cb" stroke="#b6591b"/><path d="M238.40935,174.45012l9.61408,-4.42943l4.01364,7.76118l-5.34769,3.2996z" fill="#b5fff1" stroke="#b6591b"/><path d="M228.04843,187.66056l-0.02202,-4.19028l0.73406,-2.97459l-0.52025,-2.78068l10.05797,-3.41655l8.56769,6.85874l-5.96924,9.44863z" fill="#85ffe7" stroke="#b6591b"/><path d="M227.88552,191.11264l4.39211,-7.32019l6.50684,-0.81336l1.62671,8.9469z" fill="url(#color-3)" stroke="#b6591b"/><path d="M235.5085,186.47634l3.35035,-3.21939l1.48938,8.66442z" fill="#b5fff1" stroke="#b6591b"/><path d="M245.80737,179.49869l0.73077,-6.02884l5.20673,-3.74519l3.74519,6.30289l-3.22221,4.7521z" fill="#00ffce" stroke="#b6591b"/><path d="M251.37949,177.76312v-4.93269l4.74999,-2.00961c0,0 0.50845,3.87101 1.72765,9.4287c1.11625,5.08835 7.68239,7.95604 7.68239,7.95604l-9.85245,8.90184l-5.94971,-7.02993z" fill="url(#color-4)" stroke="#b6591b"/><path d="M249.69295,176.71997l2.44037,-6.85766l1.00313,0.04358l1.55317,1.5521l-0.9424,0.35357l-1.00348,-0.78063l-1.96049,5.73262l0.51719,1.13093l0.22101,2.00921z" fill="#ff0094" stroke="#b6591b"/><path d="M248.27454,167.61421v-0.06762h0.13526v0.06762z" fill="#ff0094" stroke="none"/><path d="M228.10125,174.69747l8.94433,-7.46848l10.93021,2.75744l1.01743,1.99289l-1.50729,-1.72879l-10.33022,-2.40529l-8.11226,6.66177l-0.35792,6.1138l-0.8872,-3.40696z" fill="#ffffff" stroke="#b6591b"/><path d="M227.88255,191.08739l3.66473,-5.3685l3.76117,0.77152l5.04703,5.3685z" fill="#85ffe7" stroke="#b6591b"/><path d="M228.46986,190.06861l3.57889,-6.56108l6.78777,-0.55652l1.56148,9.03904l-2.01189,-8.57769l-5.31985,0.51414z" fill="#ffffff" stroke="#b6591b"/><path d="M235.29161,186.48749l-3.48289,-0.69658l3.61558,0.43121l3.18436,3.58241z" fill="#ffffff" stroke="#b6591b"/><path d="M246.56352,181.13152l-8.44195,-6.49918l-9.86115,3.06455l9.93212,-3.44213l8.71099,6.90536l-3.52324,5.62574z" fill="#ffffff" stroke="#b6591b"/><path d="M239.58561,184.65461l-1.48942,-3.97313l1.7555,-3.17315l4.94106,-0.00545l3.57366,3.08443l-1.82459,3.87724z" fill="#317c6d" stroke="#b6591b"/><path d="M228.01231,183.53465l0.70425,-3.02991l-0.63741,-3.47476l2.66951,-0.34297l1.52101,3.19846l-1.59651,3.49712z" fill="#317c6d" stroke="#b6591b"/><path d="M228.02677,183.5179l2.53617,-0.2396l1.73515,-3.38634l-1.43003,3.56796z" fill="#ffffff" stroke="#b6591b"/><path d="M239.55032,184.68918l-1.45709,-3.92001l1.63101,3.66879l6.70566,-0.2319l1.97111,-3.55573l-1.83584,3.90358z" fill="#ffffff" stroke="#b6591b"/></g></g></svg>
  </div>

  <!-- CUSTOM COLOR PICKER -->
  <div id="cpPopup" style="display:none;position:fixed;top:0;left:0;z-index:99999">
    <div id="cpScrim" onclick="closeCP()" style="position:fixed;inset:0"></div>
    <div id="cpPanel">
      <div id="cpHeader">// CHROMATIC OVERRIDE //
        <button id="cpClose" onclick="closeCP()">&#x2715;</button>
      </div>
      <div id="cpCols">
        <!-- ACCENT -->
        <div class="cp-col" id="cpCol-accent">
          <div class="cp-col-label">ACCENT</div>
          <canvas class="cp-satval" id="cpSatVal-accent" width="220" height="160"></canvas>
          <div class="cp-satval-thumb" id="cpSvThumb-accent"></div>
          <div class="cp-sliders">
            <div class="cp-slider-row"><span class="cp-lbl">HUE</span><div class="cp-track-wrap"><canvas id="cpHue-accent" width="150" height="12"></canvas><div class="cp-thumb" id="cpHueThumb-accent"></div></div></div>
            <div class="cp-slider-row"><span class="cp-lbl">BRIGHT</span><div class="cp-track-wrap"><canvas id="cpVal-accent" width="150" height="12"></canvas><div class="cp-thumb" id="cpValThumb-accent"></div></div></div>
            <div class="cp-slider-row"><span class="cp-lbl">SAT</span><div class="cp-track-wrap"><canvas id="cpSat-accent" width="150" height="12"></canvas><div class="cp-thumb" id="cpSatThumb-accent"></div></div></div>
          </div>
          <div class="cp-bottom">
            <div class="cp-preview" id="cpPreview-accent"></div>
            <div class="cp-hex-wrap"><span class="cp-hash">#</span><input class="cp-hex-input" id="cpHex-accent" maxlength="6" spellcheck="false" oninput="cpHexTyped('accent',this.value)" onfocus="this.select()"></div>
            <button class="cp-apply cp-foot-btn" id="cpRainbowBtn-accent" onclick="toggleRainbow('accent')" style="white-space:nowrap;padding:6px 8px">RGB</button>
            <button class="cp-apply" onclick="cpApply('accent')">SET</button>
          </div>
        </div>
        <!-- BACKGROUND -->
        <div class="cp-col" id="cpCol-bg">
          <div class="cp-col-label">BACKGROUND</div>
          <canvas class="cp-satval" id="cpSatVal-bg" width="220" height="160"></canvas>
          <div class="cp-satval-thumb" id="cpSvThumb-bg"></div>
          <div class="cp-sliders">
            <div class="cp-slider-row"><span class="cp-lbl">HUE</span><div class="cp-track-wrap"><canvas id="cpHue-bg" width="150" height="12"></canvas><div class="cp-thumb" id="cpHueThumb-bg"></div></div></div>
            <div class="cp-slider-row"><span class="cp-lbl">BRIGHT</span><div class="cp-track-wrap"><canvas id="cpVal-bg" width="150" height="12"></canvas><div class="cp-thumb" id="cpValThumb-bg"></div></div></div>
            <div class="cp-slider-row"><span class="cp-lbl">SAT</span><div class="cp-track-wrap"><canvas id="cpSat-bg" width="150" height="12"></canvas><div class="cp-thumb" id="cpSatThumb-bg"></div></div></div>
          </div>
          <div class="cp-bottom">
            <div class="cp-preview" id="cpPreview-bg"></div>
            <div class="cp-hex-wrap"><span class="cp-hash">#</span><input class="cp-hex-input" id="cpHex-bg" maxlength="6" spellcheck="false" oninput="cpHexTyped('bg',this.value)" onfocus="this.select()"></div>
            <button class="cp-apply cp-foot-btn" id="cpRainbowBtn-bg" onclick="toggleRainbow('bg')" style="white-space:nowrap;padding:6px 8px">RGB</button>
            <button class="cp-apply" onclick="cpApply('bg')">SET</button>
          </div>
        </div>
        <!-- TEXT -->
        <div class="cp-col" id="cpCol-text">
          <div class="cp-col-label">TEXT</div>
          <canvas class="cp-satval" id="cpSatVal-text" width="220" height="160"></canvas>
          <div class="cp-satval-thumb" id="cpSvThumb-text"></div>
          <div class="cp-sliders">
            <div class="cp-slider-row"><span class="cp-lbl">HUE</span><div class="cp-track-wrap"><canvas id="cpHue-text" width="150" height="12"></canvas><div class="cp-thumb" id="cpHueThumb-text"></div></div></div>
            <div class="cp-slider-row"><span class="cp-lbl">BRIGHT</span><div class="cp-track-wrap"><canvas id="cpVal-text" width="150" height="12"></canvas><div class="cp-thumb" id="cpValThumb-text"></div></div></div>
            <div class="cp-slider-row"><span class="cp-lbl">SAT</span><div class="cp-track-wrap"><canvas id="cpSat-text" width="150" height="12"></canvas><div class="cp-thumb" id="cpSatThumb-text"></div></div></div>
          </div>
          <div class="cp-bottom">
            <div class="cp-preview" id="cpPreview-text"></div>
            <div class="cp-hex-wrap"><span class="cp-hash">#</span><input class="cp-hex-input" id="cpHex-text" maxlength="6" spellcheck="false" oninput="cpHexTyped('text',this.value)" onfocus="this.select()"></div>
            <button class="cp-apply cp-foot-btn" id="cpRainbowBtn-text" onclick="toggleRainbow('text')" style="white-space:nowrap;padding:6px 8px">RGB</button>
            <button class="cp-apply" onclick="cpApply('text')">SET</button>
          </div>
        </div>
      </div>
      <!-- footer buttons -->
      <div id="cpFooter">
        <button class="cp-foot-btn" id="cpCrtBtn" onclick="toggleCrt()">CRT OFF</button>
        <button class="cp-foot-btn" id="cpResetBtn" onclick="cpResetAll()">RESET ALL</button>
      </div>
    </div>
  </div>
  <div>
    <h1>BONEMO</h1>
    <div class="subtitle">// skeleton voice recording studio // v1.2 //</div>
  </div>
  <!-- desktop mic selector -->
  <div class="header-mic">
    <label>MICROPHONE</label>
    <select id="micSelect" onchange="onMicChange()">
      <option value="">default mic</option>
    </select>
  </div>
  <!-- hover-play toggle -->
  <div class="header-mic" style="margin-left:0">
    <label>HOVER PLAY</label>
    <button id="hoverPlayBtn" onclick="toggleHoverPlay()" style="padding:5px 12px;border:1px solid var(--border);background:var(--bg3);color:var(--muted);font-family:'Share Tech Mono',monospace;font-size:0.75rem;cursor:pointer;border-radius:2px;transition:all 0.15s;white-space:nowrap">OFF</button>
  </div>
  <!-- mobile: settings icon -->
  <button class="mob-settings-btn" onclick="openMobSettings()" title="Settings">&#9881;</button>
</header>

<div class="app">
  <div class="sidebar">
    <div class="sidebar-section">
      <h3>Setup</h3>
      <button class="btn primary" onclick="loadReclist()">&#9654; Load reclist.txt</button>
    </div>
    <div class="sidebar-section">
      <h3>Session</h3>
      <button class="btn" onclick="exportAll()">&#8659; Export WAV + oto.ini</button>
      <button class="btn danger" onclick="clearAll()">&#x2715; Clear recordings</button>
    </div>
    <div class="sidebar-section">
      <h3>Display</h3>
      <button class="btn" id="romajiToggleBtn" onclick="toggleRomaji()">Show Romaji: OFF</button>
      <button class="btn" id="autoAdvanceBtn" onclick="toggleAutoAdvance()" style="margin-top:6px">Auto-advance: ON</button>
    </div>
    <div class="sidebar-section">
      <h3>Recording Offset</h3>
      <div class="tone-control" style="width:100%">
        <div class="tone-row" style="gap:8px">
          <input type="range" id="recOffsetSlider" min="-300" max="300" value="0" step="10" oninput="onOffsetChange()" style="width:100%">
        </div>
        <div style="display:flex;justify-content:space-between;margin-top:4px">
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">-300ms</span>
          <span class="tone-val" id="recOffsetVal" style="font-size:0.8rem;min-width:unset">0 ms</span>
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">+300ms</span>
        </div>
        <div style="font-family:'Share Tech Mono',monospace;font-size:0.6rem;color:var(--muted);margin-top:6px;line-height:1.5">negative: trims clip start<br>positive: delays record start</div>
      </div>
    </div>
    <div class="sidebar-section">
      <h3 style="display:flex;align-items:center;justify-content:space-between">
        Silence Trim
        <span style="display:flex;gap:6px;font-size:0.6rem">
          <span id="trimStartBtn" onclick="toggleTrimStart()" title="trim start" style="padding:2px 6px;border:1px solid var(--accent);color:var(--accent);border-radius:2px;cursor:pointer;opacity:1;transition:opacity 0.15s">S</span>
          <span id="trimEndBtn" onclick="toggleTrimEnd()" title="trim end" style="padding:2px 6px;border:1px solid var(--muted);color:var(--muted);border-radius:2px;cursor:pointer;opacity:0.4;transition:opacity 0.15s">E</span>
        </span>
      </h3>
      <div class="tone-control" style="width:100%">
        <div class="tone-row" style="gap:8px">
          <input type="range" id="silenceSlider" min="0" max="0.05" value="0" step="0.001" oninput="onSilenceChange()" style="width:100%">
        </div>
        <div style="display:flex;justify-content:space-between;margin-top:4px">
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">OFF</span>
          <span class="tone-val" id="silenceVal" style="font-size:0.8rem;min-width:unset">off</span>
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">0.050</span>
        </div>
        <div style="font-family:'Share Tech Mono',monospace;font-size:0.6rem;color:var(--muted);margin-top:6px;line-height:1.5">trims silence from start + end<br>raise until noise gets cut cleanly</div>
      </div>
    </div>
  </div>

  <div class="right-sidebar">
    <div class="right-sidebar-header">WORD LIST</div>
    <div class="word-list" id="wordList">
      <div class="no-reclist"><div class="big">&#9900;</div>load a reclist<br>to begin...</div>
    </div>
  </div>

  <div class="main-top">
    <div class="tone-control" style="flex:1">
      <label>TARGET TONE</label>
      <div class="tone-row">
        <div class="slider-pitch-wrap">
          <input type="range" id="toneSlider" min="80" max="800" value="220" oninput="onToneChange()">
          <div class="slider-pitch-line" id="sliderPitchLine"></div>
        </div>
        <span class="tone-val" id="toneVal">220 Hz</span>
        <select id="noteSelect" onchange="onNoteSelect()">
          <option value="82.41">E2 - 82 Hz</option><option value="87.31">F2 - 87 Hz</option>
          <option value="98.00">G2 - 98 Hz</option><option value="110.00">A2 - 110 Hz</option>
          <option value="130.81">C3 - 131 Hz</option><option value="146.83">D3 - 147 Hz</option>
          <option value="164.81">E3 - 165 Hz</option><option value="174.61">F3 - 175 Hz</option>
          <option value="196.00">G3 - 196 Hz</option><option value="220.00" selected>A3 - 220 Hz</option>
          <option value="261.63">C4 - 262 Hz</option><option value="293.66">D4 - 294 Hz</option>
          <option value="329.63">E4 - 330 Hz</option><option value="349.23">F4 - 349 Hz</option>
          <option value="392.00">G4 - 392 Hz</option><option value="440.00">A4 - 440 Hz</option>
          <option value="523.25">C5 - 523 Hz</option>
        </select>
        <button class="preview-btn" id="previewBtn"
          onmousedown="startPreviewTone()" onmouseup="stopPreviewTone()" onmouseleave="stopPreviewTone()"
          ontouchstart="startPreviewTone()" ontouchend="stopPreviewTone()">&#9834; PREVIEW</button>
      </div>
    </div>
  </div>

  <div class="main-content" id="mainContent">
    <div class="no-reclist" style="text-align:center">
      <div class="big">&#9900;</div>
      load a reclist.txt to start recording...<br>
      <span style="font-size:0.75rem">then hold the record key for each word</span>
    </div>
  </div>

  <div class="status-bar">
    <div class="status-item">WORDS: <span id="statusTotal">0</span></div>
    <div class="status-item">DONE: <span id="statusDone">0</span></div>
    <div class="status-item">TARGET: <span id="statusTone">220 Hz</span></div>
  </div>
</div>

<!-- MOBILE SETTINGS DRAWER -->
<div class="mob-settings-drawer" id="mobSettingsDrawer">
  <div class="mob-settings-scrim" onclick="closeMobSettings()"></div>
  <div class="mob-settings-panel">
    <div class="mob-settings-header">
      // SETTINGS //
      <button class="mob-settings-close" onclick="closeMobSettings()">&#x2715;</button>
    </div>
    <div class="sidebar-section">
      <h3>Setup</h3>
      <button class="btn primary" onclick="loadReclist();closeMobSettings()">&#9654; Load reclist.txt</button>
    </div>
    <div class="sidebar-section">
      <h3>Microphone</h3>
      <select id="micSelectMob" onchange="onMicChangeMob()" style="width:100%">
        <option value="">default mic</option>
      </select>
    </div>
    <div class="sidebar-section">
      <h3>Session</h3>
      <button class="btn" onclick="exportAll();closeMobSettings()">&#8659; Export WAV + oto.ini</button>
      <button class="btn danger" onclick="clearAll()">&#x2715; Clear recordings</button>
    </div>
    <div class="sidebar-section">
      <h3>Display</h3>
      <button class="btn" id="romajiToggleBtnMob" onclick="toggleRomaji()">Show Romaji: OFF</button>
      <button class="btn" id="autoAdvanceBtnMob" onclick="toggleAutoAdvance()" style="margin-top:6px">Auto-advance: ON</button>
      <button class="btn" id="hoverPlayBtnMob" onclick="toggleHoverPlay()" style="margin-top:6px">Hover Play: OFF</button>
    </div>
    <div class="sidebar-section">
      <h3>Target Tone</h3>
      <div class="tone-control" style="width:100%">
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
          <select id="noteSelectMob" onchange="onNoteSelectMob()" style="flex:1">
            <option value="82.41">E2 - 82 Hz</option><option value="87.31">F2 - 87 Hz</option>
            <option value="98.00">G2 - 98 Hz</option><option value="110.00">A2 - 110 Hz</option>
            <option value="130.81">C3 - 131 Hz</option><option value="146.83">D3 - 147 Hz</option>
            <option value="164.81">E3 - 165 Hz</option><option value="174.61">F3 - 175 Hz</option>
            <option value="196.00">G3 - 196 Hz</option><option value="220.00" selected>A3 - 220 Hz</option>
            <option value="261.63">C4 - 262 Hz</option><option value="293.66">D4 - 294 Hz</option>
            <option value="329.63">E4 - 330 Hz</option><option value="349.23">F4 - 349 Hz</option>
            <option value="392.00">G4 - 392 Hz</option><option value="440.00">A4 - 440 Hz</option>
            <option value="523.25">C5 - 523 Hz</option>
          </select>
          <button class="preview-btn"
            onmousedown="startPreviewTone()" onmouseup="stopPreviewTone()" onmouseleave="stopPreviewTone()"
            ontouchstart="startPreviewTone()" ontouchend="stopPreviewTone()">&#9834;</button>
        </div>
        <input type="range" id="toneSliderMob" min="80" max="800" value="220" oninput="onToneChangeMob()" style="width:100%">
        <div style="text-align:center;font-family:'Share Tech Mono',monospace;font-size:0.8rem;color:var(--accent);margin-top:4px" id="toneValMob">220 Hz</div>
      </div>
    </div>
    <div class="sidebar-section">
      <h3>Recording Offset</h3>
      <div class="tone-control" style="width:100%">
        <input type="range" id="recOffsetSliderMob" min="-300" max="300" value="0" step="10" oninput="onOffsetChangeMob()" style="width:100%">
        <div style="display:flex;justify-content:space-between;margin-top:4px">
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">-300ms</span>
          <span class="tone-val" id="recOffsetValMob" style="font-size:0.8rem;min-width:unset">0 ms</span>
          <span style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted)">+300ms</span>
        </div>
      </div>
    </div>
    <div class="sidebar-section">
      <h3 style="display:flex;align-items:center;justify-content:space-between">
        Silence Trim
        <span style="display:flex;gap:6px;font-size:0.6rem">
          <span id="trimStartBtnMob" onclick="toggleTrimStart()" title="trim start" style="padding:2px 6px;border:1px solid var(--accent);color:var(--accent);border-radius:2px;cursor:pointer;opacity:1;transition:opacity 0.15s">S</span>
          <span id="trimEndBtnMob" onclick="toggleTrimEnd()" title="trim end" style="padding:2px 6px;border:1px solid var(--muted);color:var(--muted);border-radius:2px;cursor:pointer;opacity:0.4;transition:opacity 0.15s">E</span>
        </span>
      </h3>
      <div class="tone-control" style="width:100%">
        <input type="range" id="silenceSliderMob" min="0" max="0.05" value="0" step="0.001" oninput="onSilenceChangeMob()" style="width:100%">
        <div style="text-align:center;font-family:'Share Tech Mono',monospace;font-size:0.8rem;color:var(--accent);margin-top:4px" id="silenceValMob">off</div>
      </div>
    </div>
  </div>
</div>

<!-- MOBILE WORD LIST TAB (bottom) -->
<div class="mob-word-tab" id="mobWordTab" onclick="toggleMobWordList()">
  <span>WORD LIST &nbsp;<span id="mobWordProgress">0 / 0</span></span>
  <span class="mob-word-tab-arrow">&#9650;</span>
</div>
<div class="mob-word-panel" id="mobWordPanel">
  <div class="mob-word-tab" style="position:relative;border-bottom:1px solid var(--border);border-top:none" onclick="toggleMobWordList()">
    <span>WORD LIST &nbsp;<span id="mobWordProgress2">0 / 0</span></span>
    <span class="mob-word-tab-arrow tab-open">&#9650;</span>
  </div>
  <div class="mob-word-list-wrap" id="mobWordList"></div>
</div>
<div class="modal-overlay" id="reclistModal">
  <div class="modal">
    <h2>// LOAD RECLIST //</h2>
    <p>load a reclist.txt — one entry per line, or space-separated. japanese (UTF-8) works fine.</p>
    <input type="file" id="reclistFile" accept=".txt,.reclist" style="display:none" onchange="readReclistFile(event)">
    <button class="modal-btn" onclick="document.getElementById('reclistFile').click()">browse file</button>
    <textarea id="reclistText" class="modal-input" style="width:100%;height:140px;margin-top:12px;resize:vertical;font-size:0.9rem" placeholder="あ い う え お&#10;か き く け こ&#10;or&#10;a&#10;i&#10;u&#10;..."></textarea>
    <div class="modal-row">
      <button class="modal-btn cancel" onclick="closeModal('reclistModal')">cancel</button>
      <button class="modal-btn" onclick="confirmReclist()">load</button>
    </div>
  </div>
</div>

<!-- EXPORT MODAL -->
<div class="modal-overlay" id="exportModal">
  <div class="modal">
    <h2>// EXPORT //</h2>
    <p id="exportMsg">name your voicebank and hit export.</p>
    <div style="margin-bottom:12px">
      <label style="font-family:'Share Tech Mono',monospace;font-size:0.65rem;color:var(--muted);letter-spacing:0.15em;display:block;margin-bottom:6px">VOICEBANK NAME</label>
      <input type="text" id="vbNameInput" class="modal-input" placeholder="MyVoicebank" style="width:100%">
      <div style="font-family:'Share Tech Mono',monospace;font-size:0.6rem;color:var(--muted);margin-top:6px">used for character.txt, character.yaml, and zip folder name</div>
    </div>
    <div id="exportProgressMsg" style="font-family:'Share Tech Mono',monospace;font-size:0.75rem;color:var(--accent3);margin-bottom:10px;display:none">generating .frq files...</div>
    <div class="modal-row">
      <button class="modal-btn" id="exportConfirmBtn" onclick="runExport()">&#8659; export</button>
      <button class="modal-btn" id="downloadZipBtn" style="display:none">download .zip</button>
      <button class="modal-btn cancel" onclick="closeModal('exportModal')">close</button>
    </div>
  </div>
</div>

<script>
// ---- STATE ----
let words = [], currentIdx = 0;
let recordingBlobs = {}, decodedBuffers = {};
let targetFreq = 220;
let audioCtx = null, mediaStream = null, mediaRecorder = null;
let isRecording = false, recordedChunks = [];
let alwaysOnSource = null, analyserNode = null;
let waveAnimId = null, pitchAnimId = null;
let previewOscillator = null, saveFolderHandle = null;
let recordKeyDown = false, currentPlaybackSource = null, isPlaying = false;
let pendingRecordTimeout = null;

let showRomaji = false;
let autoAdvance = true;
let recOffset = 0;

// ---- TRIM STATE ----
// originalBuffers stores the full uncut buffer before any trim edits
// trimRegions[word] = { startSamples, endSamples } — samples removed from each side
let originalBuffers = {};
let trimRegions = {}; // { startSamples: N, endSamples: N }
let manualTrimWords = new Set(); // words where user dragged a handle — slider won't override these
let silenceThreshold = 0;
let trimStart = true;
let trimEnd = false;
let recordKey = 'r'; // lowercase canonical key
let recordKeyLabel = 'R'; // display label
let bindingMode = false;
let micMuted = false;

function toggleMicMute() {
  micMuted = !micMuted;
  if (mediaStream) {
    mediaStream.getAudioTracks().forEach(t => t.enabled = !micMuted);
  }
  const dot = document.querySelector('.rec-dot');
  const ind = document.getElementById('recIndicator');
  if (dot) { dot.classList.toggle('muted', micMuted); dot.title = micMuted ? 'unmute mic' : 'mute mic'; }
  if (ind) { ind.classList.toggle('muted', micMuted); }
}

// ---- ROMAJI MAP ----
const romajiMap = {
  // vowels
  'あ':'a','い':'i','う':'u','え':'e','お':'o',
  // small vowels standalone
  'ぁ':'a','ぃ':'i','ぅ':'u','ぇ':'e','ぉ':'o',
  // k
  'か':'ka','き':'ki','く':'ku','け':'ke','こ':'ko',
  // s
  'さ':'sa','し':'shi','す':'su','せ':'se','そ':'so',
  // t
  'た':'ta','ち':'chi','つ':'tsu','て':'te','と':'to',
  // n
  'な':'na','に':'ni','ぬ':'nu','ね':'ne','の':'no',
  // h
  'は':'ha','ひ':'hi','ふ':'fu','へ':'he','ほ':'ho',
  // m
  'ま':'ma','み':'mi','む':'mu','め':'me','も':'mo',
  // y
  'や':'ya','ゆ':'yu','よ':'yo',
  // small y standalone
  'ゃ':'ya','ゅ':'yu','ょ':'yo',
  // r
  'ら':'ra','り':'ri','る':'ru','れ':'re','ろ':'ro',
  // w
  'わ':'wa','を':'wo','ん':'n',
  // voiced
  'が':'ga','ぎ':'gi','ぐ':'gu','げ':'ge','ご':'go',
  'ざ':'za','じ':'ji','ず':'zu','ぜ':'ze','ぞ':'zo',
  'だ':'da','ぢ':'ji','づ':'zu','で':'de','ど':'do',
  'ば':'ba','び':'bi','ぶ':'bu','べ':'be','ぼ':'bo',
  // p
  'ぱ':'pa','ぴ':'pi','ぷ':'pu','ぺ':'pe','ぽ':'po',
  // katakana vowels
  'ア':'a','イ':'i','ウ':'u','エ':'e','オ':'o',
  'ァ':'a','ィ':'i','ゥ':'u','ェ':'e','ォ':'o',
  // k
  'カ':'ka','キ':'ki','ク':'ku','ケ':'ke','コ':'ko',
  'ガ':'ga','ギ':'gi','グ':'gu','ゲ':'ge','ゴ':'go',
  // s
  'サ':'sa','シ':'shi','ス':'su','セ':'se','ソ':'so',
  'ザ':'za','ジ':'ji','ズ':'zu','ゼ':'ze','ゾ':'zo',
  // t
  'タ':'ta','チ':'chi','ツ':'tsu','テ':'te','ト':'to',
  'ダ':'da','ヂ':'ji','ヅ':'zu','デ':'de','ド':'do',
  // n
  'ナ':'na','ニ':'ni','ヌ':'nu','ネ':'ne','ノ':'no',
  // h
  'ハ':'ha','ヒ':'hi','フ':'fu','ヘ':'he','ホ':'ho',
  'バ':'ba','ビ':'bi','ブ':'bu','ベ':'be','ボ':'bo',
  'パ':'pa','ピ':'pi','プ':'pu','ペ':'pe','ポ':'po',
  // m
  'マ':'ma','ミ':'mi','ム':'mu','メ':'me','モ':'mo',
  // y
  'ヤ':'ya','ユ':'yu','ヨ':'yo',
  'ャ':'ya','ュ':'yu','ョ':'yo',
  // r
  'ラ':'ra','リ':'ri','ル':'ru','レ':'re','ロ':'ro',
  // w
  'ワ':'wa','ヲ':'wo','ン':'n',
  // v
  'ヴ':'v',
  // misc
  'っ':'っ','ッ':'ッ', // handled separately
};

// digraph combos: base consonant stem + small kana → romaji
const digraphMap = {
  // き/キ
  'きゃ':'kya','きゅ':'kyu','きょ':'kyo','きぇ':'kye','きぃ':'kyi',
  'ぎゃ':'gya','ぎゅ':'gyu','ぎょ':'gyo','ぎぇ':'gye',
  // し/シ
  'しゃ':'sha','しゅ':'shu','しょ':'sho','しぇ':'she','しぃ':'shi',
  'じゃ':'ja','じゅ':'ju','じょ':'jo','じぇ':'je',
  // ち/チ
  'ちゃ':'cha','ちゅ':'chu','ちょ':'cho','ちぇ':'che',
  // に/ニ
  'にゃ':'nya','にゅ':'nyu','にょ':'nyo','にぇ':'nye',
  // ひ/ヒ
  'ひゃ':'hya','ひゅ':'hyu','ひょ':'hyo','ひぇ':'hye',
  'びゃ':'bya','びゅ':'byu','びょ':'byo',
  'ぴゃ':'pya','ぴゅ':'pyu','ぴょ':'pyo','ぴぇ':'pye',
  // み/ミ
  'みゃ':'mya','みゅ':'myu','みょ':'myo','みぇ':'mye',
  // り/リ
  'りゃ':'rya','りゅ':'ryu','りょ':'ryo','りぇ':'rye',
  // て/で + small
  'てぃ':'ti','てゅ':'tyu','てぅ':'tyu',
  'でぃ':'di','でゅ':'dyu','でぅ':'dyu',
  // と/ど + small u
  'とぅ':'tu','どぅ':'du',
  // う + small vowels
  'うぁ':'wa','うぃ':'wi','うぇ':'we','うぉ':'wo',
  'うぅ':'wu',
  // ヴ combos
  'ヴぁ':'va','ヴぃ':'vi','ヴぇ':'ve','ヴぉ':'vo','ヴゅ':'vyu',
  // ふ + small
  'ふぁ':'fa','ふぃ':'fi','ふぇ':'fe','ふぉ':'fo','ふゅ':'fyu',
  // す/ず + small i
  'すぃ':'si','ずぃ':'zi',
  // おぁ
  'おぁ':'oa',
  // katakana digraphs
  'キャ':'kya','キュ':'kyu','キョ':'kyo','キェ':'kye',
  'ギャ':'gya','ギュ':'gyu','ギョ':'gyo',
  'シャ':'sha','シュ':'shu','ショ':'sho','シェ':'she',
  'ジャ':'ja','ジュ':'ju','ジョ':'jo','ジェ':'je',
  'チャ':'cha','チュ':'chu','チョ':'cho','チェ':'che',
  'ニャ':'nya','ニュ':'nyu','ニョ':'nyo',
  'ヒャ':'hya','ヒュ':'hyu','ヒョ':'hyo',
  'ビャ':'bya','ビュ':'byu','ビョ':'byo',
  'ピャ':'pya','ピュ':'pyu','ピョ':'pyo',
  'ミャ':'mya','ミュ':'myu','ミョ':'myo',
  'リャ':'rya','リュ':'ryu','リョ':'ryo',
  'ティ':'ti','テュ':'tyu','ディ':'di','デュ':'dyu',
  'トゥ':'tu','ドゥ':'du',
  'ファ':'fa','フィ':'fi','フェ':'fe','フォ':'fo','フュ':'fyu',
  'ヴァ':'va','ヴィ':'vi','ヴェ':'ve','ヴォ':'vo',
  'ウィ':'wi','ウェ':'we','ウォ':'wo',
};

const smallKana = new Set(['ゃ','ゅ','ょ','ぁ','ぃ','ぅ','ぇ','ぉ','ャ','ュ','ョ','ァ','ィ','ゥ','ェ','ォ']);

function toRomaji(text) {
  const chars = [...text]; // unicode-safe split
  let result = '';
  let i = 0;
  while (i < chars.length) {
    const c = chars[i];
    const next = chars[i + 1];
    // っ/ッ — double the next consonant
    if (c === 'っ' || c === 'ッ') {
      const nextRom = next ? toRomaji(next) : '';
      result += nextRom[0] || '';
      i++; continue;
    }
    // try digraph first
    if (next && smallKana.has(next)) {
      const digraph = digraphMap[c + next];
      if (digraph) { result += digraph; i += 2; continue; }
    }
    // single char
    result += romajiMap[c] || c;
    i++;
  }
  return result;
}

// replaces underscores with spaces for display/export. ga_wi_sa → ga wi sa
function displayName(w) { return w.replace(/_/g, ' '); }
// true if this entry is a multi-part sequence
function isSequence(w) { return w.includes('_'); }

// ---- AUDIO CTX ----
function getAudioCtx() { if (!audioCtx) audioCtx = new AudioContext(); return audioCtx; }

// ---- MIC PANIC ----
let micPanicTimeout = null;
let silenceCheckInterval = null;

function triggerMicPanic() {
  document.getElementById('micSelect')?.closest('.header-mic')?.classList.add('panic');
  document.querySelector('.mob-settings-btn')?.classList.add('panic');
}
function clearMicPanic() {
  document.getElementById('micSelect')?.closest('.header-mic')?.classList.remove('panic');
  document.querySelector('.mob-settings-btn')?.classList.remove('panic');
  if (micPanicTimeout) { clearTimeout(micPanicTimeout); micPanicTimeout = null; }
}

function startSilenceWatch() {
  if (silenceCheckInterval) return;
  let silentStreak = 0;
  silenceCheckInterval = setInterval(() => {
    if (!analyserNode) return;
    const buf = new Float32Array(analyserNode.fftSize);
    analyserNode.getFloatTimeDomainData(buf);
    let rms = 0;
    for (let i = 0; i < buf.length; i++) rms += buf[i] * buf[i];
    rms = Math.sqrt(rms / buf.length);
    if (rms < 0.0005) {
      silentStreak++;
      // 10 seconds of complete dead silence = something's actually wrong
      if (silentStreak >= 20) { triggerMicPanic(); }
    } else {
      silentStreak = 0;
      clearMicPanic();
    }
  }, 500);
}
function stopSilenceWatch() {
  if (silenceCheckInterval) { clearInterval(silenceCheckInterval); silenceCheckInterval = null; }
}

// ---- ALWAYS-ON MIC ----
// Call once after mic permission is granted. Keeps analyser alive permanently.
async function initAlwaysOnMic() {
  if (alwaysOnSource) return; // already init'd
  try {
    const ctx = getAudioCtx();
    const constraints = { audio: selectedDeviceId ? { deviceId: { exact: selectedDeviceId } } : true, video: false };
    if (!mediaStream) mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
    alwaysOnSource = ctx.createMediaStreamSource(mediaStream);
    analyserNode = ctx.createAnalyser(); analyserNode.fftSize = 2048;
    alwaysOnSource.connect(analyserNode);
    clearMicPanic();
    // populate mic list once we have permission
    populateMicList();
    // start live waveform + pitch if main UI is up
    if (words.length) { startWaveAndPitch(); startSilenceWatch(); }
  } catch(e) {
    console.warn('mic init failed:', e.message);
    triggerMicPanic();
  }
}

// ---- TOGGLES ----
function toggleRomaji() {
  showRomaji = !showRomaji;
  const btn = document.getElementById('romajiToggleBtn');
  if (btn) {
    btn.textContent = `Show Romaji: ${showRomaji ? 'ON' : 'OFF'}`;
    btn.className = showRomaji ? 'btn active-toggle' : 'btn';
  }
  renderWordList(); renderMain();
}

function toggleAutoAdvance() {
  autoAdvance = !autoAdvance;
  const btn = document.getElementById('autoAdvanceBtn');
  if (btn) {
    btn.textContent = `Auto-advance: ${autoAdvance ? 'ON' : 'OFF'}`;
    btn.className = autoAdvance ? 'btn active-toggle' : 'btn';
  }
}

// ---- HOVER PLAY ----
let hoverPlay = false;
let hoverPlayTimeout = null;
let hoverPlaySource = null;

function toggleHoverPlay() {
  hoverPlay = !hoverPlay;
  const btn = document.getElementById('hoverPlayBtn');
  const btnMob = document.getElementById('hoverPlayBtnMob');
  const label = `Hover Play: ${hoverPlay ? 'ON' : 'OFF'}`;
  if (btn) { btn.textContent = label; btn.style.borderColor = hoverPlay ? 'var(--accent)' : 'var(--border)'; btn.style.color = hoverPlay ? 'var(--accent)' : 'var(--muted)'; btn.style.background = hoverPlay ? 'rgba(0,255,204,0.08)' : 'var(--bg3)'; }
  if (btnMob) { btnMob.textContent = label; btnMob.className = hoverPlay ? 'btn active-toggle' : 'btn'; }
}

function onWordHover(i) {
  if (!hoverPlay) return;
  const w = words[i];
  if (!decodedBuffers[w]) return;
  // short delay so fast scrolling doesn't spam playback
  hoverPlayTimeout = setTimeout(() => {
    stopHoverPlay();
    const ctx = getAudioCtx();
    hoverPlaySource = ctx.createBufferSource();
    hoverPlaySource.buffer = decodedBuffers[w];
    hoverPlaySource.connect(ctx.destination);
    hoverPlaySource.start();
    hoverPlaySource.onended = () => { hoverPlaySource = null; };
  }, 120);
}

function onWordHoverEnd(i) {
  clearTimeout(hoverPlayTimeout);
  hoverPlayTimeout = null;
  stopHoverPlay();
}

function stopHoverPlay() {
  if (hoverPlaySource) {
    try { hoverPlaySource.stop(); } catch(e) {}
    hoverPlaySource = null;
  }
}

// ---- OFFSET ----
function onOffsetChange() {
  recOffset = parseInt(document.getElementById('recOffsetSlider').value);
  const el = document.getElementById('recOffsetVal');
  if (el) el.textContent = (recOffset > 0 ? '+' : '') + recOffset + ' ms';
}

function toggleTrimStart() {
  trimStart = !trimStart;
  const btn = document.getElementById('trimStartBtn');
  const btnM = document.getElementById('trimStartBtnMob');
  [btn, btnM].forEach(b => { if (!b) return; b.style.borderColor = trimStart ? 'var(--accent)' : 'var(--muted)'; b.style.color = trimStart ? 'var(--accent)' : 'var(--muted)'; b.style.opacity = trimStart ? '1' : '0.4'; });
  _applySilenceTrimToCurrentWord();
}
function toggleTrimEnd() {
  trimEnd = !trimEnd;
  const btn = document.getElementById('trimEndBtn');
  const btnM = document.getElementById('trimEndBtnMob');
  [btn, btnM].forEach(b => { if (!b) return; b.style.borderColor = trimEnd ? 'var(--accent)' : 'var(--muted)'; b.style.color = trimEnd ? 'var(--accent)' : 'var(--muted)'; b.style.opacity = trimEnd ? '1' : '0.4'; });
  _applySilenceTrimToCurrentWord();
}

function onSilenceChange() {
  silenceThreshold = parseFloat(document.getElementById('silenceSlider').value);
  const el = document.getElementById('silenceVal');
  if (el) el.textContent = silenceThreshold === 0 ? 'off' : silenceThreshold.toFixed(3);
  _applyGlobalSilenceTrim();
}

// Apply silence trim globally to all recorded words that aren't manually locked.
// Also refreshes the canvas if the current word is affected.
function _applyGlobalSilenceTrim() {
  let currentWordAffected = false;
  const w = words[currentIdx];
  for (const word of Object.keys(originalBuffers)) {
    if (manualTrimWords.has(word)) continue; // user set this manually — leave it alone
    trimRegions[word] = detectSilenceTrimRegion(originalBuffers[word], silenceThreshold);
    _applyTrim(word);
    if (word === w) currentWordAffected = true;
  }
  if (currentWordAffected) {
    _waveformCache = null;
    const canvas = (_livePlaybackCanvas && _livePlaybackCanvas.isConnected)
      ? _livePlaybackCanvas
      : document.getElementById('playbackCanvas');
    if (canvas) _repaint(canvas);
  }
}

// Single-word re-trim used by S/E toggle buttons (respects manual lock).
function _applySilenceTrimToCurrentWord() {
  const w = words[currentIdx]; if (!w) return;
  const src = originalBuffers[w]; if (!src) return;
  // S/E toggle always recomputes — clear manual lock for this word
  manualTrimWords.delete(w);
  trimRegions[w] = detectSilenceTrimRegion(src, silenceThreshold);
  _applyTrim(w);
  _waveformCache = null;
  const canvas = (_livePlaybackCanvas && _livePlaybackCanvas.isConnected)
    ? _livePlaybackCanvas
    : document.getElementById('playbackCanvas');
  if (!canvas) return;
  _repaint(canvas);
}

// Trim samples below threshold from both ends of an AudioBuffer.
// Uses a small look-ahead window so a single loud spike doesn't prematurely stop trimming.
// Returns { startSamples, endSamples } — samples to remove from each side.
// Does NOT slice the buffer. Zero means no trim on that side.
function detectSilenceTrimRegion(buffer, threshold) {
  const sr = buffer.sampleRate, len = buffer.length, nc = buffer.numberOfChannels;
  const WINDOW = Math.floor(sr * 0.005);

  const mono = new Float32Array(len);
  for (let ch = 0; ch < nc; ch++) {
    const data = buffer.getChannelData(ch);
    for (let i = 0; i < len; i++) mono[i] += Math.abs(data[i]);
  }
  for (let i = 0; i < len; i++) mono[i] /= nc;

  let start = 0;
  if (trimStart && threshold > 0) {
    for (let i = 0; i < len - WINDOW; i++) {
      let loud = false;
      for (let j = i; j < i + WINDOW; j++) { if (mono[j] > threshold) { loud = true; break; } }
      if (loud) { start = i; break; }
    }
  }

  let end = len;
  if (trimEnd && threshold > 0) {
    for (let i = len - 1; i >= WINDOW; i--) {
      let loud = false;
      for (let j = i; j > i - WINDOW; j--) { if (mono[j] > threshold) { loud = true; break; } }
      if (loud) { end = i + 1; break; }
    }
  }

  return { startSamples: start, endSamples: len - end };
}

// ---- DOWNLOAD CURRENT ----
function downloadCurrent() {
  const w = words[currentIdx];
  const blob = recordingBlobs[w]; if (!blob) return;
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = displayName(w) + '.wav'; a.click();
  setTimeout(() => URL.revokeObjectURL(url), 2000);
}

// ---- KEYBIND ----
function startBindingMode() {
  if (bindingMode) return;
  bindingMode = true;
  const keyEl = document.getElementById('recKeyDisplay');
  if (keyEl) { keyEl.textContent = '...'; keyEl.classList.add('binding'); }
}

function finishBinding(e) {
  if (!bindingMode) return;
  // ignore modifiers alone
  if (['Control','Shift','Alt','Meta','CapsLock','Tab','Escape'].includes(e.key)) return;
  bindingMode = false;
  recordKey = e.key.toLowerCase();
  recordKeyLabel = e.key.length === 1 ? e.key.toUpperCase() : e.key;
  const keyEl = document.getElementById('recKeyDisplay');
  if (keyEl) { keyEl.textContent = recordKeyLabel; keyEl.classList.remove('binding'); }
  e.preventDefault(); e.stopPropagation();
}

// ---- WORD LIST ----
function renderWordList() {
  const el = document.getElementById('wordList'); if (!el) return;
  if (!words.length) { el.innerHTML = '<div class="no-reclist"><div class="big">&#9900;</div>load a reclist.txt<br>to begin...</div>'; return; }
  el.innerHTML = words.map((w, i) => {
    const active = i === currentIdx, done = !!recordingBlobs[w];
    const dn = displayName(w);
    const seq = isSequence(w) ? `<span style="font-size:0.55rem;opacity:0.5;font-family:'Share Tech Mono',monospace;margin-left:4px;border:1px solid var(--muted);padding:1px 4px;border-radius:2px">SEQ</span>` : '';
    const displayWord = showRomaji ? `${dn} <span style="font-size:0.75em;opacity:0.6">(${toRomaji(dn)})</span>${seq}` : `${dn}${seq}`;
    const wave = done ? `<canvas class="word-mini-wave" data-word="${encodeURIComponent(w)}" height="16"></canvas>` : '';
    const wrapClass = `word-item-wrap${active?' active':''}${done?' done':''}`;
    return `<div class="${wrapClass}" onclick="selectWord(${i})" onmouseenter="onWordHover(${i})" onmouseleave="onWordHoverEnd(${i})" data-idx="${i}"><div class="word-item"><span>${displayWord}</span><span class="word-status">${done?'REC':''}</span></div>${wave}</div>`;
  }).join('');
  setTimeout(() => { const a = el.querySelector('.active'); if (a) a.scrollIntoView({ block: 'nearest' }); }, 0);
  requestAnimationFrame(() => el.querySelectorAll('.word-mini-wave').forEach(cv => paintMiniWave(cv)));
  if (mobWordOpen) renderMobWordList();
}

function paintMiniWave(cv) {
  const w = decodeURIComponent(cv.dataset.word);
  const buf = decodedBuffers[w];
  const W = Math.round(cv.getBoundingClientRect().width) || cv.offsetWidth || 240;
  const H = 14;
  cv.width = W; cv.height = H;
  const ctx2 = cv.getContext('2d');

  // subtle dark background so the bar is always visible
  ctx2.fillStyle = 'rgba(0,20,16,0.6)';
  ctx2.fillRect(0, 0, W, H);

  if (!buf) { cv.style.opacity = '0'; return; }

  const data = buf.getChannelData(0);
  const step = Math.max(1, Math.floor(data.length / W));

  // build per-column RMS
  const rms = new Float32Array(W);
  for (let x = 0; x < W; x++) {
    let sum = 0, count = 0;
    const start = x * step, end = Math.min(start + step, data.length);
    for (let j = start; j < end; j++) { sum += data[j] * data[j]; count++; }
    rms[x] = count ? Math.sqrt(sum / count) : 0;
  }

  // normalise
  let peak = 0;
  for (let x = 0; x < W; x++) if (rms[x] > peak) peak = rms[x];
  if (peak === 0) { cv.style.opacity = '1'; return; }

  const midY = H / 2;
  for (let x = 0; x < W; x++) {
    const norm = rms[x] / peak;            // 0..1
    const barH = Math.max(1, norm * (H - 2));
    const alpha = 0.12 + norm * 0.88;

    // green glow: dim for silence, bright accent for peaks
    const g = Math.round(100 + norm * 155);
    const b = Math.round(80  + norm * 124);
    ctx2.fillStyle = `rgba(0,${g},${b},${alpha.toFixed(2)})`;
    ctx2.fillRect(x, midY - barH / 2, 1, barH);

    // extra glow layer for loud sections
    if (norm > 0.45) {
      const glowAlpha = ((norm - 0.45) * 0.55).toFixed(2);
      ctx2.fillStyle = `rgba(0,255,204,${glowAlpha})`;
      ctx2.fillRect(x, midY - barH / 2, 1, barH);
    }
  }

  cv.style.opacity = '1';
}

// ---- MAIN UI ----
function renderMain() {
  _livePlaybackCanvas = null; // reset live ref; drawPlaybackWaveform will set it fresh
  if (!words.length) {
    document.getElementById('mainContent').innerHTML = `<div class="no-reclist" style="text-align:center"><div class="big">&#9900;</div>load a reclist.txt to start...<br><span style="font-size:0.75rem">hold the record key for each word</span></div>`;
    return;
  }
  const w = words[currentIdx], done = !!recordingBlobs[w];
  const pct = (Object.keys(recordingBlobs).length / words.length * 100).toFixed(0);
  const dn = displayName(w);
  const seqParts = isSequence(w) ? w.split('_') : null;
  const syllableCount = seqParts ? seqParts.length : 1;
  // Scale font size down for longer sequences to prevent overflow
  let fontSize;
  if (syllableCount <= 2) fontSize = '5rem';
  else if (syllableCount <= 3) fontSize = '4rem';
  else if (syllableCount <= 4) fontSize = '3.2rem';
  else if (syllableCount <= 6) fontSize = '2.5rem';
  else if (syllableCount <= 8) fontSize = '2rem';
  else fontSize = '1.5rem';

  const centerLabel = seqParts
    ? `<span class="seq-parts">${seqParts.map((p, i) => i < seqParts.length - 1 ? `<span style="white-space:nowrap">${p}</span><span class="seq-divider"></span>` : `<span style="white-space:nowrap">${p}</span>`).join('')}</span>`
    : w;
  const displayWord = showRomaji
    ? `${centerLabel}<div style="font-size:1.4rem;opacity:0.5;font-family:'Share Tech Mono',monospace;letter-spacing:0.1em;margin-top:4px">(${toRomaji(dn)})</div>`
    : centerLabel;

  document.getElementById('mainContent').innerHTML = `
    <div class="current-word ${done?'done-word':''}" id="currentWordEl" style="flex-direction:column;gap:4px;font-size:${fontSize}">${displayWord}</div>
    <canvas id="waveCanvas"></canvas>
    <div class="pitch-section">
      <div class="pitch-label">PITCH METER</div>
      <div class="pitch-meter">
        <div class="pitch-fill" id="pitchFill"></div>
        <div class="pitch-target-line" id="pitchTarget"></div>
      </div>
      <div class="pitch-info">
        <span class="pitch-current" id="pitchCurrent">-- Hz</span>
        <span class="pitch-target-label">target: ${targetFreq.toFixed(0)} Hz</span>
        <span class="pitch-offset" id="pitchOffset">--</span>
      </div>
    </div>
    ${done ? `<div class="playback-row">
      <button class="play-btn" id="playBtn" onclick="togglePlayback()">&#9654; LISTEN</button>
      <button class="play-btn" id="dlBtn" onclick="downloadCurrent()" style="border-color:var(--accent3);color:var(--accent3);background:rgba(255,204,0,0.06)">&#8659; DL</button>
      <canvas id="playbackCanvas"></canvas>
    </div>` : ''}
    <div style="display:flex;align-items:center;gap:20px;flex-wrap:wrap;justify-content:center">
      <div class="record-hint">
        <span class="key" id="recKeyDisplay" onclick="startBindingMode()" title="click to remap">${recordKeyLabel}</span>
        <span>${done ? 'hold to re-record' : 'hold to record'}</span>
      </div>
      <button class="mobile-rec-btn" id="mobileRecBtn">
        <div class="rec-ring"></div>
        HOLD
      </button>
      <div class="recording-indicator${micMuted?' muted':''}" id="recIndicator"><div class="rec-dot${micMuted?' muted':''}" onclick="toggleMicMute()" title="${micMuted?'unmute mic':'mute mic'}"></div>REC</div>
    </div>
    <div class="progress-bar-wrap">
      <div class="progress-bar"><div class="progress-fill" style="width:${pct}%"></div></div>
      <div class="progress-text">${Object.keys(recordingBlobs).length} / ${words.length}</div>
    </div>
    <div class="keys-hint">
      <span class="key">&#8593;</span><span class="key">&#8595;</span> prev/next &nbsp;
      <span class="key">&#8592;</span> first &nbsp;
      <span class="key">&#8594;</span> last &nbsp;
      <span class="key">SPACE</span> listen &nbsp;
      <span class="key" style="border-color:var(--accent);color:var(--accent)">${recordKeyLabel}</span> record
      &nbsp;<span style="opacity:0.5">(click key to remap)</span>
    </div>
  `;

  updatePitchTargetLine();
  if (done && decodedBuffers[w]) setTimeout(() => drawPlaybackWaveform(decodedBuffers[w]), 50);

  // always-on: restart wave/pitch display after re-render
  if (analyserNode) { cancelAnimationFrame(waveAnimId); cancelAnimationFrame(pitchAnimId); startWaveAndPitch(); }

  // mobile button touch events
  const mBtn = document.getElementById('mobileRecBtn');
  if (mBtn) {
    mBtn.addEventListener('touchstart', e => { e.preventDefault(); mBtn.classList.add('recording-active'); if (words.length) startRecording(); }, { passive: false });
    mBtn.addEventListener('touchend',   e => { e.preventDefault(); mBtn.classList.remove('recording-active'); if (isRecording) stopRecording(); }, { passive: false });
    mBtn.addEventListener('touchcancel',e => { e.preventDefault(); mBtn.classList.remove('recording-active'); if (isRecording) stopRecording(); }, { passive: false });
    // also support mouse for desktop testing
    mBtn.addEventListener('mousedown', e => { e.preventDefault(); if (words.length) startRecording(); });
    mBtn.addEventListener('mouseup',   e => { e.preventDefault(); if (isRecording) stopRecording(); });
  }
}

function updatePitchTargetLine() {
  const el = document.getElementById('pitchTarget'); if (!el) return;
  const pct = Math.max(0, Math.min(100, ((targetFreq - 50) / (1000 - 50)) * 100));
  el.style.left = pct + '%';
}

function selectWord(i) {
  stopPlayback();
  currentIdx = i;
  // Auto-apply current silence threshold to this word if it has audio and isn't manually locked
  const w = words[i];
  if (originalBuffers[w] && !manualTrimWords.has(w) && silenceThreshold > 0) {
    trimRegions[w] = detectSilenceTrimRegion(originalBuffers[w], silenceThreshold);
    _applyTrim(w);
  }
  renderWordList();
  renderMain();
}

// ---- TONE ----
function snapNoteSelect(freq) {
  const sel = document.getElementById('noteSelect');
  const selMob = document.getElementById('noteSelectMob');
  if (!sel) return;
  let closest = null, minDiff = Infinity;
  for (const opt of sel.options) {
    const diff = Math.abs(parseFloat(opt.value) - freq);
    if (diff < minDiff) { minDiff = diff; closest = opt.value; }
  }
  if (closest) { sel.value = closest; if (selMob) selMob.value = closest; }
}
function onToneChange() {
  targetFreq = parseFloat(document.getElementById('toneSlider').value);
  document.getElementById('toneVal').textContent = targetFreq.toFixed(0) + ' Hz';
  document.getElementById('statusTone').textContent = targetFreq.toFixed(0) + ' Hz';
  snapNoteSelect(targetFreq);
  const mob = document.getElementById('toneSliderMob'); if (mob) mob.value = targetFreq;
  const mobVal = document.getElementById('toneValMob'); if (mobVal) mobVal.textContent = targetFreq.toFixed(0) + ' Hz';
  updatePitchTargetLine();
}
function onNoteSelect() {
  const val = parseFloat(document.getElementById('noteSelect').value);
  document.getElementById('toneSlider').value = val; targetFreq = val;
  document.getElementById('toneVal').textContent = val.toFixed(0) + ' Hz';
  document.getElementById('statusTone').textContent = val.toFixed(0) + ' Hz';
  const mob = document.getElementById('toneSliderMob'); if (mob) mob.value = val;
  const mobVal = document.getElementById('toneValMob'); if (mobVal) mobVal.textContent = val.toFixed(0) + ' Hz';
  const selMob = document.getElementById('noteSelectMob'); if (selMob) selMob.value = val;
  updatePitchTargetLine();
}
function startPreviewTone() {
  if (previewOscillator) return; // already playing
  const ctx = getAudioCtx(), btn = document.getElementById('previewBtn');
  previewOscillator = ctx.createOscillator();
  const g = ctx.createGain();
  previewOscillator.frequency.value = targetFreq;
  previewOscillator.type = 'sine';
  g.gain.value = 0.2;
  previewOscillator.connect(g); g.connect(ctx.destination);
  previewOscillator.start();
  if (btn) { btn.classList.add('playing'); btn.textContent = '■ HOLD'; }
}
function stopPreviewTone() {
  if (!previewOscillator) return;
  try { previewOscillator.stop(); } catch(e) {}
  previewOscillator = null;
  const btn = document.getElementById('previewBtn');
  if (btn) { btn.classList.remove('playing'); btn.textContent = '♪ PREVIEW'; }
}

// ---- RECLIST ----
function loadReclist() { openModal('reclistModal'); }
function readReclistFile(e) {
  const file = e.target.files[0]; if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    const buffer = ev.target.result;
    let decoder = new TextDecoder('utf-8');
    let text = decoder.decode(buffer);
    if (text.includes('\uFFFD')) { decoder = new TextDecoder('shift-jis'); text = decoder.decode(buffer); }
    document.getElementById('reclistText').value = text;
  };
  reader.readAsArrayBuffer(file);
}
function confirmReclist() {
  const text = document.getElementById('reclistText').value.trim(); if (!text) return;
  words = [];
  for (const line of text.split('\n')) {
    const tokens = line.trim().split(/\s+/).filter(t => t.length > 0);
    words.push(...tokens);
  }
  recordingBlobs = {}; decodedBuffers = {}; currentIdx = 0;
  manualTrimWords.clear();
  closeModal('reclistModal');
  renderWordList(); renderMain(); updateStatus();
  // init always-on mic as soon as we have a reclist
  initAlwaysOnMic().then(() => { if (analyserNode) startSilenceWatch(); });
}

// ---- PLAYBACK ----
function togglePlayback() {
  if (isPlaying) { stopPlayback(); return; }
  const w = words[currentIdx], buf = decodedBuffers[w]; if (!buf) return;
  const ctx = getAudioCtx();
  currentPlaybackSource = ctx.createBufferSource();
  currentPlaybackSource.buffer = buf;
  currentPlaybackSource.connect(ctx.destination);
  currentPlaybackSource.start();
  isPlaying = true;
  const btn = document.getElementById('playBtn');
  if (btn) { btn.textContent = '■ STOP'; btn.classList.add('playing'); }
  currentPlaybackSource.onended = () => {
    isPlaying = false; currentPlaybackSource = null;
    const b = document.getElementById('playBtn');
    if (b) { b.textContent = '▶ LISTEN'; b.classList.remove('playing'); }
  };
}
function stopPlayback() {
  if (currentPlaybackSource) { try { currentPlaybackSource.stop(); } catch(e) {} currentPlaybackSource = null; }
  isPlaying = false;
  const btn = document.getElementById('playBtn');
  if (btn) { btn.textContent = '▶ LISTEN'; btn.classList.remove('playing'); }
}

// ---- TRIM EDITOR STATE ----
// trimDrag: null | { side: 'left'|'right' }
let trimDrag = null;
const HANDLE_HIT = 10; // px hit radius around each handle line

function drawPlaybackWaveform(buffer) {
  const canvas = document.getElementById('playbackCanvas'); if (!canvas) return;
  const W = canvas.offsetWidth || 500, H = 60;
  canvas.width = W; canvas.height = H;
  _livePlaybackCanvas = canvas; // will be updated again by _attachTrimListeners
  _repaint(canvas);
  _attachTrimListeners(canvas);
}

// Cached ImageData of just the waveform (no overlay) — reused during drag
let _waveformCache = null; // { imageData, word, W, H }
let _livePlaybackCanvas = null; // always points to the actual canvas in the DOM (post-clone)

// Full repaint: expensive waveform path + overlay. Call on init and mouse-up only.
function _repaint(canvas) {
  if (!canvas) return;
  const W = canvas.width, H = canvas.height;
  const w = words[currentIdx];
  const fullBuf = originalBuffers[w] || decodedBuffers[w]; if (!fullBuf) return;
  const ctx = canvas.getContext('2d');

  // --- draw background + waveform ---
  const data = fullBuf.getChannelData(0);
  const totalSamples = data.length;
  ctx.fillStyle = '#1a1a24';
  ctx.fillRect(0, 0, W, H);
  const step = Math.ceil(totalSamples / W);
  ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 1;
  ctx.shadowBlur = 4; ctx.shadowColor = '#00ffcc';
  ctx.beginPath();
  for (let i = 0; i < W; i++) {
    let mn = 1, mx = -1;
    for (let j = 0; j < step; j++) { const d = data[i * step + j] || 0; if (d < mn) mn = d; if (d > mx) mx = d; }
    ctx.moveTo(i + 0.5, ((1 + mn) / 2) * H);
    ctx.lineTo(i + 0.5, ((1 + mx) / 2) * H);
  }
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Cache the waveform pixels so drag overlay can restore them cheaply
  _waveformCache = { imageData: ctx.getImageData(0, 0, W, H), word: w, W, H };

  // draw overlay on top
  _repaintOverlay(canvas);
}

// Cheap overlay-only repaint: restores cached waveform pixels then draws red zones + handles.
// Called on every mousemove during drag — no waveform loop, just fillRect + lineTo.
function _repaintOverlay(canvas) {
  if (!canvas) return;
  const W = canvas.width, H = canvas.height;
  const ctx = canvas.getContext('2d');
  const w = words[currentIdx];
  const fullBuf = originalBuffers[w] || decodedBuffers[w]; if (!fullBuf) return;
  const totalSamples = fullBuf.getChannelData(0).length;
  const region = trimRegions[w] || { startSamples: 0, endSamples: 0 };
  const leftPx  = Math.round((region.startSamples / totalSamples) * W);
  const rightPx = W - Math.round((region.endSamples  / totalSamples) * W);

  // Restore cached waveform (avoids redrawing the expensive path)
  if (_waveformCache && _waveformCache.word === w && _waveformCache.W === W && _waveformCache.H === H) {
    ctx.putImageData(_waveformCache.imageData, 0, 0);
  } else {
    // Cache is stale — fall back to full repaint
    _repaint(canvas); return;
  }

  // Red overlay for trimmed zones
  if (leftPx > 0) {
    ctx.fillStyle = 'rgba(255,40,70,0.28)';
    ctx.fillRect(0, 0, leftPx, H);
  }
  if (rightPx < W) {
    ctx.fillStyle = 'rgba(255,40,70,0.28)';
    ctx.fillRect(rightPx, 0, W - rightPx, H);
  }

  // Handle lines — no shadowBlur here, too expensive per frame
  const drawHandle = (x, active) => {
    ctx.strokeStyle = active ? '#ff4060' : 'rgba(255,60,80,0.85)';
    ctx.lineWidth = active ? 3 : 2;
    ctx.beginPath();
    ctx.moveTo(x + 0.5, 0);
    ctx.lineTo(x + 0.5, H);
    ctx.stroke();
  };

  drawHandle(leftPx,  trimDrag && trimDrag.side === 'left');
  drawHandle(rightPx, trimDrag && trimDrag.side === 'right');
}

function _attachTrimListeners(canvas) {
  // clone to strip stale listeners, preserve id
  const fresh = canvas.cloneNode(false);
  fresh.id = canvas.id;
  canvas.parentNode.replaceChild(fresh, canvas);
  _livePlaybackCanvas = fresh; // keep a live reference so slider can repaint the right element

  // repaint onto the fresh clone (clone has same width/height attrs)
  _repaint(fresh);

  const getX = e => {
    const r = fresh.getBoundingClientRect();
    return (e.touches ? e.touches[0].clientX : e.clientX) - r.left;
  };

  const getCursorAndSide = ex => {
    const w = words[currentIdx];
    const fullBuf = originalBuffers[w] || decodedBuffers[w]; if (!fullBuf) return null;
    const totalSamples = fullBuf.getChannelData(0).length;
    const region = trimRegions[w] || { startSamples: 0, endSamples: 0 };
    const W = fresh.width;
    const lp = Math.round((region.startSamples / totalSamples) * W);
    const rp = W - Math.round((region.endSamples  / totalSamples) * W);
    if (Math.abs(ex - lp) <= HANDLE_HIT) return 'left';
    if (Math.abs(ex - rp) <= HANDLE_HIT) return 'right';
    return null;
  };

  // Single document-level mousemove — no double dispatch, rAF-throttled
  let _dragRafPending = false;
  let _dragLastX = 0;

  const onDocMove = e => {
    if (!trimDrag) {
      // cursor hint only when over the canvas
      if (e.target === fresh) {
        fresh.style.cursor = getCursorAndSide(getX(e)) ? 'ew-resize' : 'default';
      }
      return;
    }
    e.preventDefault();
    _dragLastX = getX(e);
    if (_dragRafPending) return; // skip if a frame is already queued
    _dragRafPending = true;
    requestAnimationFrame(() => {
      _dragRafPending = false;
      if (!trimDrag) return;
      const ex = _dragLastX;
      const w = words[currentIdx];
      const fullBuf = originalBuffers[w] || decodedBuffers[w]; if (!fullBuf) return;
      const totalSamples = fullBuf.getChannelData(0).length;
      const region = trimRegions[w] || { startSamples: 0, endSamples: 0 };
      const W = fresh.width;
      const lp = Math.round((region.startSamples / totalSamples) * W);
      const rp = W - Math.round((region.endSamples  / totalSamples) * W);
      if (trimDrag.side === 'left') {
        const cx = Math.max(0, Math.min(ex, rp - 2));
        trimRegions[w] = { ...region, startSamples: Math.round((cx / W) * totalSamples) };
      } else {
        const cx = Math.max(lp + 2, Math.min(ex, W));
        trimRegions[w] = { ...region, endSamples: Math.round(((W - cx) / W) * totalSamples) };
      }
      _repaintOverlay(fresh);
    });
  };
  document.addEventListener('mousemove', onDocMove);

  fresh.addEventListener('mousedown', e => {
    const side = getCursorAndSide(getX(e));
    if (!side) return;
    e.preventDefault();
    trimDrag = { side };
    fresh.style.cursor = 'ew-resize';
  });

  // Touch support for trim handles
  fresh.addEventListener('touchstart', e => {
    const side = getCursorAndSide(getX(e));
    if (!side) return;
    e.preventDefault();
    trimDrag = { side };
  }, { passive: false });

  document.addEventListener('touchmove', e => {
    if (!trimDrag) return;
    e.preventDefault();
    _dragLastX = getX(e);
    if (_dragRafPending) return;
    _dragRafPending = true;
    requestAnimationFrame(() => {
      _dragRafPending = false;
      if (!trimDrag) return;
      const ex = _dragLastX;
      const w = words[currentIdx];
      const fullBuf = originalBuffers[w] || decodedBuffers[w]; if (!fullBuf) return;
      const totalSamples = fullBuf.getChannelData(0).length;
      const region = trimRegions[w] || { startSamples: 0, endSamples: 0 };
      const W = fresh.width;
      const lp = Math.round((region.startSamples / totalSamples) * W);
      const rp = W - Math.round((region.endSamples  / totalSamples) * W);
      if (trimDrag.side === 'left') {
        const cx = Math.max(0, Math.min(ex, rp - 2));
        trimRegions[w] = { ...region, startSamples: Math.round((cx / W) * totalSamples) };
      } else {
        const cx = Math.max(lp + 2, Math.min(ex, W));
        trimRegions[w] = { ...region, endSamples: Math.round(((W - cx) / W) * totalSamples) };
      }
      _repaintOverlay(fresh);
    });
  }, { passive: false });

  const onUp = () => {
    if (!trimDrag) return;
    const w = words[currentIdx];
    manualTrimWords.add(w); // user explicitly set this — lock it from global slider
    _applyTrim(w);
    trimDrag = null;
    fresh.style.cursor = 'default';
    _waveformCache = null;
    _repaint(fresh);
  };

  fresh.addEventListener('mouseup', onUp);
  document.addEventListener('mouseup', onUp);
  document.addEventListener('touchend', onUp);
  document.addEventListener('touchcancel', onUp);
}

function _applyTrim(w) {
  const region = trimRegions[w];
  if (!region) return;

  // always work from the original full buffer so handles can restore audio
  if (!originalBuffers[w]) originalBuffers[w] = decodedBuffers[w];
  const src = originalBuffers[w];
  const totalSamples = src.length;
  const keepStart = Math.max(0, region.startSamples);
  const keepEnd   = Math.max(keepStart + 1, totalSamples - region.endSamples);
  const keepLen   = keepEnd - keepStart;

  const ctx = getAudioCtx();
  const trimmed = ctx.createBuffer(src.numberOfChannels, keepLen, src.sampleRate);
  for (let ch = 0; ch < src.numberOfChannels; ch++) {
    trimmed.copyToChannel(src.getChannelData(ch).slice(keepStart, keepEnd), ch);
  }

  decodedBuffers[w] = trimmed;
  recordingBlobs[w] = audioBufferToWavBlob(trimmed);

  // refresh mini waveform in the sidebar
  requestAnimationFrame(() => {
    const cvs = document.querySelectorAll(`.word-mini-wave[data-word="${encodeURIComponent(w)}"]`);
    cvs.forEach(cv => paintMiniWave(cv));
  });
}


async function startRecording() {
  if (!words.length || isRecording) return;
  stopPlayback();

  // ensure mic is up (first press might need permission)
  if (!mediaStream) await initAlwaysOnMic();
  if (!mediaStream) return; // permission denied

  isRecording = true;

  const doStart = () => {
    pendingRecordTimeout = null;
    if (!isRecording) return;
    // Clear countdown colour
    const wordEl2 = document.getElementById('currentWordEl');
    if (wordEl2) { wordEl2.style.color = ''; wordEl2.style.transition = ''; }
    recordedChunks = [];
    // analyserNode is always alive — just hook recorder to the existing stream
    mediaRecorder = new MediaRecorder(mediaStream);
    mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
    mediaRecorder.onstop = processRecording;
    mediaRecorder.start();
    document.getElementById('currentWordEl')?.classList.add('recording');
    const ind = document.getElementById('recIndicator');
    if (ind) { ind.classList.add('active'); ind.style.opacity = ''; }
  };

  if (recOffset > 0) {
    const ind = document.getElementById('recIndicator');
    if (ind) { ind.classList.add('active'); ind.style.opacity = '0.35'; }
    // Show countdown on the word element
    const wordEl = document.getElementById('currentWordEl');
    if (wordEl) { wordEl.style.transition = 'color 0.1s'; wordEl.style.color = 'var(--accent3)'; }
    pendingRecordTimeout = setTimeout(doStart, recOffset);
  } else {
    doStart();
  }
}

function stopRecording() {
  if (!isRecording) return;
  isRecording = false;

  if (pendingRecordTimeout !== null) {
    clearTimeout(pendingRecordTimeout);
    pendingRecordTimeout = null;
    const ind = document.getElementById('recIndicator');
    if (ind) {
      ind.classList.remove('active');
      ind.style.opacity = '';
      // Flash a brief "cancelled" hint
      const wordEl = document.getElementById('currentWordEl');
      if (wordEl) {
        wordEl.style.transition = 'color 0.1s';
        wordEl.style.color = 'var(--warn)';
        setTimeout(() => { wordEl.style.color = ''; wordEl.style.transition = ''; }, 350);
      }
    }
    return;
  }

  if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
  const ind = document.getElementById('recIndicator');
  if (ind) { ind.classList.remove('active'); ind.style.opacity = ''; }
  document.getElementById('currentWordEl')?.classList.remove('recording');
}

function processRecording() {
  const blob = new Blob(recordedChunks, { type: 'audio/webm' }), w = words[currentIdx];
  const reader = new FileReader();
  reader.onload = async ev => {
    const ctx = getAudioCtx();
    try {
      let decoded = await ctx.decodeAudioData(ev.target.result.slice(0));
      if (recOffset < 0) {
        const trimSamples = Math.floor(Math.abs(recOffset) / 1000 * decoded.sampleRate);
        const keepSamples = Math.max(0, decoded.length - trimSamples);
        if (keepSamples > 0) {
          const trimmed = ctx.createBuffer(decoded.numberOfChannels, keepSamples, decoded.sampleRate);
          for (let ch = 0; ch < decoded.numberOfChannels; ch++)
            trimmed.copyToChannel(decoded.getChannelData(ch).slice(trimSamples), ch);
          decoded = trimmed;
        }
      }
      // Store raw audio as the original — silence trim becomes trim region, not a destructive cut
      originalBuffers[w] = decoded;
      manualTrimWords.delete(w); // fresh recording resets any manual lock
      _waveformCache = null;
      // Compute silence trim as a region (visible in UI, user-adjustable)
      trimRegions[w] = detectSilenceTrimRegion(decoded, silenceThreshold);
      // Apply it to produce the working buffer + blob
      _applyTrim(w);
      decodedBuffers[w] = decodedBuffers[w] || decoded; // fallback if _applyTrim didn't set it
    } catch(e) { recordingBlobs[w] = blob; }

    renderWordList(); updateStatus();

    if (autoAdvance && currentIdx < words.length - 1) {
      currentIdx++;
    } else if (Object.keys(recordingBlobs).length === words.length) {
      // All done! Brief celebration glow on the progress bar
      setTimeout(() => {
        const fill = document.querySelector('.progress-fill');
        if (fill) {
          fill.style.transition = 'box-shadow 0.3s';
          fill.style.boxShadow = '0 0 24px var(--accent), 0 0 48px rgba(0,255,204,0.5)';
          setTimeout(() => { fill.style.boxShadow = ''; fill.style.transition = ''; }, 1200);
        }
      }, 100);
    }
    renderMain();
  };
  reader.readAsArrayBuffer(blob);
}

// ---- WAVEFORM ----
function startWaveAndPitch() { drawWave(); detectPitch(); }
function drawWave() {
  const canvas = document.getElementById('waveCanvas'); if (!canvas || !analyserNode) return;
  const ctx2d = canvas.getContext('2d');
  canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight;
  const bufLen = analyserNode.frequencyBinCount, dataArr = new Uint8Array(bufLen);
  function draw() {
    if (!analyserNode || !document.getElementById('waveCanvas')) { cancelAnimationFrame(waveAnimId); return; }
    waveAnimId = requestAnimationFrame(draw);
    analyserNode.getByteTimeDomainData(dataArr);
    ctx2d.fillStyle = '#1a1a24'; ctx2d.fillRect(0, 0, canvas.width, canvas.height);
    ctx2d.lineWidth = 1.5; ctx2d.strokeStyle = '#00ffcc'; ctx2d.shadowBlur = 6; ctx2d.shadowColor = '#00ffcc';
    ctx2d.beginPath();
    const sliceW = canvas.width / bufLen; let x = 0;
    for (let i = 0; i < bufLen; i++) {
      const y = (dataArr[i] / 128.0 * canvas.height) / 2;
      i === 0 ? ctx2d.moveTo(x, y) : ctx2d.lineTo(x, y); x += sliceW;
    }
    ctx2d.stroke();
  }
  draw();
}

// ---- PITCH ----
function detectPitch() {
  if (!analyserNode) return;
  const buf = new Float32Array(analyserNode.fftSize), sr = getAudioCtx().sampleRate;
  function detect() {
    if (!analyserNode || !document.getElementById('pitchFill')) { cancelAnimationFrame(pitchAnimId); return; }
    pitchAnimId = requestAnimationFrame(detect);
    analyserNode.getFloatTimeDomainData(buf);
    updatePitchUI(autoCorrelate(buf, sr));
  }
  detect();
}
function autoCorrelate(buf, sr) {
  let SIZE = buf.length, rms = 0;
  for (let i = 0; i < SIZE; i++) rms += buf[i]*buf[i];
  rms = Math.sqrt(rms/SIZE); if (rms < 0.01) return -1;
  let r1=0, r2=SIZE-1;
  for (let i=0;i<SIZE/2;i++) if(Math.abs(buf[i])<0.2){r1=i;break;}
  for (let i=1;i<SIZE/2;i++) if(Math.abs(buf[SIZE-i])<0.2){r2=SIZE-i;break;}
  buf=buf.slice(r1,r2); SIZE=buf.length;
  const c=new Array(SIZE).fill(0);
  for(let i=0;i<SIZE;i++) for(let j=0;j<SIZE-i;j++) c[i]+=buf[j]*buf[j+i];
  let d=0; while(c[d]>c[d+1])d++;
  let maxval=-1,maxpos=-1;
  for(let i=d;i<SIZE;i++) if(c[i]>maxval){maxval=c[i];maxpos=i;}
  let T0=maxpos;
  const x1=c[T0-1],x2=c[T0],x3=c[T0+1],a=(x1+x3-2*x2)/2,b=(x3-x1)/2;
  if(a) T0-=b/(2*a);
  return sr/T0;
}
function updatePitchUI(freq) {
  const fillEl=document.getElementById('pitchFill'),curEl=document.getElementById('pitchCurrent'),offEl=document.getElementById('pitchOffset');
  const lineEl=document.getElementById('sliderPitchLine');
  if(!fillEl) return;
  if(freq<0){
    fillEl.style.width='0%';curEl.textContent='-- Hz';offEl.textContent='--';offEl.className='pitch-offset';
    if(lineEl) lineEl.classList.remove('visible');
    return;
  }
  fillEl.style.width=Math.max(0,Math.min(100,((freq-50)/950)*100))+'%';
  curEl.textContent=freq.toFixed(1)+' Hz';
  const cents=1200*Math.log2(freq/targetFreq),abs=Math.abs(cents);
  offEl.textContent=(cents>0?'+':'')+cents.toFixed(0)+' cents';
  offEl.className=abs<30?'pitch-offset good':abs<80?'pitch-offset warn':'pitch-offset bad';
  // update slider pitch line
  if(lineEl) {
    const slider = document.getElementById('toneSlider');
    if(slider) {
      const min=80, max=800;
      const clampedFreq = Math.max(min, Math.min(max, freq));
      const pct = (clampedFreq - min) / (max - min);
      const w = slider.offsetWidth;
      // account for thumb width (~14px) so it lines up with the track
      const thumbR = 7;
      const trackPx = w - thumbR * 2;
      lineEl.style.left = (thumbR + pct * trackPx - 1) + 'px';
      lineEl.classList.add('visible');
    }
  }
}

// ---- KEYBOARD ----
document.addEventListener('keydown', e => {
  // keybind capture mode
  if (bindingMode) { finishBinding(e); return; }
  if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;

  if (e.key.toLowerCase() === recordKey && !recordKeyDown) {
    recordKeyDown = true;
    if (words.length) startRecording();
    // init mic early on first ever keypress even before reclist loaded
    if (!mediaStream) initAlwaysOnMic();
  }
  const _navTo = idx => {
    stopPlayback(); currentIdx = idx;
    const w = words[currentIdx];
    if (originalBuffers[w] && !manualTrimWords.has(w) && silenceThreshold > 0) {
      trimRegions[w] = detectSilenceTrimRegion(originalBuffers[w], silenceThreshold);
      _applyTrim(w);
    }
    renderWordList(); renderMain();
  };
  if (e.key === 'ArrowUp'    && currentIdx > 0)               { e.preventDefault(); _navTo(currentIdx - 1); }
  if (e.key === 'ArrowDown'  && currentIdx < words.length - 1) { e.preventDefault(); _navTo(currentIdx + 1); }
  if (e.key === 'ArrowLeft'  && words.length)                  { e.preventDefault(); _navTo(0); }
  if (e.key === 'ArrowRight' && words.length)                  { e.preventDefault(); _navTo(words.length - 1); }
  if (e.key === ' ') { e.preventDefault(); if (recordingBlobs[words[currentIdx]]) togglePlayback(); }
});
document.addEventListener('keyup', e => {
  if (bindingMode) return;
  if (e.key.toLowerCase() === recordKey) { recordKeyDown = false; if (isRecording) stopRecording(); }
});

// ---- MIC SELECTION ----
let selectedDeviceId = '';

async function populateMicList() {
  try {
    // need permission first so labels show up
    await navigator.mediaDevices.getUserMedia({ audio: true });
    const devices = await navigator.mediaDevices.enumerateDevices();
    const mics = devices.filter(d => d.kind === 'audioinput');
    const sel = document.getElementById('micSelect');
    if (!sel) return;
    sel.innerHTML = '<option value="">default mic</option>';
    mics.forEach(d => {
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = d.label || `mic ${d.deviceId.slice(0,6)}`;
      if (d.deviceId === selectedDeviceId) opt.selected = true;
      sel.appendChild(opt);
    });
  } catch(e) { console.warn('mic enum failed:', e.message); }
}

async function onMicChange() {
  const sel = document.getElementById('micSelect');
  selectedDeviceId = sel ? sel.value : '';
  // tear down existing stream so next initAlwaysOnMic picks new device
  stopSilenceWatch();
  clearMicPanic();
  if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }
  if (alwaysOnSource) { try { alwaysOnSource.disconnect(); } catch(e) {} alwaysOnSource = null; }
  cancelAnimationFrame(waveAnimId); cancelAnimationFrame(pitchAnimId);
  await initAlwaysOnMic();
  if (analyserNode && words.length) startSilenceWatch();
}

// ---- FRQ GENERATION ----
// Generates a UTAU-compatible .frq binary from an AudioBuffer using autocorrelation pitch detection.
function generateFrqBinary(audioBuffer) {
  const HOP = 256;
  const sr = audioBuffer.sampleRate;
  const rawData = audioBuffer.getChannelData(0); // mono
  const nFrames = audioBuffer.length;
  const nPoints = Math.floor(nFrames / HOP);

  const freqs = [];
  for (let i = 0; i < nPoints; i++) {
    const start = i * HOP;
    const frame = rawData.slice(start, start + HOP * 4); // use 4 hops for autocorrelation window
    const f = autoCorrelateBuffer(frame, sr);
    freqs.push(f > 0 ? f : 0.0);
  }

  const valid = freqs.filter(f => f > 0);
  const avgPitch = valid.length ? valid.reduce((a, b) => a + b, 0) / valid.length : 0.0;

  // Build binary: FREQ0003 header + hop(int32) + avgPitch(float64) + 16 null bytes + count(int32) + [freq(f64), amp(f64)]...
  const headerStr = 'FREQ0003';
  const totalDoubles = freqs.length * 2;
  const byteLen = 8 + 4 + 8 + 16 + 4 + totalDoubles * 8;
  const buf = new ArrayBuffer(byteLen);
  const view = new DataView(buf);
  let off = 0;

  for (let i = 0; i < 8; i++) { view.setUint8(off++, headerStr.charCodeAt(i)); }
  view.setInt32(off, HOP, true); off += 4;
  view.setFloat64(off, avgPitch, true); off += 8;
  for (let i = 0; i < 16; i++) { view.setUint8(off++, 0); }
  view.setInt32(off, freqs.length, true); off += 4;
  for (const f of freqs) {
    view.setFloat64(off, f, true); off += 8;
    view.setFloat64(off, 0.0, true); off += 8;
  }
  return buf;
}

function autoCorrelateBuffer(buf, sr) {
  let SIZE = buf.length;
  let rms = 0;
  for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
  rms = Math.sqrt(rms / SIZE);
  if (rms < 0.01) return -1;

  let r1 = 0, r2 = SIZE - 1;
  for (let i = 0; i < SIZE / 2; i++) { if (Math.abs(buf[i]) < 0.2) { r1 = i; break; } }
  for (let i = 1; i < SIZE / 2; i++) { if (Math.abs(buf[SIZE - i]) < 0.2) { r2 = SIZE - i; break; } }
  buf = buf.slice(r1, r2); SIZE = buf.length;
  if (SIZE < 2) return -1;

  const c = new Array(SIZE).fill(0);
  for (let i = 0; i < SIZE; i++) for (let j = 0; j < SIZE - i; j++) c[i] += buf[j] * buf[j + i];
  let d = 0;
  while (d < SIZE - 1 && c[d] > c[d + 1]) d++;
  let maxval = -1, maxpos = -1;
  for (let i = d; i < SIZE; i++) { if (c[i] > maxval) { maxval = c[i]; maxpos = i; } }
  if (maxpos <= 0 || maxpos >= SIZE - 1) return -1;
  let T0 = maxpos;
  const x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1], a = (x1 + x3 - 2 * x2) / 2, b = (x3 - x1) / 2;
  if (a) T0 -= b / (2 * a);
  const freq = sr / T0;
  return (freq >= 55 && freq <= 1000) ? freq : 0.0;
}

// ---- EXPORT ----
async function exportAll() {
  if (!Object.keys(recordingBlobs).length) { alert('no recordings yet... hold the record key first.'); return; }
  // reset modal state
  document.getElementById('exportMsg').textContent = 'name your voicebank and hit export.';
  document.getElementById('exportProgressMsg').style.display = 'none';
  document.getElementById('exportConfirmBtn').style.display = '';
  document.getElementById('downloadZipBtn').style.display = 'none';
  document.getElementById('vbNameInput').value = '';
  openModal('exportModal');
}

function analyzeAudioForOto(buffer) {
    const data = buffer.getChannelData(0);
    const sr = buffer.sampleRate;
    const totalMs = (data.length / sr) * 1000;

    // 1. Detect Sound Start (Offset)
    const startThreshold = 0.015;
    let startSample = 0;
    for (let i = 0; i < data.length; i++) {
        if (Math.abs(data[i]) >= startThreshold) {
            startSample = i;
            break;
        }
    }

    // 2. Detect Sound End (Cutoff calculation)
    const endThreshold = 0.01;
    let endSample = data.length - 1;
    for (let i = data.length - 1; i > startSample; i--) {
        if (Math.abs(data[i]) >= endThreshold) {
            endSample = i;
            break;
        }
    }

    const startMs = (startSample / sr) * 1000;
    const endMs = (endSample / sr) * 1000;

    // 3. Detect Vowel Start (Preutterance)
    const winSamples = Math.round(sr * 0.010);
    const stepSamples = Math.round(sr * 0.005);
    let vowelStartMs = startMs;

    for (let i = startSample; i < endSample - winSamples; i += stepSamples) {
        let e = 0;
        for (let j = i; j < i + winSamples; j++) e += data[j] * data[j];
        if ((e / winSamples) > 0.05) {
            vowelStartMs = (i / sr) * 1000;
            break;
        }
    }

    // --- UTAU PARAMETER CALCULATION ---
    // Preutterance: Timing where the vowel starts relative to the offset
    const preutter = Math.max(10, Math.round(vowelStartMs - startMs));

    // FIX: Consonant (Fixed) MUST be greater than Preutterance.
    // Adding 50ms ensures the start of the vowel is never stretched or "buzzy".
    const consonant = preutter + 50;

    // FIX: Using a negative cutoff (ms from the end of the file)
    const cutoff = -Math.round(totalMs - endMs);

    return {
        offset: Math.round(startMs),
        consonant: consonant,
        cutoff: cutoff,
        preutter: preutter,
        overlap: Math.round(preutter * 0.5) // Initial guess for overlap
    };
}

// FIX: Ensure the export function uses these specific values
async function runExport() {
    const zip = new JSZip();
    let otoLines = [];
    const entries = Object.entries(recordedBlobs);

    for (let idx = 0; idx < entries.length; idx++) {
        const [word, blob] = entries[idx];
        const dn = word; // Use your existing displayName logic here
        const fname = '_' + dn;
        const alias = dn.trim();

        // Convert blob to buffer for analysis
        const arrayBuffer = await blob.arrayBuffer();
        const audioBuf = await audioCtx.decodeAudioData(arrayBuffer);
        const oto = analyzeAudioForOto(audioBuf);

        // Apply smooth overlap (30ms) for standalone vowels
        const vowels = ['あ','い','う','え','お','ア','イ','ウ','エ','オ','a','i','u','e','o'];
        let finalOverlap = vowels.includes(alias) ? 30 : oto.overlap;

        // CORRECT OTO FORMAT: filename=alias,offset,consonant,cutoff,preutterance,overlap
        const line = `${fname}.wav=${alias},${oto.offset},${oto.consonant},${oto.cutoff},${oto.preutter},${finalOverlap}`;
        otoLines.push(line);

        // Add wav to zip
        zip.file(`${fname}.wav`, blob);
    }

    // Add oto.ini to zip
    zip.file("oto.ini", otoLines.join("\r\n"));

    const content = await zip.generateAsync({type:"blob"});
    saveAs(content, "voicebank_export.zip");
}

// Update the export loop to handle aliases and specific overlap for vowels
async function runExport() {
    /* ... existing JSZip setup code ... */

    for (let idx = 0; idx < entries.length; idx++) {
        const [word, blob] = entries[idx];
        const dn = displayName(word);
        const fname = '_' + dn;
        const alias = dn.replace(/\s+/g, '');

        let audioBuf = decodedBuffers[word];
        const oto = analyzeAudioForOto(audioBuf);

        // FIX: Adjust overlap if the alias is a standalone vowel
        const vowels = ['あ','い','う','え','お','ア','イ','ウ','エ','オ','a','i','u','e','o'];
        let finalOverlap = oto.overlap;
        if (vowels.includes(alias)) {
            finalOverlap = 30; // Standard smooth overlap for vowels
        }

        // CORRECT FORMAT: filename=alias,offset,consonant,cutoff,preutterance,overlap
        otoLines.push(`${fname}.wav=${alias},${oto.offset},${oto.consonant},${oto.cutoff},${oto.preutter},${finalOverlap}`);
    }
    /* ... rest of your saveAs(content) logic ... */
}

async function runExport() {
  const vbName = (document.getElementById('vbNameInput')?.value.trim() || 'MyVoicebank').replace(/[\\/:*?"<>|]/g, '_');

  document.getElementById('exportConfirmBtn').style.display = 'none';
  document.getElementById('exportMsg').textContent = 'building...';
  document.getElementById('exportProgressMsg').style.display = 'block';
  document.getElementById('exportProgressMsg').textContent = 'loading...';

  if (!document.querySelector('script[src*="jszip"]')) {
    const s = document.createElement('script'); s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js'; document.head.appendChild(s);
    await new Promise(res => s.onload = res);
  }

  const zip = new JSZip();
  const folder = zip.folder(vbName);
  const otoLines = [];
  const entries = Object.entries(recordingBlobs);

  document.getElementById('exportProgressMsg').textContent = `generating .frq files (0 / ${entries.length})...`;

  const ctx = getAudioCtx();

  for (let idx = 0; idx < entries.length; idx++) {
    const [word, blob] = entries[idx];
    const dn = displayName(word);
    const fname = '_' + dn;

    // wav
    folder.file(fname + '.wav', await blob.arrayBuffer());

    // oto.ini line — calculate values from actual clip duration
    const alias = dn.replace(/\s+/g, '');
    let audioBuf = decodedBuffers[word];
    if (!audioBuf) {
      const ab = await blob.arrayBuffer();
      audioBuf = await ctx.decodeAudioData(ab.slice(0));
      decodedBuffers[word] = audioBuf;
    }
    const oto = analyzeAudioForOto(audioBuf);
    otoLines.push(`${fname}.wav=${alias},${oto.offset},${oto.consonant},${oto.cutoff},${oto.preutter},${oto.overlap}`);

    // .frq
    try {
      const frqBinary = generateFrqBinary(audioBuf);
      folder.file(fname + '.wav.frq', frqBinary);
    } catch(e) {
      console.warn('frq gen failed for', word, e);
    }

    document.getElementById('exportProgressMsg').textContent = `generating .frq files (${idx + 1} / ${entries.length})...`;
    if (idx % 5 === 0) await new Promise(r => setTimeout(r, 0));
  }

  // oto.ini (UTF-8 with BOM)
  folder.file('oto.ini', '\uFEFF' + otoLines.join('\r\n'));
  folder.file('character.txt', `name=${vbName}\r\n`);
  folder.file('character.yaml',
    `name: ${vbName}\r\ntext_file_encoding: utf-8\r\nportrait_opacity: 0.67\r\nportrait_height: 0\r\n`
  );

  document.getElementById('exportProgressMsg').style.display = 'none';
  document.getElementById('exportMsg').textContent = `${entries.length} wavs + frq files + oto.ini + character files ready.`;

  // encodeFileName: encode as UTF-8 bytes so JSZip sets the UTF-8 language
  // encoding flag (bit 11) in every local file header. Without this flag,
  // apps like OpenUtau fall back to CP437/Latin and Japanese chars get mangled.
  const utf8Enc = new TextEncoder();
  const content = await zip.generateAsync({
    type: 'blob',
    encodeFileName: s => utf8Enc.encode(s)
  });
  const url = URL.createObjectURL(content);
  const dlBtn = document.getElementById('downloadZipBtn');
  dlBtn.style.display = '';
  dlBtn.innerHTML = '&#8659; download .zip';
  dlBtn.onclick = () => {
    const a = document.createElement('a');
    a.href = url; a.download = vbName + '.zip'; a.click();
  };
}

// ---- CLEAR ----
function clearAll() {
  if (!confirm('clear all recordings? ...you sure?')) return;
  recordingBlobs = {}; decodedBuffers = {}; originalBuffers = {}; trimRegions = {}; manualTrimWords.clear(); stopPlayback(); renderWordList(); renderMain(); updateStatus();
}

function updateStatus() {
  document.getElementById('statusTotal').textContent = words.length;
  document.getElementById('statusDone').textContent = Object.keys(recordingBlobs).length;
  // update document title with progress
  const done = Object.keys(recordingBlobs).length;
  const total = words.length;
  if (total > 0) {
    const pct = Math.round(done / total * 100);
    document.title = `BONEMO [${pct}% — ${done}/${total}]`;
  } else {
    document.title = 'BONEMO - Voice Recording Studio';
  }
  // update mobile word tab progress
  const prog = `${Object.keys(recordingBlobs).length} / ${words.length}`;
  const p1 = document.getElementById('mobWordProgress'); if (p1) p1.textContent = prog;
  const p2 = document.getElementById('mobWordProgress2'); if (p2) p2.textContent = prog;
  renderMobWordList();
}
function openModal(id) { document.getElementById(id).classList.add('show'); }
function closeModal(id) { document.getElementById(id).classList.remove('show'); }

// ---- MOBILE SETTINGS DRAWER ----
function openMobSettings() { document.getElementById('mobSettingsDrawer').classList.add('open'); }
function closeMobSettings() { document.getElementById('mobSettingsDrawer').classList.remove('open'); }

// ---- MOBILE WORD LIST ----
let mobWordOpen = false;
function toggleMobWordList() {
  mobWordOpen = !mobWordOpen;
  const panel = document.getElementById('mobWordPanel');
  const tab = document.getElementById('mobWordTab');
  if (panel) panel.classList.toggle('open', mobWordOpen);
  if (tab) tab.classList.toggle('tab-open', mobWordOpen);
  if (mobWordOpen) renderMobWordList();
}

function renderMobWordList() {
  const el = document.getElementById('mobWordList'); if (!el) return;
  if (!words.length) { el.innerHTML = '<div style="padding:12px;font-family:\'Share Tech Mono\',monospace;font-size:0.75rem;color:var(--muted);text-align:center">no reclist loaded</div>'; return; }
  el.innerHTML = words.map((w, i) => {
    const active = i === currentIdx, done = !!recordingBlobs[w];
    const dn = displayName(w);
    return `<div class="word-item ${active?'active':''} ${done?'done':''}" onclick="selectWord(${i});toggleMobWordList()"><span>${dn}</span><span class="word-status">${done?'REC':''}</span></div>`;
  }).join('');
  setTimeout(() => { const a = el.querySelector('.active'); if (a) a.scrollIntoView({ block: 'nearest' }); }, 0);
}

// ---- MOBILE MIRROR CONTROLS ----
// these keep the mob drawer controls in sync with the desktop ones
function onNoteSelectMob() {
  const val = parseFloat(document.getElementById('noteSelectMob').value);
  const ds = document.getElementById('toneSlider'); if (ds) ds.value = val;
  const dm = document.getElementById('toneSliderMob'); if (dm) dm.value = val;
  targetFreq = val;
  document.getElementById('toneVal').textContent = val.toFixed(0) + ' Hz';
  document.getElementById('toneValMob').textContent = val.toFixed(0) + ' Hz';
  document.getElementById('statusTone').textContent = val.toFixed(0) + ' Hz';
  snapNoteSelect(val);
  updatePitchTargetLine();
}
function onToneChangeMob() {
  const val = parseFloat(document.getElementById('toneSliderMob').value);
  const ds = document.getElementById('toneSlider'); if (ds) ds.value = val;
  targetFreq = val;
  document.getElementById('toneVal').textContent = val.toFixed(0) + ' Hz';
  document.getElementById('toneValMob').textContent = val.toFixed(0) + ' Hz';
  document.getElementById('statusTone').textContent = val.toFixed(0) + ' Hz';
  snapNoteSelect(val);
  updatePitchTargetLine();
}
function onOffsetChangeMob() {
  recOffset = parseInt(document.getElementById('recOffsetSliderMob').value);
  const ds = document.getElementById('recOffsetSlider'); if (ds) ds.value = recOffset;
  const lbl = (recOffset > 0 ? '+' : '') + recOffset + ' ms';
  const v1 = document.getElementById('recOffsetVal'); if (v1) v1.textContent = lbl;
  const v2 = document.getElementById('recOffsetValMob'); if (v2) v2.textContent = lbl;
}
function onSilenceChangeMob() {
  silenceThreshold = parseFloat(document.getElementById('silenceSliderMob').value);
  const ds = document.getElementById('silenceSlider'); if (ds) ds.value = silenceThreshold;
  const txt = silenceThreshold === 0 ? 'off' : silenceThreshold.toFixed(3);
  const v1 = document.getElementById('silenceVal'); if (v1) v1.textContent = txt;
  const v2 = document.getElementById('silenceValMob'); if (v2) v2.textContent = txt;
  _applyGlobalSilenceTrim();
}
function onMicChangeMob() {
  const sel = document.getElementById('micSelectMob');
  selectedDeviceId = sel ? sel.value : '';
  const ds = document.getElementById('micSelect'); if (ds) ds.value = selectedDeviceId;
  onMicChange();
}

// patch toggleRomaji and toggleAutoAdvance to also update mob mirror buttons
const _origToggleRomaji = toggleRomaji;
toggleRomaji = function() {
  _origToggleRomaji();
  const b = document.getElementById('romajiToggleBtnMob');
  if (b) { b.textContent = `Show Romaji: ${showRomaji?'ON':'OFF'}`; b.className = showRomaji ? 'btn active-toggle' : 'btn'; }
};
const _origToggleAutoAdvance = toggleAutoAdvance;
toggleAutoAdvance = function() {
  _origToggleAutoAdvance();
  const b = document.getElementById('autoAdvanceBtnMob');
  if (b) { b.textContent = `Auto-advance: ${autoAdvance?'ON':'OFF'}`; b.className = autoAdvance ? 'btn active-toggle' : 'btn'; }
};
const _origToggleHoverPlay = toggleHoverPlay;
toggleHoverPlay = function() {
  _origToggleHoverPlay();
  // desktop button is already updated inside the original; sync mob
  const b = document.getElementById('hoverPlayBtnMob');
  if (b) { b.textContent = `Hover Play: ${hoverPlay?'ON':'OFF'}`; b.className = hoverPlay ? 'btn active-toggle' : 'btn'; }
};

// patch populateMicList to also fill mob select
const _origPopulateMicList = populateMicList;
populateMicList = async function() {
  await _origPopulateMicList();
  // mirror to mob select
  const src = document.getElementById('micSelect');
  const dst = document.getElementById('micSelectMob');
  if (src && dst) { dst.innerHTML = src.innerHTML; dst.value = selectedDeviceId; }
};

// ---- INIT ----
window.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('toneSlider');
  if (slider) {
    targetFreq = parseFloat(slider.value);
    document.getElementById('toneVal').textContent = targetFreq.toFixed(0) + ' Hz';
    document.getElementById('statusTone').textContent = targetFreq.toFixed(0) + ' Hz';
    snapNoteSelect(targetFreq);
    updatePitchTargetLine();
  }
  // restore saved colors
  const savedAccent = localStorage.getItem('bonemo_accent_color');
  if (savedAccent) _applyChannelColor('accent', savedAccent, false);
  const savedBg = localStorage.getItem('bonemo_bg_color');
  if (savedBg) _applyChannelColor('bg', savedBg, false);
  const savedText = localStorage.getItem('bonemo_text_color');
  if (savedText) _applyChannelColor('text', savedText, false);
  // restore CRT
  if (localStorage.getItem('bonemo_crt') === '0') _applyCrt(false, false);
  // restore rainbow
  // rainbow is not persisted per-channel (too complex for restore)
});

// ---- COLOR MATH ----
function hexToRgb(hex) {
  hex = hex.replace('#','');
  if (hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
  return { r:parseInt(hex.slice(0,2),16), g:parseInt(hex.slice(2,4),16), b:parseInt(hex.slice(4,6),16) };
}
function hexToHsv(hex) {
  let {r,g,b} = hexToRgb(hex); r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
  let h=0, s=max===0?0:d/max, v=max;
  if (d!==0) {
    if(max===r) h=((g-b)/d+6)%6;
    else if(max===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h*=60;
  }
  return {h,s,v};
}
function hsvToRgb(h,s,v) {
  const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
  let r=0,g=0,b=0;
  if(h<60){r=c;g=x;}else if(h<120){r=x;g=c;}else if(h<180){g=c;b=x;}
  else if(h<240){g=x;b=c;}else if(h<300){r=x;b=c;}else{r=c;b=x;}
  return {r:Math.round((r+m)*255),g:Math.round((g+m)*255),b:Math.round((b+m)*255)};
}
function hsvToHex(h,s,v) {
  const {r,g,b}=hsvToRgb(h,s,v);
  return '#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('');
}
function hsvToHsl(h,s,v) {
  const l=v*(1-s/2), sl=(l===0||l===1)?0:(v-l)/Math.min(l,1-l);
  return {h,s:sl,l};
}
function hexToRgba(hex,a) { const {r,g,b}=hexToRgb(hex); return `rgba(${r},${g},${b},${a})`; }
function deriveGood(hex) {
  const {r,g,b}=hexToRgb(hex);
  return '#'+[Math.round(r*0.6),Math.min(255,Math.round(g*1.1+20)),Math.round(b*0.7)].map(x=>x.toString(16).padStart(2,'0')).join('');
}
function hexToHue(hex) { return hexToHsv(hex).h; }

// ---- APPLY COLORS ----
const DEFAULTS = { accent:'#00ffcc', bg:'#0a0a0f', text:'#ddeeff' };

function _applyChannelColor(ch, hex, save=true) {
  const root = document.documentElement;
  if (ch === 'accent') {
    root.style.setProperty('--accent', hex);
    root.style.setProperty('--good', deriveGood(hex));
    const rotation = hexToHue(hex) - 174;
    const svg = document.getElementById('skullSvg');
    if (svg) svg.style.filter = `hue-rotate(${rotation}deg)`;
    let ds = document.getElementById('dynAccentStyle');
    if (!ds) { ds = document.createElement('style'); ds.id='dynAccentStyle'; document.head.appendChild(ds); }
    ds.textContent = `
      .seq-divider{background:${hex}!important;box-shadow:0 0 6px ${hex},0 0 14px ${hex},0 0 28px ${hexToRgba(hex,0.4)}!important;}
      h1{text-shadow:0 0 20px ${hex},0 0 40px ${hexToRgba(hex,0.3)}!important;}
      #cpPanel{border-top-color:${hex}!important;}
    `;
    // Clear recordings buttons: accent color with reversed hue (+180deg)
    const {h:ah, s:as, v:av} = hexToHsv(hex);
    const revHex = hsvToHex((ah + 180) % 360, as, av);
    document.querySelectorAll('.btn.danger').forEach(btn => {
      btn.style.borderColor = revHex;
      btn.style.color = revHex;
      btn.style.background = hexToRgba(revHex, 0.06);
    });
  } else if (ch === 'bg') {
    // derive bg2 and bg3 as slightly lighter variants
    const {r,g,b} = hexToRgb(hex);
    const l = (v,a) => '#'+[r,g,b].map(x=>Math.min(255,Math.round(x+a)).toString(16).padStart(2,'0')).join('');
    root.style.setProperty('--bg', hex);
    root.style.setProperty('--bg2', l(hex, 10));
    root.style.setProperty('--bg3', l(hex, 22));
    root.style.setProperty('--border', l(hex, 28));
  } else if (ch === 'text') {
    root.style.setProperty('--text', hex);
    // derive muted as dimmer version
    const {r,g,b}=hexToRgb(hex);
    const muted = '#'+[r,g,b].map(x=>Math.round(x*0.45).toString(16).padStart(2,'0')).join('');
    root.style.setProperty('--muted', muted);
  }
  if (save) localStorage.setItem(`bonemo_${ch}_color`, hex);
}

function cpResetAll() {
  Object.entries(DEFAULTS).forEach(([ch,hex]) => _applyChannelColor(ch, hex, true));
  localStorage.removeItem('bonemo_accent_color');
  localStorage.removeItem('bonemo_bg_color');
  localStorage.removeItem('bonemo_text_color');
  if (cpOpen) _cpInitAll();
}

// ---- CRT TOGGLE ----
let crtOn = true;
function toggleCrt() { _applyCrt(!crtOn, true); }
function _applyCrt(on, save) {
  crtOn = on;
  document.body.classList.toggle('no-crt', !on);
  const btn = document.getElementById('cpCrtBtn');
  if (btn) { btn.textContent = on ? 'CRT OFF' : 'CRT ON'; btn.classList.toggle('on', !on); }
  if (save) localStorage.setItem('bonemo_crt', on ? '1' : '0');
}

// ---- RAINBOW MODE (per-channel, hue-only) ----
let _rainbowRafs = {}; // per-channel RAF ids
let _rainbowHues = {}; // per-channel current hue
let rainbowActive = {}; // per-channel boolean: {accent:false, bg:false, text:false}

function toggleRainbow(ch) {
  rainbowActive[ch] = !rainbowActive[ch];
  const btn = document.getElementById(`cpRainbowBtn-${ch}`);
  if (btn) btn.classList.toggle('active', rainbowActive[ch]);
  if (rainbowActive[ch]) {
    _rainbowHues[ch] = cpState[ch].h;
    _rainbowTick(ch);
  } else {
    if (_rainbowRafs[ch]) { cancelAnimationFrame(_rainbowRafs[ch]); _rainbowRafs[ch]=null; }
  }
}

function _rainbowTick(ch) {
  if (!rainbowActive[ch]) return;
  _rainbowHues[ch] = (_rainbowHues[ch] + 0.8) % 360;
  // Only change hue — preserve current sat and val
  const {s, v} = cpState[ch];
  const hex = hsvToHex(_rainbowHues[ch], s, v);
  _applyChannelColor(ch, hex, true);
  if (cpOpen) {
    _cpSetState(ch, _rainbowHues[ch], s, v);
    _cpDrawCol(ch);
    _cpSyncCol(ch);
  }
  _rainbowRafs[ch] = requestAnimationFrame(() => _rainbowTick(ch));
}

// ---- CUSTOM COLOR PICKER ----
const CP_SWATCHES = ['#00ffcc','#ff4466','#ffcc00','#00aaff','#ff00ff','#ff6600','#00ff88','#aa00ff','#ff0055','#ffffff'];
const CHANNELS = ['accent','bg','text'];

// per-channel HSV state
const cpState = {
  accent: { h:174, s:1, v:1 },
  bg:     { h:240, s:0.4, v:0.06 },
  text:   { h:210, s:0.2, v:0.87 },
};
// init rainbow per-channel state
CHANNELS.forEach(ch => { rainbowActive[ch]=false; _rainbowHues[ch]=cpState[ch].h; });
let cpOpen = false;
let _cpDragging = null; // { ch, type }
let _cpActiveSwatchCh = 'accent';

function toggleCP(e) { e.stopPropagation(); cpOpen ? closeCP() : openCP(); }

function openCP() {
  cpOpen = true;
  document.getElementById('cpPopup').style.display = 'block';
  const skull = document.getElementById('skullBtn');
  const rect = skull.getBoundingClientRect();
  const panel = document.getElementById('cpPanel');
  requestAnimationFrame(() => {
    const pw = panel.offsetWidth, ph = panel.offsetHeight;
    let x = rect.left, y = rect.bottom + 8;
    if (x + pw > window.innerWidth - 8) x = window.innerWidth - pw - 8;
    if (y + ph > window.innerHeight - 8) y = rect.top - ph - 8;
    panel.style.left = Math.max(4,x)+'px';
    panel.style.top  = Math.max(4,y)+'px';
    _cpInitAll();
    // sync footer buttons
    CHANNELS.forEach(ch => {
      const rb = document.getElementById(`cpRainbowBtn-${ch}`);
      if (rb) rb.classList.toggle('active', rainbowActive[ch]);
    });
    const cb = document.getElementById('cpCrtBtn');
    if (cb) { cb.textContent = crtOn?'CRT OFF':'CRT ON'; cb.classList.toggle('on',!crtOn); }
  });
  _cpBindEvents();
}

function _cpInitAll() {
  CHANNELS.forEach(ch => {
    const cur = getComputedStyle(document.documentElement).getPropertyValue(
      ch==='accent'?'--accent': ch==='bg'?'--bg':'--text'
    ).trim() || DEFAULTS[ch];
    const hsv = hexToHsv(cur);
    cpState[ch].h = hsv.h; cpState[ch].s = hsv.s; cpState[ch].v = hsv.v;
    _cpDrawCol(ch);
    _cpSyncCol(ch);
  });
}

function closeCP() {
  cpOpen = false;
  document.getElementById('cpPopup').style.display = 'none';
  _cpUnbindEvents();
}

function cpApply(ch) {
  if (rainbowActive[ch]) toggleRainbow(ch);
  const {h,s,v} = cpState[ch];
  _applyChannelColor(ch, hsvToHex(h,s,v), true);
}

function cpHexTyped(ch, val) {
  val = val.replace(/[^0-9a-fA-F]/g,'');
  document.getElementById(`cpHex-${ch}`).value = val;
  if (val.length===6) {
    if (rainbowActive[ch]) toggleRainbow(ch);
    const hsv = hexToHsv('#'+val);
    _cpSetState(ch, hsv.h, hsv.s, hsv.v);
    _cpDrawCol(ch); _cpSyncCol(ch);
  }
}

function cpPickSwatch(hex) {
  const ch = _cpActiveSwatchCh;
  if (rainbowActive[ch]) toggleRainbow(ch);
  const hsv = hexToHsv(hex);
  _cpSetState(ch, hsv.h, hsv.s, hsv.v);
  _cpDrawCol(ch); _cpSyncCol(ch);
}

function _cpSetState(ch,h,s,v) { cpState[ch].h=h; cpState[ch].s=s; cpState[ch].v=v; }

// ---- drawing per column ----
function _cpDrawCol(ch) {
  _cpDrawSatVal(ch);
  _cpDrawHueTrack(ch);
  _cpDrawValTrack(ch);
  _cpDrawSatTrack(ch);
}

function _cpDrawSatVal(ch) {
  const cv = document.getElementById(`cpSatVal-${ch}`); if (!cv) return;
  const {h} = cpState[ch];
  const W=cv.width, H=cv.height, ctx=cv.getContext('2d');
  ctx.fillStyle=`hsl(${h},100%,50%)`; ctx.fillRect(0,0,W,H);
  const wg=ctx.createLinearGradient(0,0,W,0);
  wg.addColorStop(0,'rgba(255,255,255,1)'); wg.addColorStop(1,'rgba(255,255,255,0)');
  ctx.fillStyle=wg; ctx.fillRect(0,0,W,H);
  const bg=ctx.createLinearGradient(0,0,0,H);
  bg.addColorStop(0,'rgba(0,0,0,0)'); bg.addColorStop(1,'rgba(0,0,0,1)');
  ctx.fillStyle=bg; ctx.fillRect(0,0,W,H);
}
function _cpDrawHueTrack(ch) {
  const cv=document.getElementById(`cpHue-${ch}`); if(!cv) return;
  const W=cv.width,H=cv.height,ctx=cv.getContext('2d');
  const g=ctx.createLinearGradient(0,0,W,0);
  for(let i=0;i<=12;i++) g.addColorStop(i/12,`hsl(${i*30},100%,50%)`);
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
}
function _cpDrawValTrack(ch) {
  const cv=document.getElementById(`cpVal-${ch}`); if(!cv) return;
  const {h,s,v}=cpState[ch];
  const W=cv.width,H=cv.height,ctx=cv.getContext('2d');
  const hsl=hsvToHsl(h,s,1);
  const g=ctx.createLinearGradient(0,0,W,0);
  g.addColorStop(0,'#000'); g.addColorStop(1,`hsl(${h},${Math.round(hsl.s*100)}%,${Math.round(hsl.l*100)}%)`);
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
}
function _cpDrawSatTrack(ch) {
  const cv=document.getElementById(`cpSat-${ch}`); if(!cv) return;
  const {h,v}=cpState[ch];
  const W=cv.width,H=cv.height,ctx=cv.getContext('2d');
  const h1=hsvToHsl(h,0,v), h2=hsvToHsl(h,1,v);
  const g=ctx.createLinearGradient(0,0,W,0);
  g.addColorStop(0,`hsl(${h},${Math.round(h1.s*100)}%,${Math.round(h1.l*100)}%)`);
  g.addColorStop(1,`hsl(${h},${Math.round(h2.s*100)}%,${Math.round(h2.l*100)}%)`);
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
}

function _cpSyncCol(ch) {
  const {h,s,v}=cpState[ch];
  const hex=hsvToHex(h,s,v);
  // hex input
  const inp=document.getElementById(`cpHex-${ch}`); if(inp) inp.value=hex.slice(1).toUpperCase();
  // preview
  const pv=document.getElementById(`cpPreview-${ch}`);
  if(pv){pv.style.background=hex; pv.style.boxShadow=`0 0 12px ${hex}88`;}
  // sv thumb
  const svT=document.getElementById(`cpSvThumb-${ch}`);
  const svR=document.getElementById(`cpSatVal-${ch}`)?.getBoundingClientRect();
  const panR=document.getElementById('cpPanel')?.getBoundingClientRect();
  if(svT&&svR&&panR){
    svT.style.left=(svR.left-panR.left+s*svR.width)+'px';
    svT.style.top=(svR.top-panR.top+(1-v)*svR.height)+'px';
    svT.style.borderColor=v>0.45?'#fff':'#999';
  }
  // slider thumbs
  const setT=(id,trackId,pct)=>{
    const tr=document.getElementById(trackId); if(!tr) return;
    const r=tr.getBoundingClientRect();
    const th=document.getElementById(id); if(th) th.style.left=(pct*r.width)+'px';
  };
  setT(`cpHueThumb-${ch}`,`cpHue-${ch}`,h/360);
  setT(`cpValThumb-${ch}`,`cpVal-${ch}`,v);
  setT(`cpSatThumb-${ch}`,`cpSat-${ch}`,s);
}

function _cpBuildSwatches() {
  const row=document.getElementById('cpSwatchRow'); if(!row) return;
  row.innerHTML=CP_SWATCHES.map(c=>`<div class="cp-sw" style="background:${c}" onclick="cpPickSwatch('${c}')" title="${c}"></div>`).join('');
  // clicking a swatch targets whichever col the user last clicked
  document.querySelectorAll('.cp-col').forEach(col=>{
    col.addEventListener('mousedown',()=>{ _cpActiveSwatchCh=col.id.replace('cpCol-',''); },true);
  });
}

// ---- drag events ----
function _cpClientXY(e){ return e.touches?{x:e.touches[0].clientX,y:e.touches[0].clientY}:{x:e.clientX,y:e.clientY}; }

function _cpBindEvents() {
  CHANNELS.forEach(ch=>{
    const attach=(el,type)=>{
      if(!el) return;
      el._cpD=(e)=>{ _cpDragging={ch,type}; _cpHandle(ch,type,e); e.preventDefault(); };
      el.addEventListener('mousedown',el._cpD);
      el.addEventListener('touchstart',el._cpD,{passive:false});
    };
    attach(document.getElementById(`cpSatVal-${ch}`),'sv');
    attach(document.getElementById(`cpHue-${ch}`),'hue');
    attach(document.getElementById(`cpVal-${ch}`),'val');
    attach(document.getElementById(`cpSat-${ch}`),'sat');
  });
  window._cpMov=(e)=>{ if(_cpDragging){_cpHandle(_cpDragging.ch,_cpDragging.type,e); e.preventDefault&&e.preventDefault();} };
  window._cpUp=()=>{ _cpDragging=null; };
  window.addEventListener('mousemove',window._cpMov);
  window.addEventListener('mouseup',window._cpUp);
  window.addEventListener('touchmove',window._cpMov,{passive:false});
  window.addEventListener('touchend',window._cpUp);
}
function _cpUnbindEvents(){
  if(window._cpMov){window.removeEventListener('mousemove',window._cpMov);window.removeEventListener('touchmove',window._cpMov);}
  if(window._cpUp){window.removeEventListener('mouseup',window._cpUp);window.removeEventListener('touchend',window._cpUp);}
}

function _cpHandle(ch,type,e){
  if(rainbowActive[ch]) toggleRainbow(ch);
  _cpActiveSwatchCh=ch;
  const {x,y}=_cpClientXY(e);
  const st=cpState[ch];
  if(type==='sv'){
    const r=document.getElementById(`cpSatVal-${ch}`).getBoundingClientRect();
    st.s=Math.max(0,Math.min(1,(x-r.left)/r.width));
    st.v=Math.max(0,Math.min(1,1-(y-r.top)/r.height));
    _cpDrawValTrack(ch); _cpDrawSatTrack(ch);
  } else if(type==='hue'){
    const r=document.getElementById(`cpHue-${ch}`).getBoundingClientRect();
    st.h=Math.max(0,Math.min(360,((x-r.left)/r.width)*360));
    _cpDrawCol(ch);
  } else if(type==='val'){
    const r=document.getElementById(`cpVal-${ch}`).getBoundingClientRect();
    st.v=Math.max(0,Math.min(1,(x-r.left)/r.width));
    _cpDrawSatTrack(ch);
  } else if(type==='sat'){
    const r=document.getElementById(`cpSat-${ch}`).getBoundingClientRect();
    st.s=Math.max(0,Math.min(1,(x-r.left)/r.width));
    _cpDrawValTrack(ch);
  }
  _cpSyncCol(ch);
  _applyChannelColor(ch, hsvToHex(cpState[ch].h, cpState[ch].s, cpState[ch].v), true);
}

function audioBufferToWavBlob(buffer) {
  const nc=buffer.numberOfChannels,sr=buffer.sampleRate,dl=buffer.length*nc*2;
  const ab=new ArrayBuffer(44+dl),v=new DataView(ab);
  const ws=(o,s)=>{for(let i=0;i<s.length;i++)v.setUint8(o+i,s.charCodeAt(i));};
  ws(0,'RIFF');v.setUint32(4,36+dl,true);ws(8,'WAVE');ws(12,'fmt ');
  v.setUint32(16,16,true);v.setUint16(20,1,true);v.setUint16(22,nc,true);
  v.setUint32(24,sr,true);v.setUint32(28,sr*nc*2,true);v.setUint16(32,nc*2,true);
  v.setUint16(34,16,true);ws(36,'data');v.setUint32(40,dl,true);
  let off=44;
  for(let i=0;i<buffer.length;i++) for(let ch=0;ch<nc;ch++){
    const s=Math.max(-1,Math.min(1,buffer.getChannelData(ch)[i]));
    v.setInt16(off,s<0?s*0x8000:s*0x7FFF,true);off+=2;
  }
  return new Blob([ab],{type:'audio/wav'});
}
</script>
</body>
</html>
